\chapter{Tipos}
\label{chap:types}

En la introducci\'on ya comentamos algo sobre tipos, en particular la 
motivaci\'on de contar con ellos. En este cap\'itulo vamos a estudiar las 
nociones importantes sobre tipado, a su vez, vamos a tener un primer contacto
con la idea de definir sem\'antica. \

Es importante comentar que los tipos que estudiemos en este cap\'itulo van
a formar parte de los tipos concretos que usemos a lo largo de los dem\'as
cap\'itulos. A su vez, para estudiar tipado hace falta hacerlo sobre un
lenguaje, presentamos entonces la siguiente sintaxis abstracta la cual
se corresponder\'a con la sintaxis del lenguaje del cap\'itulo siguiente.

\begin{center} 

$\lrangles{Phrase} ::=$ $\lrangles{PBool}$ $|$ $\lrangles{PInt}$ $|$ $\lrangles{PReal}$ $|$ \\
$\odot \lrangles{Phrase}$ $|$ $\lrangles{Phrase} \otimes \lrangles{Phrase} $ $|$ \\
$\lrangles{Phrase} := \lrangles{Phrase}$ $|$ $skip$ $|$ $\lrangles{Phrase};\lrangles{Phrase}$ $|$ \\
$if \lrangles{Phrase} then \lrangles{Phrase} else \lrangles{Phrase}$ $|$\\
$while \lrangles{Phrase} do \lrangles{Phrase}$ $|$ \\
$new \ \delta var \lrangles{Id} := \lrangles{Phrase} in \lrangles{Phrase}$ $|$\\
$\lrangles{Id}$ $|$ $\lrangles{Phrase}\lrangles{Phrase}$ $|$\\
$\lambda \lrangles{Phrase}_\theta \ . \ \lrangles{Phrase} $ $|$ $rec \ \lrangles{Phrase}$

\end{center}

donde $\delta \in \lrangles{Data types}$, $\odot \in \{-, \neg\}$ y 
$\otimes \in \{+,-,*,/,\wedge,\vee,\Rightarrow,\Leftrightarrow\}$

\section{Tipos simples}

\subsection{Sintaxis}
Comencemos introduciendo tipos b\'asicos que representen los tipos de datos,
una vez con estos definidos, podemos definir los tipos b\'asicos para las
frases de nuestro lenguaje y agregar operadores para en base a estos
construir nuevos.\

Una pregunta a esta altura puede ser, ?`Por que tener dos clases de tipos 
distinta?; de momento puede no tener sentido esto, pero simplemente
comentamos que por el m\'etodo de evaluaci\'on de nuestro lenguaje
vamos a querer esta distinci\'on.\

Definamos, ahora si, la sintaxis de los tipos de dato b\'asicos, 
que vamos a llamar $data$ $types$ y la de los tipos de las frases que
llamaremos $phrase$ $types$ 

\begin{center} $\lrangles{data type} ::=$ $int$ $|$ $real$ $|$ $bool$ \end{center}

\begin{center} 

$\lrangles{phrase type}::=$ $\lrangles{data type}$ $|$ $\lrangles{phrase type} \rightarrow \lrangles{phrase type}$

\end{center}

De momento introducimos solamente el operador $\rightarrow$, adelante en este 
cap\'itulo vamos a agregar otros mas e iremos viendo como se completa nuestro
sistema de tipos.\

\subsection{Inferencia}
Para definir la inferencia de tipos primero vamos a necesitar introducir las 
nociones de contexto y juicio de tipado. Pero antes, veamos la idea general
sobre la inferencia de tipos, la idea es poder averiguar el tipo de una expresi\'on
usando informaci\'on de expresiones b\'asicas que tiene su tipos determinado e
informaci\'on de los tipos de los operadores del lenguaje.\\
Por ejemplo, nuestro lenguaje contiene el operador $+$ cuyo significado
es el usual, un posible tipo podr\'ia ser $int \rightarrow int \rightarrow int$
por lo tanto si tenemos la expresi\'on $v + w$, donde $v,w$ son variables en
nuestro lenguaje, vamos a querer poder inferir que los tipos de $v$ y $w$ son
$int$ y que el tipo de la expresi\'on completa $v + w$ es $int$.\

\

\

\noindent Definamos contexto y juicio de tipado, un contexto sera una lista de 
pares $\lrangles{Phrase}:\lrangles{phrase type}$, a la primera componente de este 
par le diremos pattern para hacer referencia a que durante la inferencia de tipos
necesitaremos hacer matching entre una expresi\'on concreta y una expresi\'on, el
pattern, en un contexto. Adem\'as la lista de patterns no tiene elementos repetidos.

\begin{center} 

$\lrangles{Context}::=$ $\varnothing$ $|$ $\lrangles{Context}, \lrangles{Pattern}:\lrangles{phrase type}$

\end{center}

una vez dada la definici\'on anterior estamos en condiciones de definir un juicio de tipado
este sera, una relaci\'on entre un contexto $\pi$ y un expresi\'on $e$
con su determinado tipo $\theta$, lo denotamos como

\begin{center} $\pi \vdash e : \theta$ \end{center}

y decimos que $e$ tiene tipo $\theta$ mediante $\pi$.\

Ahora estamos en posici\'on de definir la inferencia de tipos mediante reglas, a
continuaci\'on listamos las reglas para nuestro sistema de tipos y lenguaje antes
mencionados.

\

Sean \\
$\theta \in \lrangles{phrase type}$ \ \ \ $p \in \lrangles{pattern}$\\
$e \in \lrangles{phrase}$ \ \ \ $n,m \in \N$\\
$\pi \in \lrangles{context}$ \ \ \ $v \in \lrangles{Id}$\\

Comencemos con las expresiones simples que dan una primera idea sobre la inferencia

\begin{center}
\AxiomC{}
\RightLabel{$b \in \lrangles{PBool}$}
\UnaryInfC{$\pi \vdash b : bool$}
\DisplayProof
\quad
\AxiomC{}
\RightLabel{$i \in \lrangles{PInt}$}
\UnaryInfC{$\pi \vdash i : int$}
\DisplayProof

\quad

\AxiomC{}
\RightLabel{$r \in \lrangles{PReal}$}
\UnaryInfC{$\pi \vdash r : real$}
\DisplayProof
\end{center}

claramente, estas reglas de inferencia expresan que las expresiones simples
son totalmente independientes del contexto en el que se utilizan. Continuemos
con las reglas de inferencia para los operadores

\begin{center}
\AxiomC{$\pi \vdash e : int$}
\RightLabel{Ty Rule: $-$ $int$}
\UnaryInfC{$\pi \vdash -e : int$}
\DisplayProof
\quad
\AxiomC{$\pi \vdash e : real$}
\RightLabel{Ty Rule: $-$ $real$}
\UnaryInfC{$\pi \vdash -e : real$}
\DisplayProof
\end{center}

\begin{center}
\AxiomC{$\pi \vdash e : bool$}
\RightLabel{Ty Rule: $\neg$}
\UnaryInfC{$\pi \vdash \neg e : bool$}
\DisplayProof
\end{center}

\begin{center}
\AxiomC{$\pi \vdash e : int$}
\AxiomC{$\pi \vdash e' : int$}
\RightLabel{Ty Rule: $\otimes$ $int$. $\otimes \in \{+,-,*\}$}
\BinaryInfC{$\pi \vdash e \otimes e' : int$}
\DisplayProof

\quad

\AxiomC{$\pi \vdash e : real$}
\AxiomC{$\pi \vdash e' : real$}
\RightLabel{Ty Rule: $\otimes$ $real$. $\otimes \in \{+,-,*,/\}$}
\BinaryInfC{$\pi \vdash e \otimes e' : real$}
\DisplayProof
\end{center}

\begin{center}
\AxiomC{$\pi \vdash e : bool$}
\AxiomC{$\pi \vdash e' : bool$}
\RightLabel{Ty Rule: $\otimes$ $bool$. $\otimes \in \{\wedge,\vee,\Rightarrow,\Leftrightarrow\}$}
\BinaryInfC{$\pi \vdash e \otimes e' : bool$}
\DisplayProof
\end{center}

\begin{center}
\AxiomC{$\pi \vdash e : \delta$}
\AxiomC{$\pi \vdash e' : \delta$}
\RightLabel{Ty Rule: $=$. $\delta \in \lrangles{data \ type}$}
\BinaryInfC{$\pi \vdash e = e' : bool$}
\DisplayProof
\end{center}

Aqui ya se puede observar que para determinar si es correcto el tipo
de una expresi\'on nos hace falta utilizar el contexto. Veamos ahora
las reglas de inferencia para el tipado de una variable y el calculo
lambda tipado.

\begin{center}
\AxiomC{}
\RightLabel{Ty Rule: Var. $v:\theta \in \pi$}
\UnaryInfC{$\pi \vdash v : \theta$}
\DisplayProof
\end{center}

\begin{center}
\AxiomC{$\pi \vdash e : \theta \rightarrow \theta'$}
\AxiomC{$\pi \vdash e': \theta$}
\RightLabel{Ty Rule: App}
\BinaryInfC{$\pi \vdash ee' : \theta'$}
\DisplayProof
\end{center}

\begin{center}
\AxiomC{$\pi,\iota:\theta \vdash e : \theta'$}
\RightLabel{Ty Rule: Lambda}
\UnaryInfC{$\pi \vdash \lambda \ \iota_\theta \ . \ e : \theta \rightarrow \theta'$}
\DisplayProof
\end{center}

\begin{center}
\AxiomC{$\pi \vdash e : \theta \rightarrow \theta$}
\RightLabel{Ty Rule: Rec}
\UnaryInfC{$\pi \vdash rec \ e : \theta$}
\DisplayProof
\end{center}

Podemos observar en la regla Lambda, de momento, es la \'unica que modifica el contexto
agregando a este el identificador de variable con su respectivo tipo. \\

Para seguir avanzando en la definici\'on de las reglas de inferencia vamos a necesitar
entender de sub-tipos e intersecci\'on, ademas de enriquezer la gramatica de $\lrangles{phrase \ type}$.
Sin embargo, todav\'ia podemos dar una definici\'on mas que puede no resultar intuitiva,
esta se basa en una propiedad deseable de los lenguajes Algol-like, que es la del comando
$if \ then \ else$.

\begin{center}
\AxiomC{$\pi \vdash b : bool$}
\AxiomC{$\pi \vdash e : \theta$}
\AxiomC{$\pi \vdash e' : \theta$}
\RightLabel{Ty Rule: IfThenElse}
\TrinaryInfC{$\pi \vdash if \ b \ then \ e \ else \ e' \ : \theta$}
\DisplayProof
\end{center}

Lo interesante a notar es que, en principio uno estar\'ia tentando a decir que una expresi\'on
$e$ $=$ $if \ b \ then \ e' \ else \ e'' \ $ ''tiene" alg\'un tipo que se corresponda con las
expresi\'ones que son programas en el lenguaje, sin embargo aqui $e$ puede tener cualquiera
de los tipos b\'asicos o inclusive tipo $\theta \rightarrow \theta'$.\\

Veamos un ejemplo del chequeo de un juicio de tipado y que ademas involucre esta propiedad que
comentabamos antes, supongamos \\

\noindent
$\lambda \ f_{int \rightarrow int} . \ \lambda \ b_{bool} . \ \lambda \ i_{int} . $\

$if \ b \ then \ fi \ else \ i$
$:$
$(int \rightarrow int) \rightarrow bool \rightarrow int \rightarrow int$\\

luego tenemos la siguiente prueba de que el juicio es correcto.

\begin{prooftree}
\AxiomC{}
\RightLabel{Var}
\def\extraVskip{5pt}
\UnaryInfC{$\pi \vdash b:bool$}
\AxiomC{}
\RightLabel{Var}
\def\extraVskip{5pt}
\UnaryInfC{$\pi \vdash f:int \rightarrow int$}
\AxiomC{}
\RightLabel{Var}
\def\extraVskip{5pt}
\UnaryInfC{$\pi \vdash i:int$}
\RightLabel{App}
\def\extraVskip{5pt}
\BinaryInfC{$\pi \vdash fi : int$}
\AxiomC{}
\RightLabel{Var}
\UnaryInfC{$\pi \vdash i:int$}
\def\extraVskip{5pt}
\TrinaryInfC{$f:int \rightarrow int,b:bool,i:int \vdash if \ b \ then \ fi \ else \ i \ : \ int$}
\RightLabel{Lambda}
\def\extraVskip{5pt}
\UnaryInfC{$f:int \rightarrow int,b:bool \vdash  \lambda \ i_{int} . \ if \ b \ then \ fi \ else \ i \ : \ int \rightarrow int$}
\RightLabel{Lambda}
\def\extraVskip{5pt}
\UnaryInfC{$f:int \rightarrow int \vdash  \lambda \ b_{bool} . \ \lambda \ i_{int} . \ if \ b \ then \ fi \ else \ i \ : \ bool \rightarrow int \rightarrow int$}
\RightLabel{Lambda}
\def\extraVskip{5pt}
\UnaryInfC{$\vdash \lambda \ f_{int \rightarrow int} . \ \lambda \ b_{bool} . \ \lambda \ i_{int} . \ if \ b \ then \ fi \ else \ i \ : \ (int \rightarrow int) \rightarrow bool \rightarrow int \rightarrow int$}
\end{prooftree}

donde $\pi$ $=$ $f:int \rightarrow int,b:bool,i:int$

\subsection{Sem\'antica categorica}

\note {Para esto va a hacer faltar contar algunas cosas de categor\'ias, hacer algo aparte?.}

\section{Sub-tipos}

En la secci\'on anterior definimos la gram\'atica $\lrangles{data \ type}$ este representaba
los tipos de dato b\'asico de nuestro lenguaje, luego dos tipos b\'asico posibles son
$int$ y $real$, los cuales representan los conjuntos de enteros y reales matem\'aticos.
Algo interesante a pensar es que, los enteros forman parte de los reales, es decir,
$\N \subseteq \R$, luego surge la pregunta, ¿Existir\'a una forma de expresar esta relaci\'on 
como una relaci\'on entre los $\lrangles{data \ type}$?, la respuesta es s\'i y es el sub-tipado.\\

Para agregar sub-tipado a nuestro lenguaje no hace falta cambiar nada de la gram\'atica de los
tipos de dato ba\'sico ni otros, simplemente vamos a necesitar definir nuevas reglas de tipado
y definir un nuevo tipo de juicio de tipado.

\subsection{Inferencia}

Comencemos definiendo el nuevo juicio de tipado y las reglas de inferencia necesarias. Como mencionamos
antes, el nuevo juicio de tipado sera una relaci\'on entre tipos, sean $\theta$ y $\theta'$ tipos
diremos $\theta$ es sub-tipo de $\theta'$ cuando $\theta \leq \theta'$.\\

Primero veamos reglas de inferencia generales a cualquier tipo, empecemos discutiendo
una idea intuitiva de las reglas que ser\'ian deseables. Supongamos tenemos que la expresi\'on
$e$ tiene tipo $int$ y adem\'as que $int$ es sub-tipo de $real$, luego quisi\'eramos 
poder decir que $e$ tiene tipo $real$, adem\'as si suponemos un tipo $nat$ que es
sub-tipo de $int$, entonces deber\'iamos poder decir que $nat$ es sub-tipo de $real$,
es decir, tener transitividad entre los tipos, cualquier tipo es
sub-tipo de \'el mismo, es decir, los tipos son reflexivos. Para finalizar, 
supongamos tenemos $\theta_0 \leq \theta_0'$ y $\theta_1 \leq \theta_1'$ y adem\'as
que tenemos una expresi\'on $e$ que tiene tipo $theta_0' \rightarrow theta_1$. Luego
$e$ puede aplicarse a elementos de tipo $\theta_0$ y el resultado de tal aplicaci\'on
puede ser un elemento de tipo $\theta_1'$.

Ahora si presentemos la reglas de inferencia,

\begin{center}
\AxiomC{$\pi \vdash e : \theta$}
\AxiomC{$\theta \leq \theta'$}
\RightLabel{Ty Rule: Subsumption}
\BinaryInfC{$\pi \vdash e : \theta'$}
\DisplayProof
\end{center}

\begin{center}
\AxiomC{$\theta \leq \theta'$}
\AxiomC{$\theta' \leq \theta''$}
\RightLabel{Ty Rule: Trans}
\BinaryInfC{$\theta \leq \theta''$}
\DisplayProof
\quad
\AxiomC{}
\RightLabel{Ty Rule: Reflex}
\UnaryInfC{$\theta \leq \theta$}
\DisplayProof
\end{center}

\begin{center}
\AxiomC{$\theta_0 \leq \theta_0'$}
\AxiomC{$\theta_1 \leq \theta_1'$}
\RightLabel{Ty Rule: Func}
\BinaryInfC{$\theta_0' \rightarrow \theta_1 \leq \theta_0 \rightarrow \theta_1'$}
\DisplayProof
\end{center}

Como mencionamos antes, las reglas anteriores son generales para cualquier tipado.
Definamos ahora mas reglas en relaci\'on a nuestros tipos y lenguaje concreto,
esto es b\'asicamente definir la relaci\'on entre enteros y reales. Luego podemos
analizar un poco que relaci\'on nos implica esto para otros tipos mas complejos.

\begin{center}
\AxiomC{}
\RightLabel{Ty Rule: intToreal}
\UnaryInfC{$int \leq real$}
\DisplayProof
\end{center}

Podemos ahora pensar en la relaci\'on entre nuestros tipos con el siguiente diagrama

\begin{diagram}[size=2em]
  real & & bool & & & \\
  \uLine^{} & & & & & \\
  int & & & &
\end{diagram}

Un ejemplo de la relaci\'on entre tipos funcionales usando la regla Func podr\'ia ser

\begin{diagram}[size=2em]
   & & int \rightarrow real & \\
   & \ruLine^{} & & \luLine^{} & \\
   int \rightarrow int & & & & real \rightarrow real \\
   & \rdLine^{} & & \ldLine^{} & \\
   & & real \rightarrow int & 
\end{diagram}

\subsection{Sem\'antica categorica}

\section{Intersecci\'on}

