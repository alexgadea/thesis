\chapter{Calculo lambda simplemente tipado}
\label{chap:lambdaarrow}

En este cap\'itulo presentaremos un lenguaje funcional con tipado 
explicito simple. La idea de comenzar con 
este lenguaje, \'el cual ya tiene sem\'antica bien conocida, es introducir
los primeros conceptos relevantes para esta tesis sobre
los sistemas de tipado simple, as\'i
como de la sem\'antica denot\'acional del lenguaje, ademas es lo 
suficientemente simple como para no eclipsar el aprendizaje de 
conceptos sobre la implementaci\'on de su evaluador utilizando
tipos dependientes.

\section{Sintaxis de $\lambdaarrow$}

En esta secci\'on vamos a introducir la sint\'axis de los t\'erminos de $\lambdaarrow$
y de los tipos. Empezamos introduciendo la sintaxis abstracta de los tipos simples.\\

\noindent
$\lrangles{Type}$ ::= $\boolt$ | $\intt$ | $\realt$\\
\indent \indent \ \
| $\lrangles{Type} \rightarrow \lrangles{Type}$\\

Ahora bien $\boolt$, $\intt$ y $\realt$ representaran 
los conjuntos de booleanos, enteros y reales respectivamente, y si 
$\theta$ y $\theta'$ son tipos,
$\theta \rightarrow \theta'$ sera la representaci\'on del conjunto
de funciones que acepta valores de tipo $\theta$ y retorna valores
de tipo $\theta'$, en ocasiones nos referiremos a este tipo como
\textit{tipo flecha}. Hay que mencionar que $\rightarrow$ asocia a derecha.\\

Con el lenguaje de los tipos definido podemos dar la sint\'axis
abstracta del lenguaje, notar que por el tipado explicito de la abstracci\'on
lambda nos hace falta tener definida la sintaxis de los tipos.\\

\noindent
$\lrangles{Phrase}$ ::= $\lrangles{PBool}$ | $\lrangles{PInt}$ | $\lrangles{PReal}$\\
\indent \indent \indent 
| $\odot$ $\lrangles{Phrase}$ | $\lrangles{Phrase}$ $\circledcirc$ $\lrangles{Phrase}$\\
\indent \indent \indent 
| $\textbf{if}$ $\lrangles{Phrase}$ $\textbf{then}$ $\lrangles{Phrase}$ $\textbf{else}$ $\lrangles{Phrase}$\\
\indent \indent \indent 
| $\lrangles{Id}$\\
\indent \indent \indent 
| $\lrangles{Phrase}\lrangles{Phrase}$\\
\indent \indent \indent 
| $\lambda$ $\lrangles{Id}_\theta$ . $\lrangles{Phrase}$\\
\indent \indent \indent 
| $\textbf{rec} \lrangles{Phrase}$\\

\noindent
$\lrangles{PBool}$ ::= $True$ | $False$\\

\noindent
$\lrangles{PNat}$ ::= $0$ | $1$ | $2$ | $\ldots$\\

\noindent
$\lrangles{PInt}$ ::= $\ldots$ | $-2$ | $-1$ | $\lrangles{PNat}$\\

\noindent
$\lrangles{PReal}$ ::= $\lrangles{PNat}$.\{$\lrangles{PNat}$\}+\\
\indent \indent \ \ \ \
| $- \lrangles{PNat}$.\{$\lrangles{PNat}$\}+\\

\noindent
donde \ 

$\lrangles{\textit{Id}}$ es un conjunto numerable.

$\theta \in \lrangles{Type}$ \

$\odot \in \{-, \neg\}$ y \

$\circledcirc \in \{+,-,*,/,\div,\rem,\wedge,\vee,\Rightarrow,\Leftrightarrow, =,\neq,<,>,\leq,\geq\}$\\

Antes de continuar con la sem\'antica de $\lambdaarrow$
vamos a introducir 
\begin{inparaenum}
\item contextos, que van a permitir anotar el tipo de los identificadores
de las frases
\item juicios de tipado, que ser\'a una relaci\'on entre un contexto, una frase y
un tipo
\item las reglas de inferencia de tipos, que nos van a permitir decidir que juicios
son validos y cuales no mediante una derivaci\'on
\item la sem\'antica de los tipos.\\
\end{inparaenum}

Empecemos introduciendo la idea de contexto, este ser\'a una lista 
de pares que asocian un identificador 
con un tipo, con la restricci\'on de que no pueden
existir identificadores repetidos, esta restricci\'on no es menor y mas
adelante cuando tengamos definidas las reglas de inferencia vamos a
ver alguna consecuencia de esta elecci\'on. En particular, para
definir los contextos usamos una gram\'atica, esto
nos va a permitir tener una versi\'on sint\'actica de los contextos
y ademas una sem\'antica la cual, un poco mas adelante, vamos a
necesitar para definir la sem\'antica del lenguaje.

\begin{definition}\label{lambdaa:context}

Un contexto estar\'a definido por la siguiente gram\'atica,\\

\noindent
$\lrangles{Context}$ ::= $\varnothing$ | $\lrangles{Context}$,$\lrangles{Id}$:$\lrangles{Type}$\\

\noindent
tal que dado cualquier contexto $\iota_0:\theta_0,\ldots,\iota_n:\theta_n$, los
identificadores $\iota_0,\ldots,\iota_n$ son todos distintos.

\end{definition}

La raz√≥n por la que la definici\'on de contextos tiene la restricci\'on de
no tener identificadores repetidos la
dejamos para mas adelante cuando terminemos de introducir los juicios de tipado, 
que es lo que empezaremos a hacer a continuaci\'on.

\begin{definition}\label{lambdaa:typejugment}

Un juicio de tipado sera una relaci\'on entre un contexto $\pi$, una
frase del lenguaje $e$ y un tipo $\theta$ que establecer\'a que
bajo el contexto $\pi$ la expresi\'on $e$ tiene tipo $\theta$.
Lo denotaremos como  $\pi \vdash e : \theta$, 
en particular, cuando $\pi = \varnothing$ escribiremos
$\vdash e : \theta$

\end{definition}

\section{Reglas de inferencia para $\lambdaarrow$}

Antes definimos los contextos como listas de pares y dimos restricciones 
en el sentido de que no cualquier lista de pares era una contexto valido,
ahora necesitamos algo parecido para los juicios de tipado, queremos
una manera de decidir que juicios son validos y cuales no, para esto
vamos a definir las reglas de inferencia, empecemos estableciendo algunas
metavariables generales:

\begin{center}
\begin{tabular}{ l r }
	$\theta$ $\in \lrangles{Type}$ & $\pi$ $\in \lrangles{Context}$ \\
	$\delta$ $\in \{ \boolt,\intt,\realt \}$ & \\
	$e$ $\in \lrangles{Phrase}$ & $\iota$ $\in \lrangles{Id}$ \\
	$n$, $m$ \ \ $\in \N$ & $b$ \ \ $\in \B$ \\
	$i$ \ \ $\in \Z$ & $r$ \ \ $\in \R$ 
\end{tabular}
\end{center}

\noindent 
Ahora s\'i presentamos las reglas de inferencia:\\

\noindent
$\texttt{Ty Rule:}$ Constantes.

\begin{center}
\AxiomC{}
\UnaryInfC{$\pi \vdash b : \boolt$}
\DisplayProof
\quad
\AxiomC{}
\UnaryInfC{$\pi \vdash i : \intt$}
\DisplayProof
\quad
\AxiomC{}
\UnaryInfC{$\pi \vdash r : \realt$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ Operadores b\'asicos.

\begin{center}
\AxiomC{$\pi \vdash e : \boolt$}
\UnaryInfC{$\pi \vdash \neg e : \boolt$}
\DisplayProof
\quad
\AxiomC{$\pi \vdash e : \intt$}
\UnaryInfC{$\pi \vdash -e : \intt$}
\DisplayProof
\quad
\AxiomC{$\pi \vdash e : \realt$}
\UnaryInfC{$\pi \vdash -e : \realt$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{$\pi \vdash e : \intt$}
\AxiomC{$\pi \vdash e' : \intt$}
\RightLabel{$\otimes \in \{+,-,*,/\ , \textbf{rem}\}$}
\BinaryInfC{$\pi \vdash e \otimes e' : \intt$}
\DisplayProof

\quad

\quad

\AxiomC{$\pi \vdash e : \realt$}
\AxiomC{$\pi \vdash e' : \realt$}
\RightLabel{$\otimes \in \{+,-,*\}$}
\BinaryInfC{$\pi \vdash e \otimes e' : \realt$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{$\pi \vdash e : \boolt$}
\AxiomC{$\pi \vdash e' : \boolt$}
\RightLabel{$\owedge \in \{\wedge,\vee,\Rightarrow,\Leftrightarrow\}$}
\BinaryInfC{$\pi \vdash e \owedge e' : \boolt$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{$\pi \vdash e : \delta$}
\AxiomC{$\pi \vdash e' : \delta$}
\RightLabel{$\delta \in \{\intt, \realt \}, \olessthan \in \{<,>,\leq,\geq\}$}
\BinaryInfC{$\pi \vdash e \olessthan e' : \boolt$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{$\pi \vdash e : \delta$}
\AxiomC{$\pi \vdash e' : \delta$}
\RightLabel{$\ominus \in \{=,\neq\}$}
\BinaryInfC{$\pi \vdash e \ominus e' : \boolt$}
\DisplayProof
\end{center}

\

Veamos ahora las reglas referidas a la parte del c\'alculo lambda simplemente tipado, 
adem\'as de la regla para el tipado de un identificador.\\

\noindent
$\texttt{Ty Rule:}$ Aplicaci\'on.

\begin{center}
\AxiomC{$\pi \vdash e : \theta \rightarrow \theta'$}
\AxiomC{$\pi \vdash e': \theta$}
\BinaryInfC{$\pi \vdash ee' : \theta'$}
\DisplayProof
\end{center}

\noindent
$\texttt{Ty Rule:}$ Operador de punto fijo.

\begin{center}
\AxiomC{$\pi \vdash e : \theta \rightarrow \theta$}
\UnaryInfC{$\pi \vdash \rec{e} : \theta$}
\DisplayProof
\end{center}

En la regla de tipado de un identificador se observa c\'omo hace falta
consultar el contexto para determinar el tipo del identificador. Esta
consulta ayuda a chequear, por supuesto el tipo, pero adem\'as que el
identificador no est\'e libre en el contexto de una frase mas compleja,
ya que si este identificador fuera libre para la frase entonces no podr\'iamos
justificar la pertenencia al contexto.

\

\noindent
$\texttt{Ty Rule:}$ Identificador.

\begin{center}
\AxiomC{$\iota:\theta \in \pi$}
\RightLabel{}
\UnaryInfC{$\pi \vdash \iota : \theta$}
\DisplayProof
\end{center}

En la regla anterior consult\'abamos el contexto, en la regla para
la abstracci\'on lambda vamos a agregar un identificador con su respectivo 
tipo. La abstracci\'on lambda la podr\'iamos haber definido de dos maneras bien distintas,
con tipado explicito o tipado impl\'icito, la diferencia est\'a en si especificamos
el tipo del identificador o no.\\

\noindent
$\texttt{Ty Rule:}$ Abstracci\'on lambda.

\begin{center}
\AxiomC{$\pi,\iota:\theta \vdash e : \theta'$}
\UnaryInfC{$\pi \vdash \clambda{\iota}{\theta}{e} : \theta \rightarrow \theta'$}
\DisplayProof
\end{center}

Para terminar con la reglas de inferencia de este lenguaje tenemos la regla de la
expresi\'on condicional.

\

\noindent
$\texttt{Ty Rule:}$ Expresi\'on condicional.

\begin{center}
\AxiomC{$\pi \vdash b  : \boolt$}
\AxiomC{$\pi \vdash e  : \theta$}
\AxiomC{$\pi \vdash e' : \theta$}
\TrinaryInfC{$\pi \vdash \cifthenelse{b}{e}{e'} : \theta$}
\DisplayProof
\end{center}

Ahora que hemos terminado de definir todas las reglas de inferencia, podemos
mencionar la raz\'on por la cual en la definici\'on de nuestros contexto no
permitimos tener identificadores repetidos. Tomemos la frase 
$\clambda{\iota}{\intt}{\clambda{\iota'}{\realt} \ \iota'}$, la derivaci\'on
para tipar esta frase ser\'ia\\

\begin{center}
\AxiomC{$\iota':\theta \in \iota:\intt, \iota':\realt$}
\UnaryInfC{$\iota:\intt, \iota':\realt \vdash \iota' : \theta$}
\UnaryInfC{$\iota:\intt \vdash \clambda{\iota'}{\realt} \ \iota' : \realt \rightarrow \theta$}
\UnaryInfC{$\vdash 
	\clambda{\iota}{\intt}{\clambda{\iota'}{\realt} \ \iota'} : 
									\intt \rightarrow \realt \rightarrow \theta$}
\DisplayProof
\end{center}

\

luego tenemos que $\theta$ debe ser $\realt$ y podemos concluir el juicio de tipado,
$\vdash 
	\clambda{\iota}{\intt}{\clambda{\iota'}{\realt} \ \iota'} : 
									\intt \rightarrow \realt \rightarrow \realt$.
Analicemos ahora que suceder\'ia si reemplaz\'aramos $\iota'$ por $\iota$, es decir
tuvi\'eramos la siguiente frase $\clambda{\iota}{\intt}{\clambda{\iota}{\realt} \ \iota}$,
la derivaci\'on es exactamente igual pero ahora surge un problema, $\theta$ podr\'ia
ser o bien $\intt$ o bien $\realt$, surge la pregunta entonces ¬ø como saber que tipo
es el correcto ? \\
Por otro lado, incluso reemplazando el tipo $\realt$ por $\intt$, es decir
tenemos la frase $\clambda{\iota}{\intt}{\clambda{\iota}{\intt} \ \iota}$, para la
cual tenemos una derivaci\'on del juicio de tipado 
$\vdash 
	\clambda{\iota}{\intt}{\clambda{\iota}{\intt} \ \iota} : 
									\intt \rightarrow \intt \rightarrow \intt$.
La pregunta que surge es ¬ø Cuando aplicamos esta frase a dos frases enteras, 
que valor debe tomar $\iota$ ?; supongamos tenemos el juicio anterior
aplicado a dos frases enteras, 
$\vdash 
	(\clambda{\iota}{\intt}{\clambda{\iota}{\intt} \ \iota}) \ 1 \ 2 : \intt$
el resultado de tal evaluaci\'on deber\'ia $2$ si nos basamos en la sem\'antica operacional.
Esto sucede porque la primera ocurrencia de $\iota$ no tiene participaci\'on en el alcance
de la segunda ocurrencia, es decir, ac\'a los par\'ametros de nuestras abstracciones lambda
llevan el mismo nombre pero son distintos par\'ametros, esto pensando en la funci\'on que define
nuestro ejemplo como una funci\'on que toma dos enteros y retorna otro.\\
Para finalizar entonces notemos que si restringimos los contextos no perdemos expresividad
para definir funciones y si solucionamos posibles problemas de tipado. La restricci\'on
entonces implica que la frase $\clambda{\iota}{\intt}{\clambda{\iota}{\intt} \ \iota}$
no tiene ning\'un juicio de tipado valido.

\section{Sem\'antica para $\lambdaarrow$}

Ya tenemos definida la sint\'axis de $\lambdaarrow$ en conjunto con las reglas
de inferencia para los distintos juicios de tipado de cada frase. Empecemos
esta secci\'on presentando la categor\'ia sem\'antica, que nombraremos $\CD$, 
esta sera una categor\'ia cartesiana cerrada, la cual iremos adaptando seg\'un 
las caracter\'isticas de nuestro lenguaje. 
Tanto para $\lambdaarrow$ como para $\lambdaleq$ esta sera $\Dom$.\\

Antes de continuar hagamos un repaso de cual es
la categor\'ia $\Dom$, esta tiene por objetos a 
dominios\footnote{Conjunto parcialmente ordenado con menor elemento.}
y por flechas a
funciones continuas\footnote{Una funci\'on $f$ entre predominios es continua si preserva
el limite de cadenas.}
. Adem\'as como caracter\'istica que nos va a interesar, 
tenemos la existencia del operador de punto fijo que representaremos como $\Y_D$
con $D$ un dominio y cuya existencia la garantiza \cite[P 2.5]{reynolds2009theories}, como
ya hemos mencionado es $\CCC$, donde el producto entre dos objetos $D$ y $D'$ 
es el producto cartesiano de conjuntos y el exponencial $D^{D'}$ es el conjunto 
de funciones continuas de $D'$ en $D$.
Mencionamos adem\'as que con $\bot$ vamos a representar la no terminaci\'on, esto
va a hacer falta ya que nuestro lenguaje b\'asico incluye operador de punto fijo.
La idea es que para interpretar los tipos elegimos 
objetos de esta categor\'ia, y para los juicios elegimos morfismos.\\

Por otro lado definimos $S_\delta$ como el conjunto de valores que representa a cada tipo
tal que $S_{\realt}$ ser\'a $\R$, $S_{\intt}$ ser\'a $\Z$ y $S_{\boolt}$ ser\'a $\{true,false\}$,
todos con orden llano.\\

Adem\'as de la categor\'ia sem\'antica vamos a definir dos categor\'ias mas,
una sera de los tipos ($\lrangles{Type}$) y
otra de contextos ($\lrangles{Context}$). Lo interesante sobre utilizar categor\'ias, sobre
todo para el significado de los juicios de tipado, ser\'a la capacidad de
adaptar las ecuaciones sem\'anticas a las distintas caracter\'isticas del lenguaje.

\begin{definition}\label{lambdaa:typescategory}
La categor\'ia de tipos, que nombraremos $\Theta$, sera una categor\'ia discreta tal que 
la colecci\'on de objetos esta definida como,\\

$\Theta_0$ $=$ $\{\theta \ | \ \theta \ \in \lrangles{Type} \}$

\end{definition}

\begin{definition}\label{lambdaa:contextcategory}
La categor\'ia de contextos, que nombraremos $\Pi$, sera una categor\'ia discreta tal que 
la colecci\'on de objetos esta definida como,\\

$\Pi_0$ $=$ $\{\pi \ | \ \pi \ \in \lrangles{Context} \}$

\end{definition}

Ahora s\'i, con los dominios necesarios, podemos definir dos funtores, 
uno entre $\Theta$ y $\CD$, y otro entre $\Pi$ y $\CD$. Esto implica definir 
funciones, que mapee objetos en objetos y flechas en flechas, como $\Theta$ y $\Pi$ 
son discreta, la definici\'on de estas ultimas funciones es directa, por lo 
tanto vamos a definir el mapeo de objetos en objetos.
En general cuando definamos funtores vamos a explicitar los \'indices, pero luego
cuando los utilicemos vamos a omitirlos.

\begin{definition}\label{lambdaa:typesemfunctor}
Sea $\semBrcks{ \_ } : \Theta \rightarrow \CD$ un funtor, tal que

$\semBrcks{\delta}_0$ $=$ $(S_\delta)_\bot$\\
\indent
$\semBrcks{\theta \rightarrow \theta'}_0$ $=$ $\semBrcks{\theta'}_0^{\semBrcks{\theta}_0}$

\end{definition}

Notar que como $\CD$ es $\mathcal{CCC}$ entonces podemos asegurar que existe el objeto exponencial.

\begin{definition}\label{lambdaa:contextsemfunctor}
Sea $\semBrcks{ \_ } : \Pi \rightarrow \CD$ un funtor, tal que

$\semBrcks{\pi}_0$ $=$ $\prod\limits_{\iota \in dom \ \pi} \semBrcks{\pi\iota}$

\end{definition}

Notar que como $\CD$ es $\mathcal{CCC}$ entonces tenemos productos finitos, como los
contextos son siempre finitos, la definici\'on es correcta.\\

Ahora estamos en condiciones de definir las ecuaciones sem\'anticas, para quien est\'e
familiarizado con la definici\'on de sem\'antica denotacional de lenguajes sin tipado
podemos comentar que las ecuaciones sem\'anticas se definen sobre un juicio 
de tipado y no sobre las frases en s\'i. Esto implica entonces, que para evaluar
un programa este antes debe haber pasado por el chequeo de tipos, es decir, 
tenemos una derivaci\'on del juicio de tipado.

Una ecuaci\'on sem\'antica entonces estar\'a definida por un juicio de tipado valido,
supongamos $\pi \vdash e : \theta$, un objeto de la categor\'ia $\CD$, determinado por 
el funtor $\semBrcks{\pi}$, otro objeto de $\CD$, determinado por $\semBrcks{\theta}$ y
un funtor sobre el juicio de tipado, tal que, 
$\semBrcks{\pi \vdash e : \theta} : \semBrcks{\pi} \rightarrow \semBrcks{\theta}$.\\

Agregamos a nuestra lista de metavariables, $\eta$ con tipo $\semBrcks{\pi}$, donde $\pi$
estar\'a determinado por el contexto donde usemos $\eta$.\\

Vamos a definir funciones \\

$(\_)_{\odot} : 
(S_\delta \rightarrow S_\delta) \rightarrow ((S_\delta)_\bot \rightarrow (S_\delta)_\bot)$\\
\indent
$f_{\odot} = (\iotabot \circ f )_{\dbot}$\\

$(\_)_{\circledcirc} : 
(S_\delta \rightarrow S_\delta \rightarrow S_{\delta'}) \rightarrow ((S_\delta)_\bot \rightarrow (S_\delta)_\bot \rightarrow (S_{\delta'})_\bot)$\\
\indent
$f_{\circledcirc} \ z \ z' = 
(\lambda x . \ (\lambda x' . \ \iotabot \ (f \ x \ x'))_{\dbot} z')_{\dbot} z$\\

Ahora s\'i comencemos con las definiciones de las ecuaciones sem\'anticas, un detalle 
es que las definiciones consideran $\CD$ como $\Dom$.\\

\noindent
$\texttt{Denotal Sem:}$ Constantes.\\

$\semBrcks{\pi \vdash b : \boolt} \eta$ $=$ $\iotabot b$\quad
$\semBrcks{\pi \vdash i : \intt} \eta$  $=$ $\iotabot i$\quad
$\semBrcks{\pi \vdash r : \realt} \eta$ $=$ $\iotabot r$

\

\noindent
$\texttt{Denotal Sem:}$ Operadores b\'asicos.\\

$\semBrcks{\pi \vdash -e : \intt}$ $=$ $-_{\odot} \circ \semBrcks{\pi \vdash e : \intt}$\\

$\semBrcks{\pi \vdash -e : \realt}$ $=$ $-_{\odot} \circ \semBrcks{\pi \vdash e : \realt}$\\

$\semBrcks{\pi \vdash \neg e : \boolt}$ $=$ $\neg_{\odot} \circ \semBrcks{\pi \vdash e : \boolt}$\\


$\semBrcks{\pi \vdash e \otimes e' : \intt}\eta$ $=$ 
$\otimes_{\circledcirc} \ \semBrcks{\pi \vdash e : \intt}\eta \
						\semBrcks{\pi \vdash e' : \intt}\eta$

\begin{center}
con $\otimes \in \{+,-,*,/\ , \rem\}$
\end{center}

$\semBrcks{\pi \vdash e \otimes e' : \realt}\eta$ $=$
$\otimes_{\circledcirc} \ \semBrcks{\pi \vdash e : \intt}\eta \
						\semBrcks{\pi \vdash e' : \intt}\eta$

\begin{center}
con $\otimes \in \{+,-,*\}$
\end{center}

$\semBrcks{\pi \vdash e \owedge e' : \boolt}\eta$ $=$
$\owedge_{\circledcirc} \ \semBrcks{\pi \vdash e : \intt}\eta \
						\semBrcks{\pi \vdash e' : \intt}\eta$

\begin{center}
con $\owedge \in \{\wedge,\vee,\Rightarrow,\Leftrightarrow\}$
\end{center}

$\semBrcks{\pi \vdash e \olessthan e' : \boolt}\eta$ $=$ 
$\olessthan_{\circledcirc} \ \semBrcks{\pi \vdash e : \intt}\eta \
						\semBrcks{\pi \vdash e' : \intt}\eta$

\begin{center}
con $\delta \in \{\intt, \realt \}, \olessthan \in \{<,>,\leq,\geq\}$
\end{center}

$\semBrcks{\pi \vdash e \ominus e' : \boolt}\eta$ $=$ 
$\ominus_{\circledcirc} \ \semBrcks{\pi \vdash e : \intt}\eta \
						\semBrcks{\pi \vdash e' : \intt}\eta$

\begin{center}
con $\ominus \in \{=,\neq\}$
\end{center}

Hasta aqu\'i tenemos definida la sem\'antica para las expresiones enteras,
reales y booleanas. Definamos ahora la parte interesante del lenguaje, esto 
es, la expresi\'on condicional, aplicaci\'on, abstracci\'on lambda, operador
de punto fijo e identificador. Parecido a como hicimos para los operadores,
definamos una funci\'on que llamaremos $\IF$ que ir\'a de $D \times D \times (S_{\boolt})_\bot$ en
$D$, con $D$ un dominio y cuya definici\'on es,

\[
\IF \lrangles{t, \ f, \ b}=
\begin{cases}
\bot & \text{si } b = \bot \\
t  & \text{si } b\\
f & \text{si } \neg b\\
\end{cases}
\]

\noindent
$\texttt{Denotal Sem:}$ Expresi\'on condicional.\

\

$\semBrcks{\pi \vdash \cifthenelse{b}{e}{e'} : \theta}\eta$ $=$ \\
\indent \indent \indent \indent \indent \indent \indent 
$\IF (\semBrcks{\pi \vdash e : \theta}\eta
	 , \ \semBrcks{\pi \vdash e' : \theta}\eta
	 , \ \semBrcks{\pi \vdash b : \boolt}\eta
	 )$

\newpage

\noindent
$\texttt{Denotal Sem:}$ Aplicaci\'on.\

\

$\semBrcks{\pi \vdash ee' : \theta'}\eta$ $=$ $\semBrcks{\pi \vdash e : \theta \rightarrow \theta'}\eta (\semBrcks{\pi \vdash e' : \theta}\eta)$

\

\noindent
$\texttt{Denotal Sem:}$ Abstracci\'on lambda.\

\

$\semBrcks{\pi \vdash \clambda{\iota}{\theta}{e} : \theta \rightarrow \theta'}$ $=$
		$\semBrcks{\pi,\iota:\theta \vdash e : \theta'} \circ ext_{\iota,\theta}$\\

donde 
$ext_{\iota,\theta} : \semBrcks{\pi} 
					  \rightarrow \semBrcks{\theta} \rightarrow \semBrcks{\pi,\iota:\theta}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \
$ext_{\iota,\theta} \eta \ x$ $=$ $[\ \eta \ | \ \iota:x \ ]$

\

\noindent
$\texttt{Denotal Sem:}$ Operador de punto fijo.\

\

$\semBrcks{\pi \vdash \rec{e} : \theta}\eta$ $=$ $\Y_{\theta} (\semBrcks{\pi \vdash e : \theta \rightarrow \theta}\eta)$

\

\noindent
$\texttt{Denotal Sem:}$ Identificador.\

\

$\semBrcks{\pi \vdash \iota : \theta}\eta$ $=$ $\eta \iota$\\

Estas ultimas ecuaciones nos terminan de definir la sem\'antica de nuestro 
primer lenguaje $\lambdaarrow$.

\section{Continuidad de las ecuaciones sem\'anticas de $\lambdaarrow$}

Ahora que tenemos nuestro lenguaje definido tanto sint\'acticamente como
sem\'anticamente, veamos algunas propiedades y caracter\'isticas. Tomemos
la ecuaci\'on sem\'antica de la abstracci\'on lambda y analic\'emosla un 
poco, podemos empezar notando que el significado que le estamos dando
a la abstracci\'on lambda de nuestro lenguaje se corresponde exactamente
con la noci\'on de funci\'on matem\'atica, recordando que 
$\semBrcks{\theta \rightarrow \theta'}$ $=$ $\semBrcks{\theta'}^{\semBrcks{\theta}}$\\

$\semBrcks{\pi \vdash \clambda{\iota}{\theta}{e} : \theta \rightarrow \theta'}\eta$ $:$
$\semBrcks{\theta'}^{\semBrcks{\theta}}$\\

\noindent
es decir, como ya mencionamos antes, el significado de la abstracci\'on lambda es
una funci\'on en $\Dom$, que va de $\semBrcks{\theta}$ en $\semBrcks{\theta'}$. Mirando
ahora la parte derecha,\\

$\semBrcks{\pi,\iota:\theta \vdash e : \theta'}  \circ (ext_{\iota,\theta} \eta) $ $:$
	$\semBrcks{\theta} \rightarrow \semBrcks{\theta'}$\\

\noindent
vemos que efectivamente es una funci\'on en el dominio correcto, adem\'as en\\

$\semBrcks{\pi,\iota:\theta \vdash e : \theta'}$ $:$ 
								$\semBrcks{\pi,\iota:\theta} \rightarrow \semBrcks{\theta'}$\\

\noindent
la aplicaci\'on del entorno $ext_\iota \eta \ x$ extendido tipa perfecto 
con $\semBrcks{\pi,\iota:\theta}$ dando como resultado el tipo esperado,\\

$\semBrcks{\pi,\iota:\theta \vdash e : \theta'}
	(ext_{\iota,\theta} \eta \ x)$ $:$ $\semBrcks{\theta'}$.\\

Acabamos de ver un poco m\'as de cerca la ecuaci\'on sem\'antica de la abstracci\'on
lambda, siguiendo con la etapa de an\'alisis de las ecuaciones que hemos definido
vamos a tomar la aplicaci\'on y realizar un an\'alisis categ\'orico, \'el cual
adem\'as nos servir\'a m\'as adelante para probar la continuidad de la 
aplicaci\'on.\\

Tomemos un juicio de tipado $\pi \vdash ee' : \theta'$ cualquiera; recordemos
adem\'as que dados dos tipos $\theta$ y $\theta'$, $\semBrcks{\theta'}^{\semBrcks{\theta}}$
es el objeto exponencial en $\Dom$, es decir, que adem\'as de este objeto tenemos
una flecha $\epsilon$,

\begin{diagram}
  \semBrcks{\theta'}^{\semBrcks{\theta}} \times \semBrcks{\theta} & \rTo^{\epsilon} & \semBrcks{\theta'}
\end{diagram}

\noindent
tal que para una flecha $D \times \semBrcks{\theta} \rTo^{f} \semBrcks{\theta'}$, con $D$
un dominio, existe una \'unica flecha $\widetilde{f}$ que hace conmutar el diagrama

\begin{diagram}
  \semBrcks{\theta'}^{\semBrcks{\theta}} \times \semBrcks{\theta} & \rTo^{\epsilon} & \semBrcks{\theta'}\\
  \uTo^{\widetilde{f} \times 1_{\semBrcks{\theta}}} & \ruTo_{f} & &  \\
  D \times \semBrcks{\theta} & & \\
\end{diagram}

Por otro lado, $\semBrcks{\pi \vdash e' : \theta} : \semBrcks{\pi} \rightarrow \semBrcks{\theta}$ y,
como ya vimos hace un momento, $\semBrcks{\pi \vdash e : \theta \rightarrow \theta'}$ $:$
$\semBrcks{\pi} \rightarrow \semBrcks{\theta'}^{\semBrcks{\theta}}$, luego podemos definir 
una flecha $f = \uncurry (\semBrcks{\pi \vdash e : \theta \rightarrow \theta'})$ luego,
$f : \semBrcks{\pi} \times \semBrcks{\theta} \rightarrow \semBrcks{\theta'}$. Por lo tanto
tenemos el siguiente diagrama,

\begin{diagram}
  \semBrcks{\theta'}^{\semBrcks{\theta}} \times \semBrcks{\theta} & \rTo^{\epsilon} & \semBrcks{\theta'}\\
  \uTo^{\widetilde{f} \times 1_{\semBrcks{\theta}}} & \ruTo_{f} & &  \\
  \semBrcks{\pi} \times \semBrcks{\theta} & & \\
\end{diagram}

\noindent
donde claramente $\widetilde{f} = \semBrcks{\pi \vdash e : \theta \rightarrow \theta'}$,
puesto que dado una flecha $g$, la transpuesta de $\uncurry(g) = g$.\\

Ahora, si tomamos una flecha $g$ tal que $g = \semBrcks{\pi \vdash e' : \theta}$, 
podemos obtener la siguiente flecha,

\begin{diagram}
\semBrcks{\pi} & \rTo^{\lrangles{1_{\semBrcks{\pi}} , 1_{\semBrcks{\pi}}}} 
			   & \semBrcks{\pi} \times \semBrcks{\pi} 
			   & \rTo^{1_{\semBrcks{\pi}} \times g}
			   & \semBrcks{\pi} \times \semBrcks{\theta}
			   & \rTo^{f}
			   & \semBrcks{\theta'}
\end{diagram}

\noindent
luego podemos combinar los dos diagramas, donde 
$(1_{\semBrcks{\pi}} \times g) \circ \lrangles{1_{\semBrcks{\pi}} , 1_{\semBrcks{\pi}}}$
$=$ $\lrangles{1_{\semBrcks{\pi}} , g}$ y obtener,

\begin{diagram}
  \semBrcks{\theta'}^{\semBrcks{\theta}} \times \semBrcks{\theta} & \rTo^{\epsilon} & \semBrcks{\theta'}\\
  \uTo^{\widetilde{f} \times 1_{\semBrcks{\theta}}} & \ruTo^{f} \ruTo(2,4) & &  \\
  \semBrcks{\pi} \times \semBrcks{\theta} & & f \circ \lrangles{1_{\semBrcks{\pi}} , g} & \\
  \uTo^{\lrangles{1_{\semBrcks{\pi}} , g}}  \ruTo(3,2) & & &  \\
  \semBrcks{\pi} & & &
\end{diagram}

Ahora usando este diagrama podemos definir la ecuaci\'on sem\'antica
de la aplicaci\'on como,\\

$\semBrcks{\pi \vdash ee' : \theta'}$ $=$ $\epsilon \circ \lrangles{\widetilde{f},g}$\\

donde $\lrangles{\widetilde{f},g} = (\widetilde{f} \times 1_{\semBrcks{\theta}}) \circ \lrangles{1_{\semBrcks{\pi}} , g}$.\\

Algo importante de notar es que esta definici\'on se corresponden exactamente
con la definici\'on previa que hicimos, para terminar con este an\'alisis 
comprobemos que efectivamente pasa esto. Pasando en limpio la nueva ecuaci\'on
de la aplicaci\'on es,\\

$\semBrcks{\pi \vdash ee' : \theta'}$ $=$ 
$\epsilon \circ \lrangles{\semBrcks{\pi \vdash e : \theta \rightarrow \theta'}
									,\semBrcks{\pi \vdash e' : \theta}}$\\

\noindent									
tomando un $\eta$ cualquiera tendremos,\\

$\semBrcks{\pi \vdash ee' : \theta'}\eta$ $=$ 
$\epsilon \circ \lrangles{\semBrcks{\pi \vdash e : \theta \rightarrow \theta'}
									,\semBrcks{\pi \vdash e' : \theta}} \eta$ $=$\\
\

$\epsilon \circ \lrangles{\semBrcks{\pi \vdash e : \theta \rightarrow \theta'}\eta
									,\semBrcks{\pi \vdash e' : \theta}\eta}$ $=$\\
\

$\semBrcks{\pi \vdash e : \theta \rightarrow \theta'}\eta
									(\semBrcks{\pi \vdash e' : \theta} \eta)$

\subsection{Continuidad}

Ahora estamos en condiciones de demostrar una propiedad importante que deben cumplir nuestras 
ecuaciones sem\'anticas, ser funciones continuas: no hay que olvidar
que cuando decimos que, dado un juicio $\pi \vdash e : \theta$, su sem\'antica ser\'a
un morfismo $\semBrcks{\pi} \rightarrow \semBrcks{\theta}$ en la categor\'ia $\Dom$.
Estamos comprometidos a que $\semBrcks{\pi \vdash e : \theta}$ sea una funci\'on
continua.\\

Empecemos enunciando algunas proposiciones que nos van a hacer \'util para
la prueba de continuidad, las pruebas de estas propiedades son mas bien simples
y se pueden encontrar en \cite{reynolds2009theories}.

\newpage

\begin{proposition}\

\begin{enumerate}

\item Si $P$ y $P'$ son predominios, $P \rightarrow P'$ es un predominio en
el cual el limite de la cadena de funciones $f_0 \sqsubseteq'' f_1 \sqsubseteq'' \cdots$ 
es una funci\'on tal que 

\begin{center}
$({\bigsqcup\limits^{\infty}_{i=0}}'' f_{i})x = {\bigsqcup\limits^{\infty}_{i=0}}' f_{i} x$
\end{center}

para todo $x \in P$. Adem\'as, si $P$ es un dominio, $P \rightarrow P'$ es un dominio
cuyo menor elemento es una funci\'on tal que $\bot'' x = \bot'$ para todo $x \in P$.

\item Supongamos $P$ y $P'$ son predominios, entonces:

\begin{enumerate}
\item[(a)] Una funci\'on constante de $P$ en $P'$ es la funci\'on continua de $P$ en $P'$.\\

\item[(b)] La funci\'on identidad en $P$ es una funci\'on continua de $P$ en $P$.\\

\item[(c)] Si f es una funci\'on continua de $P$ en $P'$ y g es una funci\'on
continua de $P'$ en $P''$, entonces $g \circ f$ es una funci\'on continua de $P$ en $P''$.\\

\item[(d)] Dada una cadena $f_0 \sqsubseteq'' f_1 \sqsubseteq'' \cdots$ tal que cada $f_i$ es una
funci\'on continua de $P$ en $P'$ y dada otra cadena $x_0 \sqsubseteq'' x_1 \sqsubseteq'' \cdots$ de
elementos de $P$, entonces vale

\begin{center}
${\bigsqcup\limits^{\infty}_{i=0}}{\bigsqcup\limits^{\infty}_{j=0}}f_i x_j$ $=$
${\bigsqcup\limits^{\infty}_{k=0}}f_k x_k$
\end{center}

\item[(e)] Dadas $n$ funciones $f_i$ de $P \rightarrow P_i$ tal que cada $f_i$ es continua, entonces
la funci\'on $\lrangles{f_0,f_1,\ldots,f_{n-1}}$ que satisface,

\begin{center}
$\lrangles{f_0,f_1,\ldots,f_{n-1}}x = \lrangles{f_0 x,f_1 x,\ldots,f_{n-1} x}$
\end{center}

es una funci\'on continua de $P$ en $P_0 \times P_1 \times \ldots \times P_{n-1}$.

\item[(f)] Dado un predominio $P$ y un dominio $D$, el operador $(\_)_{\dbot}$ que
extiende funciones de $P \rightarrow D$ en funciones de $P_{\bot} \rightarrow D$, es
continuo.

\item[(g)] $\Y_{D}$ es una funci\'on continua.

\end{enumerate}

\end{enumerate}

\end{proposition}

\begin{theorem}

Dado un juicio de tipado $\pi \vdash e : \theta$ la ecuaci\'on sem\'antica
$\semBrcks{\pi \vdash ~ e : \theta}$ es una funci\'on continua.

\end{theorem}

\begin{proof}

En la prueba vamos a proceder por inducci\'on en la estructura de la derivaci\'on 
de los juicios de tipado. Supongamos tenemos una cadena interesante
$\eta_0 \sqsubseteq \eta_1 \sqsubseteq \cdots$ en $\semBrcks{\pi}$ y probemos
que\\

$\semBrcks{\pi \vdash e : \theta}(\bigsqcup\limits^{\infty}_{i=0} \eta_i)$
$=$ $\bigsqcup\limits^{\infty}_{i=0} \semBrcks{\pi \vdash e : \theta}\eta_i$.\\

Nuestra hip\'otesis inductiva nos dir\'a que, suponiendo
tenemos una deriaci\'on $\pi \vdash e : \theta$ tal que
$\semBrcks{\pi \vdash e : \theta}$ es una funci\'on continua 
de $\semBrcks{\pi}$ en $\semBrcks{\theta}$ entonces para
una derivaci\'on mas compleja $\pi \vdash e : \theta$ que
contenga a la anterior $\semBrcks{\pi \vdash e : \theta}$ es 
una funci\'on continua de $\semBrcks{\pi}$ en $\semBrcks{\theta}$.\\

\begin{itemize}
\item Casos base.

\begin{itemize}
\item Para probar los casos base de los juicios de las constantes usamos Prop 1.2.a, 
que nos asegura que una funci\'on constante es funci\'on continua. 

\item Supongamos ahora que tenemos $\pi \vdash \iota : \theta$, luego \\

$\semBrcks{\pi \vdash \iota : \theta} (\bigsqcup\limits^{\infty}_{i=0} \eta_i)$ $=$
$(\bigsqcup\limits^{\infty}_{i=0} \eta_i)\iota$ $=$
$\bigsqcup\limits^{\infty}_{i=0} (\eta_i \iota)$ $=$
$\bigsqcup\limits^{\infty}_{i=0} (\semBrcks{\pi \vdash \iota : \theta}\eta_i)$\\

luego podemos concluir que $\semBrcks{\pi \vdash \iota : \theta}$ es una funci\'on
continua.
\end{itemize}

\item Casos inductivos
\begin{itemize}

\item Supongamos tenemos $\pi \vdash ee' : \theta$, como ya anticipamos antes, vamos a
usar la versi\'on categ\'oria de la ecuaci\'on, \\

$\semBrcks{\pi \vdash ee' : \theta}$ $=$
$\epsilon \circ \lrangles{\semBrcks{\pi \vdash e : \theta \rightarrow \theta'}
					     ,\semBrcks{\pi \vdash e' : \theta}}$\\

luego por hip\'otesis inductiva $\semBrcks{\pi \vdash e : \theta \rightarrow \theta'}$ y
$\semBrcks{\pi \vdash e' : \theta}$ son funciones continuas, entonces
$\lrangles{\semBrcks{\pi \vdash e : \theta \rightarrow \theta'}
					     ,\semBrcks{\pi \vdash e' : \theta}}$ es una funci\'on continua,
adem\'as como $\epsilon$ es la flecha del exponencial tambi\'en es continua; para
terminar la composici\'on de funciones continuas es una funci\'on continua. Por lo tanto
la ecuaci\'on sem\'antica $\semBrcks{\pi \vdash ee' : \theta}$ es una funci\'on 
continua.

\item Supongamos tenemos $\pi \vdash \rec{e} : \theta$, luego\\

$\semBrcks{\pi \vdash \rec{e} : \theta}(\bigsqcup\limits^{\infty}_{i=0} \eta_i)$ $=$ 
$\Y_{\semBrcks{\theta}}
	(\semBrcks{\pi \vdash e : \theta \rightarrow \theta} (\bigsqcup\limits^{\infty}_{i=0} \eta_i))$\\

Para hacer mas f\'acil la lectura nombramos a $\semBrcks{\pi \vdash e : \theta \rightarrow \theta}\eta_i = f_i$. Aplicando hip\'otesis inductiva en $\semBrcks{\pi \vdash e : \theta \rightarrow \theta} (\bigsqcup\limits^{\infty}_{i=0} \eta_i)$ y la definici\'on del operador 
de punto fijo\\

$\Y_{\semBrcks{\theta}}
	(\semBrcks{\pi \vdash e : \theta \rightarrow \theta} (\bigsqcup\limits^{\infty}_{i=0} \eta_i))$ $=$
$\Y_{\semBrcks{\theta}}
	(\bigsqcup\limits^{\infty}_{i=0} f_i)$ $=$
$(\bigsqcup\limits^{\infty}_{i=0} f_i)$ $(\Y_{\semBrcks{\theta}}(\bigsqcup\limits^{\infty}_{i=0} f_i))$\\

luego usando las proposiciones 2 (g) y 2 (d)\\

$(\bigsqcup\limits^{\infty}_{i=0} f_i)$ $(\Y_{\semBrcks{\theta}}(\bigsqcup\limits^{\infty}_{i=0} f_i))$ $=$
$(\bigsqcup\limits^{\infty}_{i=0} f_i)$ $(\bigsqcup\limits^{\infty}_{j=0} (\Y_{\semBrcks{\theta}}f_j)$ $=$\\

$\bigsqcup\limits^{\infty}_{i=0}$ $\bigsqcup\limits^{\infty}_{j=0}$ $f_i (\Y_{\semBrcks{\theta}}f_j)$ $=$
$\bigsqcup\limits^{\infty}_{k=0}$ $f_k (\Y_{\semBrcks{\theta}}f_k)$ $=$
$\bigsqcup\limits^{\infty}_{k=0}$ $\Y_{\semBrcks{\theta}}f_k$ $=$\\

$\bigsqcup\limits^{\infty}_{k=0}$ $\Y_{\semBrcks{\theta}}(\semBrcks{\pi \vdash e : \theta \rightarrow \theta}\eta_k)$ $=$ 
$\bigsqcup\limits^{\infty}_{k=0}$ $\semBrcks{\pi \vdash \rec{e} : \theta} \eta_k$.\\

Por lo tanto, nuestra ecuaci\'on sem\'antica $\semBrcks{\pi \vdash \rec{e} : \theta}$ es
una funci\'on continua.

\item Supongamos tenemos el juicio de tipado $\pi \vdash \cifthenelse{b}{e}{e'} : \theta$, 
probemos que la funci\'on $\IF$ es continua. Supongamos una cadena 
$\lrangles{t_0,f_0,b_0} \sqsubseteq \lrangles{t_1,f_1,b_1} \sqsubseteq \ldots$, luego
vamos a querer probar que $\IF (\bigsqcup\limits^{\infty}_{i=0}\lrangles{t_i,f_i,b_i})$ $=$
$\bigsqcup\limits^{\infty}_{i=0} (\IF \lrangles{t_i,f_i,b_i})$.


$\IF (\bigsqcup\limits^{\infty}_{i=0}\lrangles{t_i,f_i,b_i}) =
\IF (\lrangles{\bigsqcup\limits^{\infty}_{i=0}t_i
    ,\bigsqcup\limits^{\infty}_{i=0}f_i
    ,\bigsqcup\limits^{\infty}_{i=0}b_i}) =$
\[
=
\begin{cases}
\bigsqcup\limits^{\infty}_{i=0} \bot & \text{si } \bigsqcup\limits^{\infty}_{i=0}b_i = \bot \\
\bigsqcup\limits^{\infty}_{i=0}t_i & \text{si } \bigsqcup\limits^{\infty}_{i=0}b_i\\
\bigsqcup\limits^{\infty}_{i=0}f_i & \text{si } \neg \bigsqcup\limits^{\infty}_{i=0}b_i\\
\end{cases}
\]

hagamos ahora un an\'alisis por casos.

\begin{itemize}
\item $\bigsqcup\limits^{\infty}_{i=0}b_i = \bot$, luego lo que pasa es que tenemos
la cadena \\

$\lrangles{t_0,f_0,\bot} \sqsubseteq \lrangles{t_1,f_1,\bot} \sqsubseteq \ldots$ \\

a la que si le aplicamos la funci\'on $\IF$, tal que tenemos la cadena \\

$IF \lrangles{t_0,f_0,\bot} \sqsubseteq IF \lrangles{t_1,f_1,\bot} \sqsubseteq \ldots$, \\

obtenemos la cadena\\

$\bot \sqsubseteq \bot \sqsubseteq \ldots$ cuyo supremo es $\bigsqcup\limits^{\infty}_{i=0} \bot$.\\

\item $\bigsqcup\limits^{\infty}_{i=0}b_i = true$, entonces sucede similar que el caso anterior
con la salvedad de que tenemos dos tipos de cadena posibles,\\

$\lrangles{t_0,f_0,\bot} \sqsubseteq \lrangles{t_1,f_1,\bot} 
		\sqsubseteq \ldots \sqsubseteq \lrangles{t_{j-1},f_{j-1},\bot} \sqsubseteq $\\
$\lrangles{t_j,f_j,true} \sqsubseteq \lrangles{t_{j+1},f_{j+1},true} \sqsubseteq \ldots $\\

o \\

$\lrangles{t_0,f_0,true} \sqsubseteq \lrangles{t_1,f_1,true} \sqsubseteq \ldots$ \\

y lo que sucede es que para cualquiera de las dos cadenas al aplicarle $\IF$ el supremo ser\'a 
$\bigsqcup\limits^{\infty}_{i=0} t_i$.

\item $\bigsqcup\limits^{\infty}_{i=0}b_i = false$, an\'alogo al caso anterior.

\end{itemize}

Por lo tanto $\IF (\bigsqcup\limits^{\infty}_{i=0}\lrangles{t_i,f_i,b_i})$ $=$
$\bigsqcup\limits^{\infty}_{i=0} (\IF \lrangles{t_i,f_i,b_i})$.\\

Por lo tanto, nuestra ecuaci\'on sem\'antica $\semBrcks{\pi \vdash \cifthenelse{b}{e}{e'} : \theta}$ es una funci\'on continua.

\item Los casos para los operadores binarios y un\'arios son similares a la prueba
de expresi\'on condicional.

\item Supongamos tenemos $\pi \vdash \clambda{\iota}{\theta}{e} : \theta \rightarrow \theta'$, 
por la definici\'on de la ecuaci\'on sem\'antica tenemos \\

$\semBrcks{\pi \vdash \clambda{\iota}{\theta}{e} : \theta \rightarrow \theta'}$ $=$
$\semBrcks{\pi,\iota:\theta \vdash e : \theta'} \circ ext_{\iota,\theta}$, \\

probando entonces
que $\semBrcks{\pi,\iota:\theta \vdash e : \theta'}$ y $ext_{\iota,\theta}$ son funciones 
continuas podemos usar la parte 1 del lema anterior que nos dice que la composici\'on
de funciones continuas es una funci\'on continua. Por hip\'otesis
inductiva tenemos que $\semBrcks{\pi,\iota:\theta \vdash e : \theta'}$ es funci\'on
continua, luego resta probar que $ext_\iota$ es continua de $\semBrcks{\pi}$ en 
$\semBrcks{\theta} \rightarrow \semBrcks{\pi,\iota:\theta}$.\\

Supongamos entonces una cadena $\eta_0 \sqsubseteq \eta_1 \sqsubseteq \ldots$ en 
$\semBrcks{\pi}$
y probemos que $ext_{\iota,\theta} (\bigsqcup\limits^{\infty}_{i=0} \eta_i)$ $=$
$\bigsqcup\limits^{\infty}_{i=0} (ext_{\iota,\theta} \eta_i)$. Tomemos un $x$ en $\semBrcks{\theta}$
y un $\iota'$ cualquiera,\\

$ext_{\iota,\theta} (\bigsqcup\limits^{\infty}_{i=0} \eta_i) \ x \ \iota'$ $=$
$[ \ (\bigsqcup\limits^{\infty}_{i=0} \eta_i) \ | \ \iota:x \ ] \iota'$

\begin{itemize}
\item Supongamos $\iota' = \iota$, luego \\

$[ \ (\bigsqcup\limits^{\infty}_{i=0} \eta_i) \ | \ \iota:x \ ] \iota'$ $=$
$x$ $=$ $\bigsqcup\limits^{\infty}_{i=0} x$ $\bigsqcup\limits^{\infty}_{i=0} 
([ \ \eta_i \ | \ \iota:x \ ] \iota')$ $=$ $\bigsqcup\limits^{\infty}_{i=0} 
(ext_{\iota,\theta} \eta_i \ x \ \iota')$\\

\item Supongamos $\iota' \neq \iota$, luego \\

$[ \ (\bigsqcup\limits^{\infty}_{i=0} \eta_i) \ | \ \iota:x \ ] \iota'$ $=$
$(\bigsqcup\limits^{\infty}_{i=0} \eta_i) \iota'$ $=$
$\bigsqcup\limits^{\infty}_{i=0} (\eta_i \iota')$ $=$
$\bigsqcup\limits^{\infty}_{i=0} ([ \ \eta_i \ | \ \iota:x \ ] \iota')$ $=$
$\bigsqcup\limits^{\infty}_{i=0} (ext_{\iota,\theta} \eta_i \ x \ \iota')$\\
\end{itemize}

por lo tanto, $ext_{\iota,\theta}$ es una funci\'on continua y podemos concluir que
la ecuaci\'on sem\'antica para la abstracci\'on lambda tambi\'en lo es.
\end{itemize}
\end{itemize}
\end{proof}

\section{Correcci\'on de la regla-$\beta$ para $\lambdaarrow$}

Lo que vamos a hacer a continuaci\'on es probar que nuestra sem\'antica 
denotacional es correcta con respecto a la regla de reducci\'on $\beta$, para esto
vamos a necesitar el teorema de substituci\'on. Para enunciar y probar este teorema
vamos a tener que introducir un nuevo tipo de juicio de tipado as\'i como tambi\'en
algunos conceptos de substituci\'on. La intenci\'on es evitar tanto tecnicismo
como podamos, presentemos r\'apidamente las herramientas que vamos a necesitar.\\

Empecemos introduciendo el operador $\Delta$, de substituci\'on, que 
ser\'a un mapa entre $\lrangles{Id}$ y $\lrangles{Phrase}$ que representar\'a una
substituci\'on de identificadores por frases, y la funci\'on
$FV$ de $\lrangles{Phrase}$ en $\Po(\lrangles{Id})$ que determinara los
identificadores libres de una frase.\\

Adem\'as, vamos a necesitar de una nueva forma de juicio de tipado cuyo significado
ser\'a que dado un identificador $\iota$ y una substituci\'on $\Delta$, 
la substituci\'on de $\iota$ por $\Delta\iota$ en una frase conserva el 
tipado. Dados $\pi$, $\pi'$ contextos y $\Delta$, vamos a representar el 
nuevo juicio como $\pi \vdash \Delta : \pi'$, cuya \'unica regla es:

\begin{center}
\AxiomC{$\pi \vdash \Delta\iota : \pi'\iota$ \ \ \ para todo $\iota$ en $dom(\pi)$}
\UnaryInfC{$\pi \vdash \Delta : \pi'$}
\DisplayProof
\end{center}

\begin{theorem}[De substituci\'on]
Sean $\pi$ y $\pi'$ contextos, $\Delta$ una substituci\'on y supongamos
tenemos dos juicios de tipado $\pi' \vdash e : \theta$, $\pi \vdash \Delta : \pi'$. 
Asumamos adem\'as que
$\eta'\iota$ $=$ $\semBrcks{\pi \vdash \Delta\iota : \pi'\iota}\eta$
para todo $\iota \in \ dom \ \pi'$, entonces
$\semBrcks{\pi' \vdash e : \theta}\eta'$ $=$ $\semBrcks{\pi \vdash e / \Delta : \theta}\eta$.

\end{theorem}


\begin{proof}
Procedamos por inducci\'on en la estructura de la derivaci\'on de los juicios de tipado.

\begin{itemize}
\item Casos base
\begin{itemize}
\item Supongamos $\pi \vdash b : \boolt$, luego tenemos 
$\semBrcks{\pi \vdash b : \boolt}\eta'$ $=$ $\iotabot b$ $=$ 
$\semBrcks{\pi' \vdash b : \boolt}\eta$ $=$ $\semBrcks{\pi' \vdash b / \Delta : \boolt}\eta$.
An\'alogo para constantes de otros tipos.

\item Supongamos $\pi' \vdash \iota : \theta$, luego 
$\semBrcks{\pi' \vdash \iota : \theta}\eta'$ $=$ $\eta'\iota$
ahora por hip\'otesis tenemos que 
$\eta'\iota$ $=$ $\semBrcks{\pi \vdash \Delta\iota : \pi'\iota}\eta$ $=$
$\semBrcks{\pi \vdash \iota / \Delta : \theta}\eta$.
\end{itemize}

\item Casos inductivos,
\begin{itemize}
\item Supongamos $\pi' \vdash e \ominus e' : \boolt$, donde los casos para
los dem\'as operadores binarios y un\'arios, expresi\'on condicional, aplicaci\'on
y operador de punto fijo son an\'alogos, luego tenemos \\

$\semBrcks{\pi' \vdash e \ominus e' : \boolt}\eta'$ $=$ 
$\ominus_{\circledcirc} \ (\semBrcks{\pi' \vdash e : \boolt}\eta') \ 
						  (\semBrcks{\pi' \vdash e' : \boolt}\eta')$\\
						
por hip\'otesis inductiva en $\pi' \vdash e : \boolt$ y $\pi' \vdash e' : \boolt$\\

$\ominus_{\circledcirc} \ (\semBrcks{\pi' \vdash e : \boolt}\eta') \ 
						   (\semBrcks{\pi' \vdash e' : \boolt}\eta')$ $=$\\
$\ominus_{\circledcirc} \ (\semBrcks{\pi \vdash e / \Delta : \boolt}\eta) \ 
						   (\semBrcks{\pi \vdash e' / \Delta: \boolt}\eta)$ $=$\\
$\semBrcks{\pi \vdash (e / \Delta) \ominus (e' / \Delta) : \boolt}\eta$ $=$\\
$\semBrcks{\pi \vdash (e \ominus e') / \Delta : \boolt}\eta$.\\

\item Supongamos $\pi' \vdash \clambda{\iota}{\theta}{e} : \theta \rightarrow \theta'$, luego\\

$\semBrcks{\pi' \vdash \clambda{\iota}{\theta}{e} : \theta \rightarrow \theta'}\eta'$ $=$
$\lambda x . \semBrcks{\pi',\iota:\theta \vdash e : \theta'}[ \eta' \ | \ \iota:x ]$ \\

para poder aplicar la hip\'otesis inductiva supongamos vale\\

para todo $\kappa \in \ dom(\widehat{\pi})$, donde $\widehat{\pi} = \pi',\iota:\theta$ vale
que $[ \eta' \ | \ \iota:x ]\kappa$ $=$ 
$\semBrcks{\pi,\iota':\theta \vdash \Delta'\iota': \widehat{\pi}\kappa}[ \eta \ | \ \iota':x ]$\\

donde $\Delta' = \Delta \ | \ \iota \rightsquigarrow \iota' $ y 
$\iota' \not\in \bigcup\limits_{\kappa \in FV(e)-\{\iota\}} (FV(\Delta\kappa))$.\\

luego\\

$\lambda x . \semBrcks{\pi,\iota':\theta \vdash e / \Delta' : \theta'}[ \eta \ | \ \iota':x ]$ $=$
$\semBrcks{\pi \vdash \clambda{\iota'}{\theta}{e / \Delta'} : \theta \rightarrow \theta'}\eta$ $=$
$\semBrcks{\pi \vdash (\clambda{\iota}{\theta}{e}) / \Delta' : \theta \rightarrow \theta'}\eta$\\

Para finalizar probemos la suposici\'on que nos permit\'ia aplicar hip\'otesis inductiva.
Tomamos un $\kappa$ cualquiera, y vamos a separar en dos casos, si $\kappa \not= \iota$ entonces
es directo aplicando la hip\'otesis. Veamos que sucede si suponemos $\kappa = \iota$,\\

$[ \eta' \ | \ \iota:x ]\kappa$ $=$ $x$\\

y\\

$\semBrcks{\pi,\iota':\theta \vdash \delta'\kappa : \widehat{\pi}\kappa}[ \eta \ | \ \iota':x ]$ $=$
$\semBrcks{\pi,\iota':\theta \vdash \iota' : \theta}[ \eta \ | \ \iota':x ]$ $=$
$[ \eta \ | \ \iota':x ]\iota'$ $=$ $x$.

\end{itemize}
\end{itemize}
\end{proof}

Ahora que tenemos enunciado y demostrado el teorema de substituci\'on podemos
continuar y demostrar que nuestra sem\'antica den\'otacional es correcta 
con respecto a la regla $\beta$.

\begin{theorem}[Correcci\'on regla $\beta$]
Dado un juicio de tipado $\pi \vdash (\clambda{\iota}{\theta}{e})e' : \theta'$ vale,

\begin{center}
$\semBrcks{\pi \vdash (\clambda{\iota}{\theta}{e})e' : \theta'}$ $=$
$\semBrcks{\pi \vdash e / \iota \leadsto e' : \theta'}$
\end{center}

\end{theorem}
\begin{proof}

La idea de la prueba ser\'a aplicar las distintas ecuaciones sem\'anticas de la aplicaci\'on
y abstracci\'on lambda hasta llegar el punto de poder aplicar nuestro teorema de susbtituci\'on.
Supongamos un $\eta$ cualquiera,\\

$\semBrcks{\pi \vdash (\clambda{\iota}{\theta}{e})e' : \theta'}\eta$ $=$
$(\semBrcks{\pi \vdash \clambda{\iota}{\theta}{e} : \theta \rightarrow \theta'}\eta)$
$(\semBrcks{\pi \vdash e' : \theta}\eta)$ $=$\\

$(\lambda x . \semBrcks{\pi,\iota:\theta \vdash e : \theta'}[ \ \eta \ | \ \iota:x \ ])$
$(\semBrcks{\pi \vdash e' : \theta}\eta)$ $=$\\

$\semBrcks{\pi,\iota:\theta \vdash e : \theta'}[ \ \eta \ | \ 
	\iota:(\semBrcks{\pi \vdash e' : \theta}\eta) \ ]$,\\
												
hasta este punto lo que hemos hecho es usar las definiciones de la aplicaci\'on
y abstracci\'on, y resolver la aplicaci\'on del operador lambda de nuestro
modelo sem\'antico. A continuaci\'on vamos a redefinir con nombre a algunas 
expresiones y ver como podemos aplicar el teorema de substituci\'on, vamos
a renombrar $[ \ \eta \ | \ \iota:(\semBrcks{\pi \vdash e' : \theta}\eta) \ ] = \eta'$
y $\pi,\iota:\theta = \pi'$, luego obtenemos\\

$\semBrcks{\pi,\iota:\theta \vdash e : \theta'}[ \ \eta \ | \ 
	\iota:(\semBrcks{\pi \vdash e' : \theta}\eta) \ ]$ $=$ $\semBrcks{\pi' \vdash e : \theta'}\eta'$\\

ahora, para poder aplicar substituci\'on tenemos que probar que
para todo $\iota' \in \ dom (\pi')$, $\eta' \iota' = \semBrcks{\pi \vdash \Delta\iota' : \pi' \iota'}\eta$
donde $\Delta$ sera la substituci\'on $\iota \leadsto e'$ y la identidad para todo otro $\iota'$. Supongamos un $\iota'$ cualquiera,

\begin{itemize}
\item Caso $\iota' \neq \iota$, $\eta' \iota' = \eta \iota' = 
									\semBrcks{\pi \vdash \iota' : \pi'\iota'}\eta = 
									\semBrcks{\pi \vdash \Delta \iota' : \pi'\iota'}\eta$.

\item Case $\iota' = \iota$, $\eta' \iota' = \eta' \iota = 
									 \semBrcks{\pi \vdash e : \theta}\eta = 
									 \semBrcks{\pi \vdash \Delta \iota : \pi'\iota}\eta$.
\end{itemize}

luego aplicando substituci\'on obtenemos,
$\semBrcks{\pi' \vdash e : \theta'}\eta'$ $=$ $\semBrcks{\pi \vdash e / \Delta : \theta'}\eta$\\

por lo tanto, $\semBrcks{\pi \vdash (\clambda{\iota}{\theta}{e})e' : \theta'}\eta$ $=$
 			  $\semBrcks{\pi \vdash e / \iota \leadsto e' : \theta'}\eta$.

\end{proof}

\section{Implementaci\'on en Idris}

La implementaci\'on del lenguaje se encuentra en:\\
\url{https://github.com/alexgadea/thesis/tree/master/Prototypes/Idris/LambdaArrow}\\

\noindent
Sintaxis de los tipos
\begin{code}
data PType = IntExp | RealExp | BoolExp 
          | PType :-> PType
\end{code}

\noindent
Sem\'antica de los tipos
\begin{code}
evalTy : PType -> Type
evalTy IntExp    = Int
evalTy RealExp   = Float
evalTy BoolExp   = Bool
evalTy (Theta :-> Theta') = evalTy Theta -> evalTy Theta'
\end{code}

\noindent

Los contextos los vamos a separar en dos "versiones" la sint\'actica
y la sem√°ntica, la idea es implementar los contextos sint\'acticos de
forma que no haya repetici√≥n de nombres de identificador. Es decir,
un contexto va a ser una lista de identificadores y types;

\begin{center}
$i_0 : pt_0, \ldots , i_n:pt_n$
\end{center}

para contextos sem√°nticos simplemente es una lista de la siguiente manera,

\begin{center}
$evalTy \ pt_0, \ldots , evalTy \ pt_n$
\end{center}

y tenemos una correspondencia lugar a lugar con el contexto sint√°ctico para
buscar el valor.\\

\noindent Versi\'on sint\'actica
\begin{code}
mutual
    data Ctx : Type where
        CtxUnit : Ctx
        Prepend : (p:Ctx) -> (i:Identifier) -> (pt:PType) -> 
                  Fresh p i -> Ctx
    -- Representa si un identificador es fresco para un contexto.
    data Fresh : Ctx -> Identifier -> Type where
        FUnit : (i:Identifier) -> Fresh CtxUnit i
        FCons : (i:Identifier) -> (pt':PType) -> (i':Identifier) -> 
                (p:Ctx) -> (fi':Fresh p i') -> so (i/=i') -> (Fresh p i) -> 
                Fresh (Prepend p i' pt' fi') i

-- Representa la pertenencia de un identificador en un contexto.
data InCtx : Ctx -> Identifier -> Type where
    InHead : (p:Ctx) -> (i:Identifier) -> (pt:PType) -> 
             (fi:Fresh p i) -> InCtx (Prepend p i pt fi) i
    InTail : (p:Ctx) -> (i:Identifier) -> (pt:PhraseType) -> 
             (j:Identifier) -> (fj:Fresh p j) -> 
             InCtx p i -> InCtx (Prepend p j pt fj) i
\end{code}

\newpage

\noindent Versi\'on sem\'antica
\begin{code}
evalCtx : Ctx -> Type
evalCtx CtxUnit = ()
evalCtx (Prepend p _ pt _) = (evalCtx p, evalTy pt)

-- Buscar el valor de un identificador en un contexto sem√°ntico.
search : (p:Ctx) -> (i:Identifier) -> (pt:PType) ->
         InCtx p i -> evalCtx p -> evalTy pt
search (Prepend _ i pt _) i pt (InHead _ i pt fi) (eta,v) = v
search (Prepend ctx j pt _) i pt (InTail _ _ pt j _ inc) (eta,_) = search ctx i pt inc eta

-- Actualizar el valor de un identificador.
update : (p:Ctx) -> evalCtx p -> (i:Identifier) -> 
         (pt:PType) -> evalTy pt -> (fi:Fresh p i) -> evalCtx (Prepend p i pt fi)
update p eta i pt z fi = (eta,z)
\end{code}

\noindent
Sintaxis de $\lambdaarrow$
\begin{code}
using (Pi:Ctx, Theta:PType, Theta':PType)    
    data TypeJugdmnt : Ctx -> PType -> Type where
        I     : (i:Identifier) -> InCtx Pi i -> TypeJugdmnt Pi Theta
        
        CInt  : Int   -> TypeJugdmnt Pi IntExp
        CBool : Bool  -> TypeJugdmnt Pi BoolExp
        CReal : Float -> TypeJugdmnt Pi RealExp
        
        Lam   : (i:Identifier) -> (pt:PhraseType) -> (fi:Fresh Pi i) ->
                TypeJugdmnt (Prepend Pi i pt fi) Theta' -> 
                TypeJugdmnt Pi (pt :-> Theta')
        App   : TypeJugdmnt Pi (Theta :-> Theta') -> 
                TypeJugdmnt Pi Theta -> TypeJugdmnt Pi Theta'
        Rec   : TypeJugdmnt Pi (Theta :-> Theta) -> TypeJugdmnt Pi Theta
        
        If    : TypeJugdmnt Pi BoolExp -> 
                TypeJugdmnt Pi Theta -> TypeJugdmnt Pi Theta -> 
                TypeJugdmnt Pi Theta
        
        BinOp : (evalTy a -> evalTy b -> evalTy c) -> 
                TypeJugdmnt Pi a -> TypeJugdmnt Pi b -> TypeJugdmnt Pi c
        UnOp  : (evalTy a -> evalTy b) -> 
                TypeJugdmnt Pi a -> TypeJugdmnt Pi b
\end{code}

\noindent
Sem\'antica de $\lambdaarrow$
\begin{code}
eval : {Pi:Ctx} -> {Theta:PType} -> TypeJugdmnt Pi Theta -> evalCtx Pi -> evalTy Theta
eval {Pi=p} {Theta=pt} (I i iIn) eta = search p i pt iIn eta
eval (CInt x) eta = x
eval (CBool x) eta = x
eval (CReal x) eta = x
eval {Pi=p} (Lam i pt fi b) eta = \z => eval b (update p eta i pt z fi)
eval (App e e')   eta = (eval e eta) (eval e' eta)
eval (Rec e) eta = fix (eval e eta)
eval (If b e e')  eta = if eval b eta then eval e eta else eval e' eta
eval (BinOp op x y) eta = op (eval x eta) (eval y eta)
eval (UnOp op x) eta = op (eval x eta)
\end{code}
