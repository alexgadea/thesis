\chapter{Lenguaje Algol-like}
\label{chap:algollike}

En el final del cap\'itulo anterior terminamos con el estudio
del lenguaje lambda leq, este era un lenguaje funcional con subtipado.
En este cap\'itulo vamos a tomar a lambda leq y vamos a agregar
aspectos imperativos, este nuevo lenguaje lo llamaremos \Alike.

Este nuevo lenguaje que vamos a estudiar pertenecer\'a a la clase
de lenguaje Algol-like estos combinan
aspectos funcionales con imperativos y se basan en evaluaci\'on
normal. Una propiedad importante de este tipo de lenguajes es
la forma en la que se eval\'ua la aplicaci\'on de procedimientos
en un programa, lo que sucede es que la evaluaci\'on del programa
ocurre en dos partes, en la primera se reduce el programa hasta que
la aplicaci\'on del procedimiento desaparece quedando de esta manera 
la parte imperativa por evaluar y que es exactamente la segunda parte.

A continuaci\'on presentamos los cinco principio que (ref de the essence of algol)
cree que captura la esencia de los lenguajes Algol-like.

\begin{enumerate}
\item Algol-like se obtiene de un lenguaje imperativo simple imponiendo un
sistema para los procedimientos basado en el calculo lambda "fully typed" y utilizando
call-by-name. Donde con "fully typed" se refiere que todos los errores de tipo deben ser
errores sint\'acticos.

\item Existe dos clases de tipos: Los $\textit{Data Types}$ que representaran los 
conjuntos de valores para expresiones y variables y los $\textit{Phrase Types}$ que
representaran los conjuntos de valores para las frases e identificadores.

\item El orden de evaluaci\'on para las partes de una expresi\'on y su
conversi\'on impl\'icita deber\'ia estar indeterminada, pero el significado
del lenguaje es independiente de la indeterminaci\'on.

\item La definici\'on de procedimientos, recursiones, expresiones condicionales
pueden ser de cualquier $\textit{Phrase Types}$.

\item El lenguaje contiene stack discipline y su definici\'on debe hacer esta disciplina
obvia.

\end{enumerate}

Sobre este ultimo punto vamos a presentar una variante de sem\'antica para el lenguaje
en la cual no tenemos stack discipline. Lo interesante es que lo vamos a lograr cambiando
realmente muy poco sobre las ecuaciones sem\'anticas y los dominios originales que
si contemplan stack discipline.

\section{Sintaxis}

Como ya mencionamos \Alike sera una extensi\'on de lambda leq, agregando las
construcciones para un lenguaje imperativo simple. Pero antes de hacer esta extensi\'on
hay algo a acomodar en cuantos a los lenguajes de donde se extiende \Alike y
esta en el hecho de que el lenguaje de tipos de lambda leq es demasiado simple debemos
extenderlo seg\'un el punto dos de los principios de algol.

Comencemos entonces acomodando nuestro sistema de tipos, empecemos tomando los tipos
$\boolt$, $\intt$ y $\realt$ de $\lrangles{Type}$ y separándolos por un lado, para
introducir la gram\'atica de los  $\textit{Data Types}$.

\setlength{\grammarindent}{6em}
\begin{grammar}

<Data Types> ::= $\boolt$ | $\intt$ | $\realt$

\end{grammar}

Por otro lado en $\lrangles{Type}$ tenemos el operador funcional $\rightarrow$, este vamos 
a moverlo a nuestra otra clase de tipos $\textit{Phrase Types}$ y vamos a agregar las
construcciones de tipos que representan los valores para los comandos, aceptadores, variables y 
expresiones, este ultimo tipo se lo puede considerar como el nuevo tipo que 
representa a los tipos como los ten\'iamos antes, es decir, si una frase antes
ten\'ia tipo $\intt$ ahora tendr\'a tipo $\intt\textbf{exp}$(resi\'on). Dicho lo
anterior no hay duda sobre la utilidad de $\deltaexp$ como tipo, hagamos un repaso
de los dem\'as tipos que vamos a introducir, el tipo de los comandos no ser\'a
otra cosa que el representante de las frases de la parte imperativa de
nuestro lenguaje, el tipo de las variables encapsular\'a las dos posibles utilizaciones
de un identificador de variable, es decir, ya sea como valor o como almacenamiento,
para este primero es que tenemos el tipo de las expresiones y para el segundo es
donde aparece el tipo de los aceptadores, este b\'asicamente se encarga de 
representar a un identificador de variables como un almac\'en de valores.

\setlength{\grammarindent}{8em}
\begin{grammar}

<Phrase Types> ::= $\commt$
\alt $\boolacc$ \ | $\intacc$ \ | $\realacc$
\alt $\boolexp$ | $\intexp$ | $\realexp$
\alt $\boolvar$ \ | $\intvar$ \ | $\realvar$
\alt <Phrase Types> $\rightarrow$ <Phrase Types>

\end{grammar}

Ahora que hemos actualizado el lenguaje de tipos necesario para \Alike, presentemos
la gram\'atica, como mencionamos anteriormente este lenguaje va a ser una extensi\'on de lambda leq, agregando los construcciones para un lenguaje imperativo simple. Estas construcciones 
ser\'an los comandos para la declaraci\'on de variables ($\cnew \deltavar$), 
asignaci\'on($\cassig$), comando neutro ($\cskip$), concatenaci\'on de comandos ($\concatdots$)
y un comando para iteraciones ($\cwhile$).

\setlength{\grammarindent}{6em}
\begin{grammar}

<Phrase> ::= <PBool> | <PInt> | <PReal>
\alt $\odot$ <Phrase> | <Phrase> $\circledcirc$ <Phrase>
\alt \textbf{if} <Phrase> \textbf{then} <Phrase> \textbf{else} <Phrase>
\alt <Id> 
\alt <Phrase> <Phrase>
\alt $\lambda$ <Id>$_\theta$ . <Phrase>
\alt \textbf{rec} <Phrase>
\alt $\cnewv$ $\deltavar$ <Id> $\cassig$ <Phrase> $\cin$ <Phrase>
\alt <Phrase> $\cassig$ <Phrase> | $\cskip$ | <Phrase> $\concatdots$ <Phrase>
\alt $\cwhile$ <Phrase> $\cdo$ <Phrase>


<PBool> ::= True | False

<PNat>  ::= 0 | 1 | 2 | ...

<PInt>  ::= ... | -2 | -1 | <PNat> 

<PReal> ::= <PNat>.\{<PNat>\}+ 
\alt - <PNat>.\{<PNat>\}+

\end{grammar}

\noindent
donde \ 

$\lrangles{\textit{Id}}$ es un conjunto numerable.

$\theta \in \phraseTypes$ \

$\odot \in \{-, \neg\}$ y \

$\circledcirc \in \{+,-,*,/,\div,\rem,\wedge,\vee,\Rightarrow,\Leftrightarrow, =,\neq,<,>,\leq,\geq\}$

\subsection{Reglas de inferencia}

La modificaci\'on de los tipos nos obliga a actualizar las reglas de inferencia 
concretas del subtipado, ya que ahora como mencion\'abamos antes el tipo de una
expresi\'on entera no sera $\intt$ si no $\intexp$. Pero antes de acomodar esto
definamos una nueva relaci\'on de orden para los tipos de $\dataTypes$, en esta
nueva relaci\'on vamos a retirar $\boolt \leq \intt$, cuyo fin en lambda leq
era tener casos interesantes de transitividad entre los tipos, luego nos quedara 
la siguiente relaci\'on entre los tipos,

\begin{diagram}[loose,height=2em]
   \realt & \\
   \dLine & \\
   \intt  & \boolt
\end{diagram}

Ahora utilizando este diagrama, que b\'asicamente nos dice que $\intt$ es subtipo
de $\realt$ y que no ocurre nada mas interesante, presentamos la relaci\'on de los
tipos de $\phraseTypes$,

\begin{diagram}[loose,height=2em,width=3em]
   \realexp & & \intacc  & \\
   \dLine & \rdLine(2,4) \ldLine(2,4) & \dLine   & \\
   \intexp  & & \realacc & &    \boolexp    &      &    \boolacc  & \\
   \dLine   & & \dLine   & &        &    \rdLine(1,2)  \ldLine(1,2)     &     & \\
   \intvar  & & \realvar & &        &       \boolvar   &            & \commt
\end{diagram}

Expliquemos un poco que estamos viendo, por un lado respetando la idea de que
$\intt$ es ahora $\intexp$ y $\realt$ es $\realexp$, entonces vamos a tener
$\intexp \leq \realexp$, esta relaci\'on se da vuelta si pensamos en el tipo
de los aceptadores y entonces tenemos $\realacc \leq \intacc$. Finalmente 
si pensamos que una variable puede ser usada tanto como valor o contenedor,
vamos a tener que, tomando $\delta \in \dataTypes$, $\deltavar \leq \deltaexp$ y
$\deltavar \leq \deltaacc$.\\

Dicho esto escribamos las nuevas reglas de tipado para estas relaciones nuevas
y aprovechemos para actualizar nuestras metavaribles en relaci\'on a nuestros
nuevos tipos.

\begin{center}
\begin{tabular}{ l r }
	$\theta$ $\phraseTypes$ & $\delta$ $\dataTypes$
\end{tabular}
\end{center}

\noindent
$\texttt{Ty Rule:}$ intexpTorealexp.

\begin{center}
\AxiomC{}
\UnaryInfC{$\intexp \leq \realexp$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ realaccTointacc.

\begin{center}
\AxiomC{}
\UnaryInfC{$\realacc \leq \intacc$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ $\delta$varTo$\delta$exp.

\begin{center}
\AxiomC{}
\UnaryInfC{$\deltavar \leq \deltaexp$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ $\delta$varTo$\delta$acc.

\begin{center}
\AxiomC{}
\UnaryInfC{$\deltavar \leq \deltaacc$}
\DisplayProof
\end{center}

Adem\'as de estas reglas de inferencia para el subtipado, nos van a hacer
falta actualizar las reglas de inferencia de lambda leq con los tipos correspondientes
del lenguaje \Alike y luego faltara tambi\'en agregar reglas para los juicios de 
tipado de las nuevas frases. Pero antes vamos a necesitar definir el nuevo lenguaje
de los contextos, como ha venido ocurriendo, esto ser\'a actualizar los tipos
viejos por los nuevos.

\begin{definition}\label{alike:context}

Un contexto estar\'a definido por la siguiente gram\'atica,\

\begin{grammar}

<Context> ::= $\varnothing$ | <Context>,<Id>:<Phrase Types>

\end{grammar}

\end{definition}

Ahora s\'i, reescribamos las reglas de lambda leq con los nuevos tipos, b\'asicamente
lo que vamos a hacer es cambiar un tipo $\delta$ por $\deltaexp$,

\

\noindent
$\texttt{Ty Rule:}$ Constantes.

\begin{center}
\AxiomC{}
\UnaryInfC{$\pi \vdash b : \boolexp$}
\DisplayProof
\quad
\AxiomC{}
\UnaryInfC{$\pi \vdash i : \intexp$}
\DisplayProof
\quad
\AxiomC{}
\UnaryInfC{$\pi \vdash r : \realexp$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ Operadores b\'asicos.

\begin{center}
\AxiomC{$\pi \vdash e : \intexp$}
\UnaryInfC{$\pi \vdash -e : \intexp$}
\DisplayProof
\quad
\AxiomC{$\pi \vdash e : \realexp$}
\UnaryInfC{$\pi \vdash -e : \realexp$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{$\pi \vdash e : \boolexp$}
\UnaryInfC{$\pi \vdash \neg e : \boolexp$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{$\pi \vdash e : \intexp$}
\AxiomC{$\pi \vdash e' : \intexp$}
\RightLabel{$\otimes \in \{+,-,*,/\ , \textbf{rem}\}$}
\BinaryInfC{$\pi \vdash e \otimes e' : \intexp$}
\DisplayProof

\quad

\quad

\AxiomC{$\pi \vdash e : \realexp$}
\AxiomC{$\pi \vdash e' : \realexp$}
\RightLabel{$\otimes \in \{+,-,*\}$}
\BinaryInfC{$\pi \vdash e \otimes e' : \realexp$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{$\pi \vdash e : \boolexp$}
\AxiomC{$\pi \vdash e' : \boolexp$}
\RightLabel{$\owedge \in \{\wedge,\vee,\Rightarrow,\Leftrightarrow\}$}
\BinaryInfC{$\pi \vdash e \owedge e' : \boolexp$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{$\pi \vdash e : \delta$}
\AxiomC{$\pi \vdash e' : \delta$}
\RightLabel{$\delta \in \{\intexp, \realexp \}, \olessthan \in \{<,>,\leq,\geq\}$}
\BinaryInfC{$\pi \vdash e \olessthan e' : \boolexp$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{$\pi \vdash e : \deltaexp$}
\AxiomC{$\pi \vdash e' : \deltaexp$}
\RightLabel{$\ominus \in \{=,\neq\}$}
\BinaryInfC{$\pi \vdash e \ominus e' : \boolexp$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ Aplicaci\'on.

\begin{center}
\AxiomC{$\pi \vdash e : \theta \rightarrow \theta'$}
\AxiomC{$\pi \vdash e': \theta$}
\BinaryInfC{$\pi \vdash ee' : \theta'$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ Operador de punto fijo.

\begin{center}
\AxiomC{$\pi \vdash e : \theta \rightarrow \theta$}
\UnaryInfC{$\pi \vdash \rec{e} : \theta$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ Identificador.

\begin{center}
\AxiomC{}
\RightLabel{$v:\theta \in \pi$}
\UnaryInfC{$\pi \vdash v : \theta$}
\DisplayProof
\end{center}

\noindent
$\texttt{Ty Rule:}$ Abstracci\'on lambda.

\begin{center}
\AxiomC{$\pi,\iota:\theta \vdash e : \theta'$}
\UnaryInfC{$\pi \vdash \clambda{\iota}{\theta}{e} : \theta \rightarrow \theta'$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ Expresi\'on condicional.

\begin{center}
\AxiomC{$\pi \vdash b  : \boolexp$}
\AxiomC{$\pi \vdash e  : \theta$}
\AxiomC{$\pi \vdash e' : \theta$}
\TrinaryInfC{$\pi \vdash \cifthenelse{b}{e}{e'} : \theta$}
\DisplayProof

\

con $\theta \in \{\deltavar,\deltaacc,\deltaexp,\commt\}$.\\
\end{center}


Hasta aqu\'i lo que hemos hecho es recompilar y actualizar las reglas de inferencia
para la parte aplicativa del lenguaje, ahora definamos las regla de los comandos 
$\cskip$, $\cwhile$ y $\concatdots$ que no presentan ninguna particularidad que valga 
la pena comentar y luego sigamos con las reglas $\cnew \ \deltavar$ y $\cassig$. Pero
antes notamos el hecho de que el juicio de tipado para la expresi\'on
condicional no es todo lo general que plantea el punto 4 del comienzo del capitulo,
la respuesta para esta decisi\'on se encuentra al momento de definir la ecuaci\'on
sem\'antica para este comando.

\

\noindent
$\texttt{Ty Rule:}$ $\cskip$.

\begin{center}
\AxiomC{}
\UnaryInfC{$\pi \vdash \cskip : \commt$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ $\cwhile$.

\begin{center}
\AxiomC{$\pi \vdash e : \boolexp$}
\AxiomC{$\pi \vdash e' : \commt$}
\BinaryInfC{$\pi \vdash \cwhiledo{e}{e'} : \commt$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ Composici\'on.

\begin{center}
\AxiomC{$\pi \vdash e  : \commt$}
\AxiomC{$\pi \vdash e' : \commt$}
\BinaryInfC{$\pi \vdash \cseq{e}{e'} : \commt$}
\DisplayProof
\end{center}

En la regla de inferencia para la declaraci\'on de variable, ocurre 
algo muy similar a lo que ocurre con la regla de la abstracci\'on lambda
en cuanto a que se extiende el contexto, la principal diferencia ser\'a
que solamente vamos a poder agregar el identificador con un phrase type "fijo",
donde con "fijo" nos referimos a que solamente un identificador podr\'a ser
de tipo $\deltavar$.

\

\noindent
$\texttt{Ty Rule:}$ Declaraci\'on de variable.

\begin{center}
\AxiomC{$\pi \vdash e  : \deltaexp$}
\AxiomC{$\pi,\iota:\deltavar \vdash e' : \commt$}
\BinaryInfC{$\pi \vdash \newdeltavar{\iota}{e}{e'} : \commt$}
\DisplayProof
\end{center}

Antes mencin\'abamos que el tipo $\deltavar$ encapsulaba de manera bien
separada la noci\'on de un identificador utilizado como contenedor de un
valor o utilizado como un valor en si mismo. En la regla de la asignaci\'on
se ve como para guardar un valor hace falta que la parte izquierda tenga
tipo $\deltaacc$, es decir el tipo $\deltavar$ visto como contenedor y
la parte derecha tenga tipo $\deltaexp$, que en el caso de ser un identificador
es el tipo $\deltavar$ visto como valor.

\

\noindent
$\texttt{Ty Rule:}$ Asignaci\'on.

\begin{center}
\AxiomC{$\pi \vdash e   : \deltaacc$}
\AxiomC{$\pi \vdash e'  : \deltaexp$}
\BinaryInfC{$\pi \vdash \assig{e}{e'} : \commt$}
\DisplayProof
\end{center}


\section{Sem\'antica}

A nivel sint\'actico vimos que \Alike esta compuesto por las frases
de lambda leq mas frases que representan la parte imperativa, de hecho al 
presentar las reglas de inferencia para las frases de \Alike, las
reglas de la parte de lambda leq sufrieron un \'unico cambio simple
en cuanto a los nombre de los tipos y pudimos aprovechar la definici\'on
completa. Ahora que vamos a dar la sem\'antica 
de \Alike y no vamos a poder hacer algo similar con la sem\'antica, es decir aprovechar las
ecuaciones sem\'anticas que definimos para lambda leq, la raz\'on principal es
que el significado de nuestros tipos ya no ser\'a tan simple debido a que
nos aparecen cuestiones relacionadas con el stack discipline. \\

Adem\'as para definir las dos sem\'anticas que pretendemos para \Alike,
con y sin stack discipline, vamos a tener definiciones extras, una
para el juicio de tipado de la declaraci\'on de variables imperativas
y otra para la categor\'ia de estados de la parte imperativa. 
Lo interesante de notar sobre lo anterior es que dadas todas las ecuaciones
sem\'anticas de nuestro lenguaje, con solo seleccionar una sola
ecuaci\'on vamos a decidir sobre el tipo de implementaci\'on en
relaci\'on al stack discipline.

\subsection{Categor\'ias de \Alike}

Comencemos adaptando la categor\'ia de tipos $\Theta$, lo \'unico 
por hacer ser\'a cambiar la clase de tipos de lambda leq por los de
Algol-like.

\begin{definition}\label{algol:typescategory}
La categor\'ia de tipos, que nombraremos $\Theta$, se define como sigue

$\Theta_0$ $=$ $\{\theta \ | \ \theta \ \in \phraseTypes \}$\\
\indent
$\Theta_1(\theta,\theta')$ $=$ $\{\theta \rTo \theta' \ | \ \theta \leq \theta'\}$\\

\end{definition}

Sobre la categor\'ia de contextos no hay nada que cambiar, luego
lo que nos queda por actualizar es la categor\'ia $\CD$, esta 
en lambda leq la hab\'iamos definido como la categor\'ia concreta
$\Dom$, la cuesti\'on es que ahora esta no nos alcanza solamente con esta y vamos a 
necesitar un enfoque bastante distinto debido a que la separaci\'on 
que existe entre el calculo lambda y la parte imperativa nos induce
una separac\'ion entre los ambientes y los estados. As\'i por ejemplo
sucede que $\semBrcks{\intexp}$ ya no ser\'a un $S_\intt$ que represente
el conjunto de enteros, si no que pasar\'a a ser una funci\'on de
estados en $S_\intt$.\\

Pero antes de continuar, definamos que ser\'a un estado en nuestra sem\'antica,
para el cual tendremos dos versiones, una versi\'on ser\'a un conjunto de valores 
pero con la particularidad de tener forma, donde aclarando un poco a que 
nos referimos con forma, es que si tom\'aramos un estado $(1,True)$ que 
pertenece a $\Z \times \B$, diremos que este estado tiene 
forma $\lrangles{\Z,\B}$. Para la otra versi\'on un estado ser\'a una funci\'on
de de identificadores en valores.

\begin{definition}\label{algol:disciplinestates}

Un estado ser\'a un elemento perteneciente a $S_1 \times \ldots \times S_n$, 
con $1 \leq n$ con $S_i$ conjuntos. Diremos adem\'as que este estado tiene
forma $\lrangles{S_1,\ldots,S_n}$\\

Adem\'as dados dos estados $\sigma$ y $\sigma'$, diremos que $\sigma$ extiende
a $\sigma'$ cuando la forma de $\sigma$ sea tramo inicial de la forma de $\sigma'$.

\end{definition}

Introduzcamos algunas funciones \'utiles que nos van a servir para
operar sobre los estados y las formas de los estados. Vamos a usar
$ \concat $ para definir la concatenaci\'on de estados y formas de estado,
adem\'as para operar sobre los estados vamos a tener tres funciones b\'asicas,
$head$, $tail$ y $last$. 

\begin{definition}\label{algol:statesfunctions}

Sea $\sigma$ un estado con forma $\alpha \concat \alpha'$ luego definimos
$head_\alpha \sigma$ y $tail_\alpha¿ \sigma$ como los \'unicos
estados tal que $head_\alpha \sigma \concat tail_\alpha¿ \sigma$ $=$ $\sigma$.

Adem\'as dado un estado $\sigma$ con forma $\lrangles{S}$, tenemos que $last_S \sigma$ sera el
\'unico valor contenido en el estado $\sigma$.\\

\end{definition}

Hasta aqu\'i entonces hemos definido la primera versi\'on de estados, esta ser\'a la que
se corresponda con la categor\'ia de estados para la sem\'antica con stack discipline.
Pasemos a definir la segunda versi\'on, la cual se corresponder\'a entonces con
la categor\'ia de estados para la sem\'antica sin stack discipline. Como ya
mencionamos antes estos estados ahora ser\'an funciones de identificadores
en valores, en un sentido similar a como es un ambiente, la raz\'on principal
por la cual vamos a tener esta segunda versi\'on se basa en que vamos a querer
dejar de lado la idea de que los estados tengan forma y el problema que 
trae esto es que, justamente la forma es lo que nos permite actualizar o consultar
los valores de nuestro estado, por lo tanto necesitamos otro tipo
de estado con otro mecanismo para realizar esas acciones.
Para resolver esto usamos una idea similar a la propuesta en (referencia Reynolds Theories...)
para el lenguaje Iswim.

\begin{definition}\label{algol:states}

Un estado ser\'a un elemento perteneciente a 
$\bigcup\limits_{I \in \FinId} I \rightarrow S$

donde $\FinId$ ser\'a un conjunto de subconjuntos finitos de $\lrangles{Id}$ y
$S = S_\intt + S_\realt + S_\boolt$\\

A este conjunto de estados lo llamaremos $\Sigma$.\\

\end{definition}

Ahora con los estados definidos, vamos a dar las dos definiciones de
la categor\'ia de estados, una ser\'a la categor\'ia en la que b\'asicamente cada objeto ser\'a
un conjunto de estados con la misma forma y una flecha entre dos objetos
determinar\'a como contraer la forma de un objeto y como transformar un estado
con cierta forma en un estado mas grande. Y la otra categor\'ia tendr\'a
un solo objeto que agrupar\'a a todos los estados sin importar la forma y
cuya \'unica flecha ser\'a la identidad.

\begin{definition}\label{algol:disciplinestatecategory}
La categor\'ia de estados, que nombraremos $\C$, se define como sigue,\\

\indent
$\C_0$ $=$ $\{C$ $|$ $C$ es el conjunto de todos los estados con determinada forma$\}$\\
\indent
$\C_1(C,C')$ $=$ $\{C \rTo^{(h,s)} C'$ $|$ $C'$ extiende a $C\}$\\

donde \ $h: C' \rightarrow C$\\
\indent \indent \indent
	  $h = head_C$\\
\indent \indent \indent
	  $s: (C \rightarrow C_{\bot}) \rightarrow (C' \rightarrow C'_{\bot})$\\
\indent \indent \indent
	  $s \ c \ \sigmahat =$ 
	  	   $(\lambda \sigma. \ \sigma \concat (tail_{\overline{C}} \ \sigmahat))_{\bot}$
	  	   	$(c(h \ \sigmahat))$\\
\indent \indent \indent
	 $C' = C \concat \overline{C}$

\end{definition}

Notar que si tomamos un objeto $C$ de $\C$ podemos hablar de que este objeto
tiene cierta forma, b\'asicamente la forma de los estados que agrupa, luego
podemos hablar de que dado otro objeto $C'$, este extiende a $C$ y esta extensi\'on
se determina de la misma manera que para los estados. Adem\'as aprovechamos 
que podemos hablar acerca de que $C$ tiene forma, para hacer un abuso de 
notaci\'on en $head$ y $tail$.\\

Ahora definamos la segunda categor\'ia de estados que mencionamos anteriormente.

\begin{definition}\label{algol:statecategory}
La categor\'ia de estados, que nombraremos $\C$, se define como sigue,\\

\indent
$\C_0$ $=$ $\{\ \Sigma \ \}$\\

y cuya \'unica flecha es $(1_h,1_s) : \Sigma \rightarrow \Sigma$, tal que\\

$1_h : \Sigma \rightarrow \Sigma$\\
\indent
$1_h \sigma = \sigma$\\
\indent
$1_s: (\Sigma \rightarrow \Sigma_{\bot}) \rightarrow (\Sigma \rightarrow \Sigma_{\bot})$\\
\indent
$1_s \ c = c$

\end{definition}

Una aclaraci\'on importante es que, salvo aclaraci\'on, cuando hablemos de 
la categor\'ia $\C$ vamos a estar refiri\'endonos a cualquiera de las dos
que acabamos de definir. Dicho esto, estamos en condiciones de definir quien
ser\'a $\CD$, una idea inicial es pensar en la categor\'ia funtorial
$\Dom^\C$ como sugiere (ref Reynolds, Theories of programming... Cap. 19.), pero
parece existir un problema seg\'un se menciona en (ref Oles, Functor categories and 
store shapes, Chap. 11.) que tiene que ver con que $\Dom^\C$ parece no ser $\CCC$
a pesar de que $\Dom$ lo sea y hab\'iamos mencionado que \'ibamos a querer que
nuestra categor\'ia $\CD$ sea $\CCC$. En esta ultima referencia entonces se
plantea el uso de $\PDom$, luego $\CD$ nos queda como la categor\'ia funtorial $\PDom^\C$.

\subsection{Ecuaciones sem\'anticas}

Para la definici\'on de las ecuaciones sem\'anticas primero vamos a tener
que acomodar la sem\'antica de nuestros tipos y contextos, antes ya mencionamos
que la representaci\'on que vamos a necesitar, por ejemplo, para el tipo $\intexp$
ya no ser\'a tan simple como antes. 

Notar que como nuestra categor\'ia $\CD$ es ahora una categor\'ia funtorial, 
vamos a tener que la sem\'antica de un objeto $\theta$ de $\Theta$ ser\'a un funtor,\\

$\semBrcks{\theta}$ $:$ $\C \rightarrow \PDom$\\

tal que aplicado a un objeto $C$, de $\C$ es,\\

$\semBrcks{\theta} C$ $:$ $\PDom$\\

y aplicado a una flecha $C \rTo^{(h,s)} C'$ es,\\

$\semBrcks{\theta} (h,s)$ $:$ $\semBrcks{\theta} C \rightarrow \semBrcks{\theta} C'$.\\

en general, el comportamiento de este funtor aplicado a una flecha ser\'a la traducci\'on del estado actual con forma $C$ a un estado extendido con forma $C'$. 

\noindent
Adem\'as, la sem\'antica de una flecha $\theta \rTo^{\leq} \theta'$ de $\Theta$ ser\'a
una transformaci\'on natural, indexada por objetos de $\C$,\\

$\semBrcks{\theta \rTo^{\leq} \theta'}C$ $:$ $\semBrcks{\theta}C \rightarrow \semBrcks{\theta'}C$.

\begin{definition}\label{algol:typesemfunctor}
Sea $\semBrcks{ \_ } : \Theta \rightarrow \CD$ un funtor, tal que\\

$\semBrcks{\deltaexp}_0 C$ $=$ $C \rightarrow (S_\delta)_\bot$\\ 
\indent
$\semBrcks{\deltaexp}_0 (h,s) \ e$ $=$ $e \circ h$\\
\

$\semBrcks{\commt}_0 C$ $=$ $C \rightarrow C_\bot$\\
\indent
$\semBrcks{\commt}_0 (h,s) \ c$ $=$ $s \ c$\\
\

$\semBrcks{\deltaacc}_0 C$ $=$ $S_\delta \rightarrow \semBrcks{\commt}C$\\
\indent
$\semBrcks{\deltaacc}_0 (h,s) \ a$ $=$ $s \circ a$\\
\

$\semBrcks{\deltavar}_0 C$ $=$ $\semBrcks{\deltaacc}C \times \semBrcks{\deltaexp}C$\\
\indent
$\semBrcks{\deltavar}_0 (h,s) \ (a,e)$ $=$ $( \semBrcks{\deltaacc}(h,s) \ a
										     , \semBrcks{\deltaexp}(h,s) \ e
										     )$\\
\

$\semBrcks{\theta \rightarrow \theta'}_0 C$ $=$ 
					$\Hom{\semBrcks{\theta}(C \concat \_)}{\semBrcks{\theta'}(C \concat \_)}$\\
\indent
$\semBrcks{\theta \rightarrow \theta'}_0 (h,s) \ f \ \widehat{C}$ $=$ 
														$f(\overline{C} \concat \widehat{C})$\\
\indent \indent donde $C \concat \overline{C} = C'$.\\
\

\indent
$\semBrcks{\intexp \leq \realexp}_1 C \ e$ $=$ $\J \circ e$\\
\

\indent
$\semBrcks{\realacc \leq \intacc}_1 C \ a$ $=$ $a \circ \J$\\
\

\indent
$\semBrcks{\deltavar \leq \deltaexp}_1 C \ (a,e)$ $=$ $e$\\
\

\indent
$\semBrcks{\deltavar \leq \deltaacc}_1 C \ (a,e)$ $=$ $a$\\
\

\indent
$\semBrcks{\theta \leq \theta}_1 C$ $=$ $1_{\semBrcks{\theta} C}$\\
\

\indent
$\semBrcks{\theta \leq \theta''}_1 C$ $=$ 
					$\semBrcks{\theta' \leq \theta''}_1 C \circ \semBrcks{\theta \leq \theta'}_1 C$\\
\

\indent
$\semBrcks{(\theta_0 \rightarrow \theta'_0) \leq (\theta_1 \rightarrow \theta'_1)}_1 C \ f \ \widehat{C}$ \\
			\indent \indent \indent \indent \indent \indent
			$=$ 
			$\semBrcks{\theta'_0 \leq \theta'_1}_1 (C \concat \widehat{C}) 
				\circ 
			(f \ \widehat{C}) 
				\circ 
			\semBrcks{\theta_1 \leq \theta_0}_1 (C \concat \widehat{C}) 
			$\\

con $\J$ la inyecci\'on de enteros en reales.

\end{definition}

Ahora que hemos definido las ecuaciones sem\'anticas para nuestros tipos 
hagamos un repaso sobre las mas relevantes de ellas. En determinados momentos
vamos a hablar acerca de $\textit{alcance con forma}$, a lo que nos vamos
a referir es, no solo al contexto en el cual un identificador tiene sentido,
si no adem\'as la forma que debe tener un estado en ese contexto.

\begin{itemize}
\item $\semBrcks{\deltaexp}C$, como ya hemos mencionado ser\'a una funci\'on 
de un estado en un conjunto $S_\delta$ de valores, la motivaci\'on de 
esta definici\'on es poder disponer del estado para obtener el valor de 
una variable imperativa cuando se la utiliza como expresi\'on.

\item $\semBrcks{\deltaexp}(h,s) \ e$, acá $e : C \rightarrow S_\delta$, luego
hacemos la transformaci\'on componiendo con $h : C' \rightarrow C$, para obtener
$e \circ h : C' \rightarrow S_\delta$.

\item $\semBrcks{\commt}C$, esta tal vez sea la mas intuitiva, ser\'a
una funci\'on de un estado con forma $C$ en otro con la misma forma $C$ y
como en todos los casos contemplando la no terminaci\'on.

\item $\semBrcks{\commt}(h,s) \ c$, parecido a como pasaba para $\deltaexp$,
tenemos un $c : C \rightarrow C_\bot$ y tenemos que 
$s : (C \rightarrow C_\bot) \rightarrow (C' \rightarrow C'_\bot)$, luego
$s \ c : C' \rightarrow C'_\bot$.

\item $\semBrcks{\deltaacc}C$, el tipo representa a la variable como contenedora
de valores, luego la sem\'antica ser\'a una funci\'on que toma un valor en $S_\delta$,
un estado y devuelve un nuevo estado con el valor de la variable modificado.

\item $\semBrcks{\deltaacc}(h,s) \ a$, como mencion\'abamos antes, 
$a : S_\delta \rightarrow (C \rightarrow C_\bot)$ y
$s : (C \rightarrow C_\bot) \rightarrow (C' \rightarrow C'_\bot)$, por lo tanto
con la composici\'on $s \circ a : S_\delta \rightarrow (C' \rightarrow C'_\bot)$
obtenemos la nueva funci\'on que actualiza valores de una variable en un estado
extendido.

\item $\semBrcks{\theta \rightarrow \theta'}C$, para interpretar esta ecuaci\'on
podemos empezar cuestionando porque no podr\'ia estar definida de la siguiente 
manera,\\

$\semBrcks{\theta \rightarrow \theta'}C = \semBrcks{\theta}C \rightarrow \semBrcks{\theta'}C$\\

y el problema esta en bajo que alcance se realiza la aplicaci\'on, 
b\'asicamente puede suceder que la aplicaci\'on suceda en un alcance
que tiene nuevas declaraciones y como consecuencia de esto, el estado tenga diferente
forma. La soluci\'on entonces se basa en obtener cuanto se extendió el estado.

\item $\semBrcks{\theta \rightarrow \theta'} (h,s) \ f$, pensemos que $f$ puede
aplicarse en un alcance con, por lo menos, forma $C$ y queremos que pase a, por lo menos,
poder aplicarse en un alcance con forma $C'$, entonces ampliamos hasta por lo menos
la forma $C'$, con $\overline{C}$ y agregamos la posibilidad de seguir ampliando con $\widehat{C}$.

\item $\semBrcks{(\theta_0 \rightarrow \theta'_0) \leq (\theta_1 \rightarrow \theta'_1)}_1 C \ f \ \widehat{C}$,
lo que sucede con esta ecuaci\'on no es muy diferente a lo que pasa con la definici\'on hecha en
lambda leq, el \'unico cuidado que hay que tener es el de extender la forma de $C$.

\end{itemize}

Pasemos ahora a definir la sem\'antica de nuestros contextos, de igual manera que
hicimos con los tipos, empecemos analizando los tipos de las ecuaciones que vamos
a definir. Sea $\pi$ un objeto de $\Pi$ luego tenemos que,\\

$\semBrcks{\pi}C : \PDom$, \\

$\semBrcks{\pi}(h,s) : \semBrcks{\pi}C \rightarrow \semBrcks{\pi}C'$ y\\

$\semBrcks{\pi \rTo^{\leq} \pi'}_1C : \semBrcks{\pi}C \rightarrow \semBrcks{\pi'}C$\\

\begin{definition}\label{algol:contextsemfunctor}
Sea $\semBrcks{ \_ } : \Pi \rightarrow \CD$ un funtor, tal que

$\semBrcks{\pi}_0C$ $=$ $\prod\limits_{\iota \in dom \ \pi} \semBrcks{\pi\iota}C$\\
\

\indent
$\semBrcks{\pi}_0(h,s) \ \eta$ $=$ $\prod\limits_{\iota \in dom \ \pi} 
												\semBrcks{\pi\iota}(h,s)(\eta\iota)$\\
\

\

\indent
$\semBrcks{\pi \leq \pi'}_1C$ $=$ $\prod\limits_{\iota \in dom \ \pi} 
												\semBrcks{\pi\iota \leq \pi'\iota}C(\eta\iota)$

\end{definition}

De la pasada definici\'on la ecuaci\'on que nos va a interesar ser\'a $\semBrcks{\pi}_0(h,s) \ \eta$,
esta nos servir\'a para acomodar un ambiente $\eta$ a una determinada forma cuando lo extendemos
agregando un valor, veremos adem\'as que esto pasa solamente para la abstracci\'on lambda y
la declaraci\'on de variable imperativa.\\

Ahora que hemos definido la sem\'antica de contextos y tipos, podemos continuar con
la sem\'antica de los juicios de tipado de las frases. Como hicimos antes vamos a definir un 
funtor, solo que este tomar\'a un juicio de tipado $\pi \vdash e : \theta$ y 
devolver\'a una transformaci\'on natural del funtor $\semBrcks{\pi}$ en el funtor $\semBrcks{\theta}$ 
indexada por objetos de $\C$.\\
\

\noindent
$\texttt{Denotal Sem:}$ Constantes.\\

$\semBrcks{ \pi \vdash b : \boolexp }C \ \eta \ \sigma$ $=$ $\iotabot \ b$\\

$\semBrcks{ \pi \vdash i : \intexp  }C \ \eta \ \sigma$ $=$ $\iotabot \ i$\\

$\semBrcks{ \pi \vdash r : \realexp }C \ \eta \ \sigma$ $=$ $\iotabot \ r$\\

\noindent
$\texttt{Denotal Sem:}$ Operadores unarios.\\

$\semBrcks{ \pi \vdash \neg b : \boolexp }C$ 
$=$ 
$(\lambda b . \ \iotabot \neg b)_{\dbot} \circ \semBrcks{\pi \vdash b : \boolexp}C$\\

$\semBrcks{ \pi \vdash -i : \intexp }C$ 
$=$ 
$(\lambda i . \ \iotabot -i)_{\dbot} \circ \semBrcks{\pi \vdash i : \intexp}C$\\

$\semBrcks{ \pi \vdash -r : \realexp }C$ 
$=$ 
$(\lambda r . \ \iotabot -r)_{\dbot} \circ \semBrcks{\pi \vdash r : \realexp}C$\\

\noindent
$\texttt{Denotal Sem:}$ Operadores binarios\\

$\semBrcks{ \pi \vdash b \owedge b' : \boolexp }C \ \eta \ \sigma$ 
$=$ \\
\indent \indent \indent
$(\lambda b . \ (\lambda b' . \ \iotabot (b \owedge b'))_{\dbot}
\semBrcks{\pi \vdash b' : \boolexp}C \ \eta \ \sigma)_{\dbot}
\semBrcks{\pi \vdash b : \boolexp}C \ \eta \ \sigma$\\

con $\owedge \in \{ \wedge,\vee,\Rightarrow,\Leftrightarrow \}$\\

$\semBrcks{ \pi \vdash i \oplus i' : \deltaexp }C \ \eta \ \sigma$ 
$=$ \\
\indent \indent \indent
$(\lambda i . \ (\lambda i' . \ \iotabot (i \oplus i'))_{\dbot}
\semBrcks{\pi \vdash i' : \deltaexp}C \ \eta \ \sigma)_{\dbot}
\semBrcks{\pi \vdash i : \deltaexp}C \ \eta \ \sigma$\\

con $\oplus \in \{ +,-,*,/\,\rem \}$, $\delta \in \{\intt,\realt\}$\\

$\semBrcks{ \pi \vdash e \ominus e' : \boolexp }C \ \eta \ \sigma$ 
$=$ \\
\indent \indent \indent 
$(\lambda e . (\lambda e' . \iotabot (e \ominus e'))_{\dbot}
\semBrcks{\pi \vdash e' : \deltaexp}C \ \eta \ \sigma)_{\dbot}
\semBrcks{\pi \vdash e : \deltaexp}C \ \eta \ \sigma$\\

con $\ominus \in \{\leq,\geq,<,> \}$, $\delta \in \{\intt,\realt\}$\\

$\semBrcks{ \pi \vdash e \ominus e' : \boolexp }C \ \eta \ \sigma$ 
$=$ \\
\indent \indent \indent 
$(\lambda e . (\lambda e' . \iotabot (e \ominus e'))_{\dbot}
\semBrcks{\pi \vdash e' : \deltaexp}C \ \eta \ \sigma)_{\dbot}
\semBrcks{\pi \vdash e : \deltaexp}C \ \eta \ \sigma$\\

con $\ominus \in \{=,\neq\}$\\

\noindent
$\texttt{Denotal Sem:}$ Expresi\'on condicional.\\

$\semBrcks{ \pi \vdash \cifthenelse{b}{e}{e'}: \deltaacc}C \ \eta \ z \ \sigma$ 
$=$ \\
\indent \indent \indent 
$(\lambda b . \ if \ b $ $then \ \semBrcks{ \pi \vdash e : \deltaacc}C \ \eta \ z \ \sigma$\\
\indent \indent \indent \indent \indent \ \ \ \
$else \ \semBrcks{ \pi \vdash e' : \deltaacc}C \ \eta \ z \ \sigma)_{\dbot}$ 
$(\semBrcks{ \pi \vdash b : \boolexp}C \ \eta \ \sigma)$\\

$\semBrcks{ \pi \vdash \cifthenelse{b}{e}{e'}: \deltaexp}C \ \eta \ \sigma$ 
$=$ \\
\indent \indent \indent 
$(\lambda b . \ if \ b $ $then \ \semBrcks{ \pi \vdash e : \deltaexp}C \ \eta \ \sigma$\\
\indent \indent \indent \indent \indent \ \ \ \
$else \ \semBrcks{ \pi \vdash e' : \deltaexp}C \ \eta \ \sigma)_{\dbot}$ 
$(\semBrcks{ \pi \vdash b : \boolexp}C \ \eta \ \sigma)$\\

$\semBrcks{ \pi \vdash \cifthenelse{b}{e}{e'}: \commt}C \ \eta \ \sigma$ 
$=$ \\
\indent \indent \indent 
$(\lambda b . \ if \ b $ $then \ \semBrcks{ \pi \vdash e : \deltaacc}C \ \eta \ \sigma$\\
\indent \indent \indent \indent \indent \ \ \ \
$else \ \semBrcks{ \pi \vdash e' : \deltaacc}C \ \eta \ \sigma)_{\dbot}$ 
$(\semBrcks{ \pi \vdash b : \boolexp}C \ \eta \ \sigma)$\\

$\semBrcks{ \pi \vdash \cifthenelse{b}{e}{e'}: \deltavar}C\eta$ 
$=$ \\ 
\indent \indent
$\langle \ \semBrcks{ \pi \vdash \cifthenelse{b}{e}{e'}: \deltaacc}C\eta$
$, \semBrcks{ \pi \vdash \cifthenelse{b}{e}{e'}: \deltaexp}C\eta \ \rangle$ \\

En este punto vamos a hacer un par\'entesis para comentar lo que cuando
presentamos los juicios de tipado validos para el lenguaje quedo pospuesto.
Recordado, \'ibamos a evitar que el juicio de tipado
$\pi \vdash \cifthenelse{b}{e}{e'} : \theta \rightarrow \theta'$, 
sea valido y, bas\'andonos en las ecuaciones sem\'anticas para los 
distintos juicios de tipado de la expresi\'on condicional que hemos
dado, la raz\'on entonces esta en notar que para evaluar el comando
condicional tenemos que "rescatar" el estado para poder evaluar
el juicio de la guarda $\pi \vdash b : \boolexp$, entonces para
el caso de en que nuestra expresi\'on condicional tipa a 
$\deltaexp$ o $\commt$ es sencillo porque el estado esta "a la mano",
ya para $\deltaacc$ no es tan cierto pero no es una limitaci\'on vemos
que primero tenemos que "rescatar" un $z$ y despu\'es reci\'en aparece
el estado. \\
Veamos ahora algunas de las complicaciones cuando
el tipo de nuestro juicio de tipado para la expresi\'on condicional 
tiene varias flechas($\rightarrow$), supongamos tenemos el juicio
$\pi \vdash \cifthenelse{b}{f}{f'} : \theta \rightarrow \theta' \rightarrow \theta''$ y
recordamos que para evaluar algo con tipo flecha, por su tipo, tenemos que
tener una posible expansi\'on del estado, un valor para agregar al ambiente que
ser\'a el valor pasado por argumento y finalmente aparece nuestro estado.\\
¿Como saber cuantos $z'$s y $C'$s hay que rescatar hasta encontrarse el estado?; 
por ejemplo ac\'a $f$ podr\'ia ser la expresi\'on $\lambda v. ff$ tal que, 
abusando de notaci\'on, $v : \theta \rightarrow \theta'$. Entonces esto 
implicar\'ia rescatar un solo $z$ y un solo $C$ para encontrar el estado y
podemos saber que tipo tiene $v$ por tener tipado explicito, para terminar
tomar\'iamos  este $z$ y $C$ y evaluar\'iamos cada caso de la expresi\'on
condicional pasandole estos valores, parecido a como hacemos cuando
tenemos el tipo $\deltaacc$. Esta entonces parecer\'ia ser una posible 
soluci\'on, pero surge otra complicaci\'on supongamos $f'$ es igual a
$(\lambda v . \lambda v'. ff)h$ es decir, $f'$ tipa correctamente pero
sin embargo no es una abstracci\'on lambda, si no que hay una aplicaci\'on
y esto implica entonces que rescatar el estado es distinto para una componente
que para otra de la expresi\'on condicional. En resumen, no es tan sencillo
saber de que forma rescatar el estado para, recordando, evaluar la guarda.\\

\noindent
$\texttt{Denotal Sem:}$ Aplicaci\'on.\\

$\semBrcks{ \pi \vdash ee' : \theta' }C \ \eta$ 
$=$ 
$\semBrcks{ \pi \vdash e : \theta \rightarrow \theta' }C \ \eta \ \lrangles{} \
(\semBrcks{ \pi \vdash e' : \theta }C \ \eta)$\\

\noindent
$\texttt{Denotal Sem:}$ Operador de punto fijo.\\

$\semBrcks{ \pi \vdash \rec e : \theta}C \ \eta$ 
$=$ 
$\Y_{\semBrcks{\theta}C} \ 
(\semBrcks{ \pi \vdash e : \theta \rightarrow \theta}C \ \eta \ \lrangles{})$\\

\noindent
$\texttt{Denotal Sem:}$ Identificador.\\

$\semBrcks{ \pi \vdash \iota : \theta }C \ \eta$ $=$ $\eta \ \iota$
\ \ \ \ \ \ \ \ \ \ \ \ \ \ cuando $\iota:\theta$ $\in$ $\pi$.\\

\noindent
$\texttt{Denotal Sem:}$ \cskip.\\

$\semBrcks{ \pi \vdash \cskip : \commt }C \ \eta \ \sigma$ $=$ $\iotabot \ \sigma$\\

\noindent
$\texttt{Denotal Sem:}$ Composici\'on.\\

$\semBrcks{ \pi \vdash \cseq{e}{e'} : \commt }C \ \eta$ 
$=$ 
$(\semBrcks{\pi \vdash e' : \commt}C \ \eta)_{\dbot}
\circ
(\semBrcks{ \pi \vdash e : \commt}C \ \eta)$\\

\noindent
$\texttt{Denotal Sem:}$ \cwhile.\\

$\semBrcks{ \pi \vdash \cwhiledo{b}{e} : \commt }C \ \eta$ 
$=$ \\
\indent \indent \indent
$\Y_{\semBrcks{\commt}C}$ $(\lambda c . \ \lambda \sigma . \ $\\
\indent \indent \indent \indent \indent \indent
$(\lambda b . \ if \ b $ $then \ c_{\dbot} (\semBrcks{\pi \vdash e : \commt}C \ \eta \ \sigma)$\\
 \indent \indent  \indent \indent \indent \indent \indent \indent \ \ \ \
$else \ \iotabot \ \sigma)_{\dbot}$ \
$(\semBrcks{ \pi \vdash b : \boolexp}C \ \eta \ \sigma))$\\

\noindent
$\texttt{Denotal Sem:}$ Asignaci\'on.\\

$\semBrcks{ \pi \vdash \assig{e}{e'} : \commt }C \ \eta \ \sigma$ 
$=$ \\
\indent \indent \indent \indent \indent 
$(\lambda x . \ \semBrcks{\pi \vdash e : \deltaacc}C \ \eta \ x \ \sigma)_{\dbot}
(\semBrcks{ \pi \vdash e' : \deltaexp }C \ \eta \ \sigma)$\\

\noindent
$\texttt{Denotal Sem:}$ Abstracci\'on lambda.\\

$\semBrcks{ \pi \vdash \lambda \iota_{\theta} . \ e : \theta \rightarrow \theta' }C \ \eta \ C' \ z$ 
$=$ 
$\semBrcks{ \pi,\iota:\theta \vdash e : \theta' } \ (C \concat C') \
[ \ \semBrcks{\pi}(h,s) \ \eta \ | \ \iota:z \ ]$\\

con $(h,s)$ $:$ $C \rTo (C \concat C')$ \\

Hasta aqu\'i hemos definido todas las ecuaciones sem\'anticas de $\Alike$ salvo
para el comando $\cnew \ \deltavar$, para este vamos a tener dos definiciones
y con estas, en conjunto con las dos categor\'ias de estados, vamos a completar 
las dos sem\'anticas que estudiamos.\\

$\texttt{Denotal Sem:}$ Declaraci\'on de variable (Stack discipline).\\

$\semBrcks{\pi \vdash \newdeltavar{\iota}{ei}{c} : \commt}C \ \eta \ \sigma$ 
$=$ \\ \indent \indent
$H_{\bot} ((\lambda \ v . \ \semBrcks{\pi,\iota:\deltavar \vdash c : \commt}
		\ (C\concat\lrangles{S_\delta}) \ \eta_{ext} \ \sigma_{ext})_{\dbot}$
\\ \indent \indent  \indent  \indent  \indent \indent  \indent
\indent \indent \indent \indent \indent \indent \indent
\indent \indent \indent
$(\semBrcks{\pi \vdash ei : \deltaexp}C \ \eta \ \sigma))$\\

con $(h,s)$ $:$ $C \rTo (C \concat \lrangles{S_\delta})$ \\
\indent \indent \ \
$a$ $=$ $\lambda v. \ \lambda \sigmahat . \ \iotabot ((head_{C} \sigmahat) \concat \lrangles{v})$\\
\indent \indent \ \
$e$ $=$ $ \iotabot \circ last_{S_\delta}$\\
\indent \indent \ \
$\sigma_{ext} = \sigma \concat \lrangles{v} $\\
\indent \indent \ \
$\eta_{ext} = [ \ \semBrcks{\pi}(h,s) \ \eta \ | \ \iota:\lrangles{a,e} \ ]$\\
\indent \indent \ \
$H = head_C$\\

\noindent
Expliquemos la ecuaci\'on detenidamente, recordando que esta es la versi\'on
con stack discipline, el comportamiento que este comando deber\'ia tener es evaluar
el comando $c$ en un estado y ambiente extendido con el identificador $\iota$, 
este con el valor inicial correspondiente de haber evaluado $ei$
y al terminar la evaluaci\'on de $c$ contraer el estado y el ambiente, tirando
de esa manera toda referencia al identificador $\iota$.\\

Suponiendo siempre la evaluaci\'on de nuestros comandos es distinta de $\bot$, 
lo primero que hacemos es evaluar el juicio de tipado $\pi \vdash ei : \deltaexp$
con el ambiente y estado sin extender, esta evaluaci\'on nos retorna un valor
que vamos a nombrar $v$, este ser\'a el valor para inicializar el identificador $\iota$.
Luego pasamos a evaluar $\pi \vdash c : \commt$, ac\'a vamos a tener que extender 
el ambiente y el estado, as\'i como tambi\'en el conjunto de estados con el tipo
b\'asico del identificador. \\
Extender el estado ser\'a simplemente pegar por atr\'as el valor $v$ al estado
$\sigma$, extender el ambiente ya no es tan simple por un lado si ocurre que 
agregamos el identificador $\iota$ con el par aceptador-evaluador por atr\'as
pero no al ambiente tal cual lo ten\'iamos, si no a un nuevo ambiente que es
el resultado de acomodar el ambiente original a la extensi\'on del estado, mas
adelante vamos a ver por qu\'e esto es importante. Sobre el par aceptador-evaluador
podemos notar que evaluar $\iota$ como expresi\'on ser\'a evaluar $e$, es decir,
ser\'a obtener el ultimo elemento del estado y evaluar $\iota$ como aceptador ser\'a
recortar el estado hasta justo antes del valor actual y pegar por atr\'as el nuevo
valor.\\
Finalmente al terminar de evaluar $\pi \vdash c : \commt$ obtenemos un estado
con forma $C \concat \lrangles{S_\delta}$ y necesitamos contraerlo para eliminar
el valor de $\iota$, esto lo hace $H_\bot$ recortando el estado hasta justo antes
del valor, justo como pasaba con la evaluaci\'on de $\iota$ como aceptador pero
sin agregar ning\'un valor nuevo.\\

Repasemos con un ejemplo todo lo comentado anteriormente.\\

\noindent
\textbf{Ejemplo}
Supongamos tenemos un comando,\\

$\cnew \ \intvar \ \assig{\iota}{0} \ \cin$\\
\indent \indent
$\cnew \ \intvar \ \assig{\kappa}{1} \ \cin$\\
\indent \indent \indent
$\assig{\kappa}{\iota}$ $\cseq$\\
\indent
$\cskip$\\

y la siguiente derivaci\'on que nos prueba que esta bien tipado para
obtener el juicio de tipado $\vdash \cseq{\cnew \iota \ }{ \ \cskip} : \commt$, donde
$\cnew \iota$ es el primer comando $\cnew \intvar$, adem\'as vamos a
llamar $\cnew \kappa$ al otro comando $\cnew \intvar$.

\begin{center}
\AxiomC{}
\UnaryInfC{$\pi_{\iota,\kappa} \vdash \kappa : \intvar$}
\AxiomC{$\intvar \leq \intexp$}
\BinaryInfC{$\pi_{\iota,\kappa} \vdash \kappa : \intacc$}
\AxiomC{}
\UnaryInfC{$\pi_{\iota,\kappa} \vdash \iota : \intvar$}
\AxiomC{$\intvar \leq \intexp$}
\BinaryInfC{$\pi_{\iota,\kappa} \vdash \iota : \intexp$}
\BinaryInfC{$\pi_\iota,\kappa:\intvar \vdash \assig{\kappa}{\iota} : \commt$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{}
\UnaryInfC{$\pi_\iota \vdash 1 : \intexp$}
\AxiomC{}
\UnaryInfC{$\pi_\iota,\kappa:\intvar \vdash \assig{\kappa}{\iota} : \commt$}
\BinaryInfC{$\iota:\intvar \vdash \cnew \kappa : \commt$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{}
\UnaryInfC{$\vdash 0 : \intexp$}
\AxiomC{}
\UnaryInfC{$\iota:\intvar \vdash \cnew \kappa : \commt$}
\BinaryInfC{$\vdash \cnew \iota : \commt$}
\AxiomC{}
\UnaryInfC{$\vdash \cskip : \commt$}
\BinaryInfC{$\vdash \cseq{\cnew \iota \ }{ \ \cskip} : \commt$}
\DisplayProof
\end{center}

\noindent
Ahora que tenemos nuestro juicio de tipado $\vdash \cseq{\cnew \iota \ }{ \ \cskip} : \commt$
podemos continuar con la evaluaci\'on, podemos empezar evaluando a vista y notar que
a lo que pretendemos que evalu\'e este juicio es a $\emptystate$, el estado vac\'io, 
pero adem\'as y es
la principal raz\'on por la que esta el comando $\cskip$, es ver que luego de ejecutar
un $\cnew \ \deltavar$ el comando que siga a este no sabe nada acerca de lo que paso
dentro y con los identificadores. Tomamos ambiente y estado vac\'ios, \\

\noindent
$\semBrcks{\vdash \cseq{\cnew \iota \ }{ \ \cskip} : \commt}\emptyshape\emptyenv\emptystate$ $=$
$((\semBrcks{\vdash \cskip : \commt}\emptyshape\emptyenv)_{\dbot}
\circ 
\semBrcks{\vdash \cnew \iota : \commt}\emptyshape\emptyenv) \emptystate$\\

ahora pasemos a evaluar juicio de tipado para $\cnew \iota$\\

\noindent
$\semBrcks{\vdash \cnew \iota : \commt}\emptyshape\emptyenv\emptystate$
$=$ \\ \indent \indent
$H_{\bot} ((\lambda \ v . \ \semBrcks{\iota:\intvar \vdash \cnew \kappa : \commt}
		\ (\emptyshape \concat\lrangles{S_\intt}) \ \eta_{ext} \ \sigma_{ext})_{\dbot}$
\\ \indent \indent  \indent  \indent  \indent \indent  \indent
\indent \indent \indent \indent \indent \indent \indent
\indent \indent \indent
$(\semBrcks{\vdash 0 : \intexp}\emptyshape \ \emptyenv \ \emptystate))$\\

donde $\eta_{ext}$ ser\'a simplemente agregar el identificador $\iota$ y el
par $\lrangles{a_\iota,e_\iota}$ y $\sigma_{ext}$ ser\'a la lista de valores
con un \'unico valor, el $0$.\\

\noindent
$\semBrcks{\vdash \cnew \iota : \commt}\emptyshape\emptyenv\emptystate$
$=$
$H_{\bot} \semBrcks{\iota:\intvar \vdash \cnew \kappa : \commt}
				    \ \lrangles{S_\intt} \ 
		  	        [ \ \iota : \lrangles{a_\iota,e_\iota} \ ] \ \lrangles{0}$\\

con $a_\iota = \lambda v. \ \lambda \sigmahat . \ \iotabot 
				((head_{\lrangles{}} \sigmahat) \concat \lrangles{v})$\\
\indent \indent \ 
$e_\iota$ $=$ $ \iotabot \circ last_{S_\intt}$\\

evaluamos el $\cnew \kappa$ como hicimos con $\cnew \iota$ pero con el cuidado
de que ahora no tenemos forma, ni ambiente, ni estado vac\'ios\\

\noindent
$\semBrcks{\pi_\iota \vdash \cnew \kappa : \commt}
	\ \lrangles{S_\intt} \ 
	[ \ \iota : \lrangles{a_\iota,e_\iota} \ ] \ \lrangles{0}$ $=$ \\
\indent \indent
$H_{\bot} ((\lambda \ v . \ \semBrcks{\pi_\iota,\kappa:\intvar \vdash \assig{\kappa}{\iota}: \commt}
		\ (\lrangles{S_\intt} \concat\lrangles{S_\intt}) \ \eta_{ext} \ \sigma_{ext})_{\dbot}$
\\ \indent \indent  \indent  \indent  \indent \indent  \indent
\indent \indent \indent \indent \indent \indent \indent
\indent \indent \indent
$(\semBrcks{\pi_\iota \vdash 1 : \intexp}\emptyshape \ \emptyenv \ \emptystate))$\\

como antes, tenemos que ver quienes ser\'an $\eta_{new}$ y $\sigma_{new}$, empezando por
este ultimo es sencillo y es simplemente pegar por atr\'as el valor $1$, en cuanto a
$\eta_{new}$ ya no es tan directo, lo que sucede es que vamos a tener que acomodar el
antiguo ambiente, $[ \ \iota : \lrangles{a_\iota,e_\iota} \ ]$, y luego agregar
el identificador $\kappa$ con el par $\lrangles{a_\kappa,e_\kappa}$.\\
Para acomodar el ambiente utilizamos 
$\semBrcks{\pi_\iota}(h,s)$ donde $\lrangles{S_\intt} \rTo^{(h,s)} \lrangles{S_\intt,S_\intt}$,
es decir, este funtor aplicado a la flecha $(h,s)$ toma un ambiente de tipo
$\semBrcks{\pi_\iota}\lrangles{S_\intt}$ y nos retorna un ambiente con tipo 
$\semBrcks{\pi_\iota}\lrangles{S_\intt,S_\intt}$.\\

$\semBrcks{\pi_\iota}(h,s) \ [ \ \iota : \lrangles{a_\iota,e_\iota} \ ]$ $=$
$[ \ \iota : \semBrcks{\pi_\iota \iota}(h,s) \lrangles{a_\iota,e_\iota} \ ]$ $=$\\

\indent
$[ \ \iota : \semBrcks{\intvar}(h,s) \lrangles{a_\iota,e_\iota} \ ]$ $=$
$[ \ \iota : \lrangles{\semBrcks{\intacc}(h,s) a_\iota,\semBrcks{\intacc}(h,s)e_\iota} \ ]$ $=$\\

\indent
$[ \ \iota : \lrangles{s \circ a_\iota,e_\iota \circ h} \ ]$\\

ahora si podemos extender el ambiente 
$[ \ \iota : \lrangles{s \circ a_\iota,e_\iota \circ h} \ | \
	\kappa : \lrangles{a_\kappa,e_\kappa}\ ]$ y este sera nuestro nuevo ambiente $\eta_{new}$.
Luego podemos avanzar un poco mas con la evaluaci\'on y pasar el limpio la ultima ecuaci\'on,\\

\noindent
$\semBrcks{\pi_\iota \vdash \cnew \kappa : \commt}
	\ \lrangles{S_\intt} \ 
	[ \ \iota : \lrangles{a_\iota,e_\iota} \ ] \ \lrangles{0}$ $=$ \\
	\indent 
	$H_{\bot} 
	\semBrcks{\pi_{\iota,\kappa} \vdash \assig{\kappa}{\iota}: \commt}
		\ \lrangles{S_\intt,S_\intt}
		\ [ \ \iota : \lrangles{s \circ a_\iota,e_\iota \circ h} \ | \
			\kappa : \lrangles{a_\kappa,e_\kappa}\ ] 
		\ \lrangles{0,1}$\\

con $a_\kappa = \lambda v. \ \lambda \sigmahat . \ \iotabot 
				((head_{\lrangles{S_\intt}} \sigmahat) \concat \lrangles{v})$\\
\indent \indent \ 
	$e_\kappa$ $=$ $ \iotabot \circ last_{S_\intt}$\\
\indent \indent \ 
	$(s \circ a_\iota) \ x \ \sigmahat = 
		(\lambda \sigma . \ \sigma \concat tail_{\lrangles{S_\intt}}\sigmahat)_{\bot} 
			(a_\iota \ x \ (head_{\lrangles{S_\intt}} \sigmahat))$\\
\indent \indent \ 
	$e_\iota \circ h = e_\iota \circ head_{\lrangles{S_\intt}}$.\\
	
Haciendo un repaso general de lo que llevamos hecho, tenemos evaluado hasta el comando
de asignaci\'on, esto implica haber evaluado los comandos para introducir variables 
imperativas, lo mas importante a repasar es los pares aceptor-evaluador de los
identificadores $\iota$ y $\kappa$. Empezando con $\iota$, vemos que usarlo como
expresi\'on es utilizar como $e_\iota$ que
sabe como retornar el valor asociado a $\iota$ dado un estado con forma $\lrangles{S_\intt}$,
luego acomodando esto al introducir $\kappa$, lo que sucede es que usar como expresi\'on
a $\iota$ es utilizar $e_\iota \circ head_{\lrangles{S_\intt}}$, es decir, dado
un estado con forma $\lrangles{S_\intt, S_\intt}$, primero nos quedamos con la
parte inicial sin la extensi\'on del identificador $\kappa$ y luego ya podemos
utilizar $e_\iota$ en un estado con forma $\lrangles{S_\intt}$.\\
Si en cambio usamos a $\iota$ como aceptador de valor, entonces ser\'a utilizar
$a_\iota$ que sabe recortar un estado con forma $\lrangles{S_\intt}$ de manera
de perder justo el valor asociado a $\iota$, como pasaba con antes, al agregar
$\kappa$ hay que acomodar la funci\'on a utilizar cuando usamos $\iota$ como aceptador,
para esto vamos a usar 
$s : (\lrangles{S_\intt} \rightarrow \lrangles{S_\intt}_{\bot})
	 \rightarrow 
	 (\lrangles{S_\intt,S_\intt} \rightarrow \lrangles{S_\intt,S_\intt}_{\bot})$, esta
funci\'on b\'asicamente va a tomar $a \ x : \lrangles{S_\intt} \rightarrow \lrangles{S_\intt}_{\bot}$,
recortar un la parte inicial de un estado con forma $\lrangles{S_\intt,S_\intt}$, aplicar
$a \ x$ en ese estado y luego concatenar el resultado de esa aplicaci\'on con la parte
final del estado original con forma $\lrangles{S_\intt,S_\intt}$.\\
Notar que para las funciones $e_\kappa$ y $a_\kappa$ el comportamiento es igual
al comportamiento para $e_\iota$ y $a_\iota$ cuando no se agregan variables imperativas 
nuevas. Hecho este repaso, podemos continuar con la evaluaci\'on del juicio de tipado
de la asignaci\'on, ac\'a vamos a ver como es que utilizamos un identificador 
tanto como aceptor y como valor.\\

$\semBrcks{\pi_{\iota,\kappa} \vdash \assig{\kappa}{\iota}: \commt}
		\ \lrangles{S_\intt,S_\intt} \ \eta_{\iota,\kappa}
		\ \lrangles{0,1}$ $=$\\
\indent \indent \indent \indent
$(\lambda x . \ \semBrcks{\pi_{\iota,\kappa} \vdash \kappa : \intacc}
	\lrangles{S_\intt,S_\intt} 
	\ \eta_{\iota,\kappa}
	\ x \ \lrangles{0,1})_{\dbot}$\\
\indent \indent \indent \indent \indent \indent \indent \indent
$(\semBrcks{ \pi_{\iota,\kappa} \vdash \iota : \intexp } 
	\ \lrangles{S_\intt,S_\intt}
	\ \eta_{\iota,\kappa} 
	\ \lrangles{0,1})$\\
	
evaluemos detenidamente el juicio de tipado para $\iota$, es importante notar que en
la derivaci\'on de nuestro juicio de tipado  para tipar $\iota$ no alcanza con
simplemente buscar en el contexto, ya que $\iota$ tiene tipo $\intvar$ entonces
hay que usar una regla de subtipado, por lo tanto esto impacta de la siguiente
manera en nuestra evaluaci\'on\\

$\semBrcks{ \pi_{\iota,\kappa} \vdash \iota : \intexp } 
	\ \lrangles{S_\intt,S_\intt}
	\ \eta_{\iota,\kappa} 
	\ \lrangles{0,1}$ $=$ \\
	\indent
	$(\semBrcks{\intvar \leq \intexp} \ \lrangles{S_\intt,S_\intt}
	\circ 
	\semBrcks{ \pi_{\iota,\kappa} \vdash \iota : \intvar } \ \lrangles{S_\intt,S_\intt})
		\ \eta_{\iota,\kappa} 
		\ \lrangles{0,1}$ $=$\\
	\indent
	$\semBrcks{\intvar \leq \intexp} \ \lrangles{S_\intt,S_\intt} 
				(\eta_{\iota,\kappa} \ \iota) \ \lrangles{0,1}$ $=$\\
	\indent
	$\semBrcks{\intvar \leq \intexp} \ \lrangles{S_\intt,S_\intt} 
				(\lrangles{s \circ a_\iota,e_\iota \circ h}) \ \lrangles{0,1}$ $=$
	$(e_\iota \circ h) \ \lrangles{0,1}$ $=$\\
	\indent
	$(e_\iota \circ head_{\lrangles{S_\intt}}) \lrangles{0,1}$ $=$
	$last_{S_\intt} (head_{\lrangles{S_\intt}} \ \lrangles{0,1})$ $=$
	$last_{S_\intt} \lrangles{0}$ $=$ $0$\\
	
volviendo ahora con $\iota$ evaluado como expresi\'on\\

$\semBrcks{\pi_{\iota,\kappa} \vdash \assig{\kappa}{\iota}: \commt}
		\ \lrangles{S_\intt,S_\intt} \ \eta_{\iota,\kappa}
		\ \lrangles{0,1}$ $=$\\
\indent \indent \indent \indent
$\semBrcks{\pi_{\iota,\kappa} \vdash \kappa : \intacc}
	\lrangles{S_\intt,S_\intt} 
	\ \eta_{\iota,\kappa}
	\ 0 \ \lrangles{0,1}$\\

ahora evaluando similar a como hicimos con $\iota$ y teniendo el mismo cuidado
con el subtipado del identificador $\kappa$ de $\intvar$ a $\intacc$\\

$\semBrcks{\pi_{\iota,\kappa} \vdash \kappa : \intacc}
	\lrangles{S_\intt,S_\intt} 
	\ \eta_{\iota,\kappa}
	\ 0 \ \lrangles{0,1}$ $=$\\
	\indent
$(\semBrcks{\intvar \leq \intacc} \ \lrangles{S_\intt,S_\intt}
	\circ 
	\semBrcks{ \pi_{\iota,\kappa} \vdash \kappa : \intvar } \ \lrangles{S_\intt,S_\intt})
		\ \eta_{\iota,\kappa} 
		\ 0 \ \lrangles{0,1}$ $=$\\
	\indent
$\semBrcks{\intvar \leq \intacc} \ \lrangles{S_\intt,S_\intt} (\eta_{\iota,\kappa} \kappa)
		\ 0 \ \lrangles{0,1}$ $=$\\
	\indent
$\semBrcks{\intvar \leq \intacc} \ \lrangles{S_\intt,S_\intt} \lrangles{a_\kappa,e_\kappa}
		\ 0 \ \lrangles{0,1}$ $=$ $a_\kappa \ 0 \ \lrangles{0,1}$ $=$\\
	\indent
$\iotabot ((head_{\lrangles{S_\intt}} \lrangles{0,1}) \concat \lrangles{0})$ $=$
$\iotabot (\lrangles{0} \concat \lrangles{0})$ $=$ $\iotabot \lrangles{0,0}$\\

de nuevo, reescribiendo ahora con la evaluaci\'on terminada de $\kappa$,\\

$\semBrcks{\pi_{\iota,\kappa} \vdash \assig{\kappa}{\iota}: \commt}
		\ \lrangles{S_\intt,S_\intt} \ \eta_{\iota,\kappa}
		\ \lrangles{0,1}$ $=$ $\iotabot \lrangles{0,0}$\\
		
ya casi terminando y volviendo a la evaluaci\'on de la composici\'on entre
$\cnew \iota$ y $\cskip$, \\

$(\semBrcks{\vdash \cskip : \commt}\emptyshape\emptyenv)_{\dbot}
(\semBrcks{\vdash \cnew \iota : \commt}\emptyshape\emptyenv\emptystate)$
$=$\\
\indent 
$(\lambda \sigma . \ \iotabot \sigma)_{\dbot} (H_{\bot} (H_{\bot} \iotabot \lrangles{0,0}))$ $=$\\
\indent
$(\lambda \sigma . \ \iotabot \sigma)_{\dbot}
	((head_{\lrangles{}})_{\bot} ((head_{\lrangles{S_\intt}})_{\bot} \iotabot \lrangles{0,0}))$ $=$\\
\indent
$(\lambda \sigma . \ \iotabot \sigma)_{\dbot}
	(head_{\lrangles{}} \circ head_{\lrangles{S_\intt}})_{\bot} \iotabot \lrangles{0,0}$ $=$\\
\indent
$(\lambda \sigma . \ \iotabot \sigma)_{\dbot}
	((head_{\lrangles{}} (head_{\lrangles{S_\intt}} \ \lrangles{0,0})))$ $=$
$(\lambda \sigma . \ \iotabot \sigma)_{\dbot} (\iotabot \lrangles{})$ $=$ 
$\iotabot \lrangles{}$\\

y con esto terminamos la evaluaci\'on del juicio de tipado completo y adem\'as con 
el resultado esperado.

A continuaci\'on vamos a introducir nuestra versi\'on de ecuaci\'on sem\'antica
que en conjunto con la segunda categor\'ia de estados que dimos conforman la sem\'antica
sin stack discipline. Repasando lo que pretendemos con esta sem\'antica ser\'ia, 
que a diferencia de lo que paso en el ejemplo anterior que al terminar de evaluar
un comando $\cnew \deltavar$ el siguiente comando no sabe nada acerca de los
identificadores y valores a los que se evalu\'o, nosotros queremos esta informaci\'on
quede visible, aunque no sea posible acceder.\\

En el momento en que introducimos las definiciones de estados mencion\'abamos 
que, para esta segunda versi\'on, \'ibamos a abandonar el hecho de que los estados tengan
forma, ahora que avanzamos mas podemos comentar la raz\'on, uno puede pensar para la
versi\'on con stack discipline que la forma del estado esta totalmente relacionada
con la cantidad, y el tipo, de identificadores que se han introducido y son accesibles
en cierto comando interno del $\cnew \deltavar$, de esta manera cuando termin\'abamos 
de evaluar un $\cnew \deltavar$ autom\'aticamente perd\'iamos un elemento del estado.
La cuesti\'on ahora es que, nosotros queremos que la cantidad de valores de un
estado no tenga relaci\'on con la cantidad de comandos para introducir identificadores.\\

\noindent
$\texttt{Denotal Sem:}$ Declaraci\'on de variable (Sin stack discipline).\\

$\semBrcks{\pi \vdash \newdeltavar{\iota}{e}{c} : \commt}C \ \eta \ \sigma$ 
$=$ \\ \indent \indent
$H_{\bot} ((\lambda \ v . \ \semBrcks{\pi,\iota:\deltavar \vdash c : \commt}
		\ C \ \eta_{new} \ \sigma_{new})_{\dbot}$
$(\semBrcks{\pi \vdash e : \deltaexp}C \ \eta \ \sigma))$\\

con 
$a \ v \ \sigma$ $=$ $\iotabot [ \ \sigma \ | \ \iota:\iotadelta v \ ] $\\
\indent \indent \ \
$e \ \sigma$ $=$ $(\lambda v . v)_{\delta}\sigma \iota$\\
\indent \indent \ \
$\sigma_{new} = [ \ \sigma \ | \ \iota:\iotadelta v \ ]$\\
\indent \indent \ \
$\eta_{new} = [ \ \eta \ | \ \iota:\lrangles{a,e} \ ]$\\
\indent \indent \ \
$H = 1_C$\\

De la misma forma que hicimos con la primera ecuaci\'on sem\'antica de este
comando, repasemos cada parte de la nueva ecuaci\'on. En general todo sobre 
la nueva ecuaci\'on es igual, los detalles importantes est\'an en las funciones
$a$, $e$ y $H$, empecemos notando que $H$ la cual
en la otra sem\'antica era al encargada de recortar el estado cuando terminaba 
la evaluci\'on del cuerpo, ahora es una identidad, es decir, vamos a retornar el
estado tal cual estaba al terminar de evaluar el cuerpo. La funci\'on para evaluar
el identificador como aceptador, es decir $a$, sobrescribe el valor antiguo del estado,
lo nuevo que aparece ac\'a es el $\iota_\delta$ esta funci\'on es la inyecci\'on
de $S_\delta$ en $S$, recordando $S$ era la uni\'on disjunta de $S_\intt$, 
$S_\realt$ y $S_\boolt$.\\
Para explicar la funci\'on para evaluar el identificador
como valor, primero vamos a introducir la funci\'on $(\_)_{\delta}$ que dada una $f$
de $S_\delta$ en $S_\delta$ se define as\'i,
\begin{center}
$f_{\delta}(\iota_{\delta}x) = f \ x$
\end{center}
luego simplemente ser\'a aplicar el estado al identificador, la \'unica 
salvedad importante es que $\sigma \iota : S$ y nosotros necesitamos algo de tipo
$S_\delta$, para esto utilizamos $(\lambda v. \ v)_\delta$.\\

Existe una observaci\'on importantes que surge de pensar el siguiente caso,
supongamos tenemos un $e : \Sigma \rightarrow S_\intt$ y un $\sigma \iota : S_\boolt$,
luego $e$ podr\'ia estar definido as\'i $(\lambda v . v)_{\intt}\sigma \iota$, esto es
un problema ya que $(\lambda v . v)_{\intt}$ espera algo de tipo entero y 
$\sigma \iota$ es algo de tipo booleano, para manejar esto deber\'iamos 
introducir todo un manejo extra de errores de tipos en momento de evaluaci\'on, 
y como consecuencia nuestra sem\'antica sin stack discipline generar\'ia una
nueva clase de errores que la sem\'antica con stack discipline no genera.\\

Para solucionar esto podemos pensar en que casos nuestra sem\'antica sin
stack discipline generar\'ia estos errores, nos damos cuenta que esto puede pasar
solo cuando intentamos evaluar juicios de tipado no cerrados, es decir que 
contienen variables libre. Analicemos por qu\'e esta afirmaci\'on, empecemos
suponiendo que tenemos un comando cerrado y que tenemos un $\sigma$ cualquiera,
es decir que por ejemplo tiene identificadores con valore asociados, luego
cada vez que aparezca un identificador como comando, lo que tiene que haber ocurrido
es que este identificador es un subcomando de uno o varios $\cnew \deltavar$ y por lo
tanto al evaluar este comando pisamos la posible existencia de un identificador
asociado a un valor del tipo inadecuado. El problema entonces surge cuando evaluamos
un comando no cerrado, ya que es posible que nos encontremos con un identificador
como comando a evaluar, sin que este sea subcomando de uno o varios $\cnew \deltavar$
y por lo tanto el tipo del valor asociado al identificador en el estado no sea el 
correcto.\\

La soluci\'on a esto entonces es pensar que, para los programas que vamos a
querer evaluar o que pretendemos sean programas validos a evaluar, nunca 
son no cerrados, por lo tanto este comportamiento extraño que podr\'ia llegar
a tener nuestro evaluador sin stack discipline puede ser despreciable bas\'andonos
en este hecho, y que ser\'a una restricci\'on importante en caso de comparar
las sem\'anticas de uno y otro.\\

\section{Naturalidad de las ecuaciones sem\'anticas}

Para el lenguaje lambda arrow, y por lo tanto tambi\'en para lambda leq, probamos
que las ecuaciones estuvieran bien definidas, es decir que fueran funciones continuas.
Ahora vamos a hacer lo mismo para las ecuaciones de \Alike con la diferencia de que
por las definiciones categ\'oricas que hicimos vamos a probar que nuestras ecuaciones
sean transformaciones naturales. Dado un juicio de tipado valido, $\pi \vdash e : \theta$,
vamos a querer probar que el siguiente diagrama conmuta dada una flecha $C \rTo{(h,s)} C'$
en $\C$,
\begin{center}
\begin{diagram}
   \semBrcks{\pi}C & & \rTo^{\semBrcks{\pi \vdash e : \theta}C} & & \semBrcks{\theta}C \\
   \dTo^{\semBrcks{\pi}(h,s)} & & & & \dTo^{\semBrcks{\theta}(h,s)} & \\
   \semBrcks{\pi}C' & & \rTo^{\semBrcks{\pi \vdash e : \theta}C'} & & \semBrcks{\theta}C' &
\end{diagram}
\end{center}

\

\begin{proposition}
Sea $(h,s) : C \rTo C'$ cualquier y dadas $f : C \rightarrow C_\bot$ y 
$f' : C \rightarrow C_\bot$ vale,

\begin{center}
$s(f'_{\dbot} \circ f)$ $=$ $s(f')_{\dbot} \circ s(f)$
\end{center}

\end{proposition}

\begin{theorem}[de naturalidad]
Dado un juicio de tipado valido $\pi \vdash e : \theta$ y una flecha 
$C \rTo{(h,s)} C'$ en $\C$ se cumple,
\begin{center}
$\semBrcks{\theta}(h,s) \circ \semBrcks{\pi \vdash e : \theta}C$ $=$
$\semBrcks{\pi \vdash e : \theta}C' \circ \semBrcks{\pi}(h,s)$
\end{center}
es decir el diagrama anterior conmuta.

\end{theorem}

\begin{proof}
Procedamos por inducci\'on en la estructura de la derivaci\'on de los juicios de tipado,
supongamos un $\eta : \semBrcks{\pi}C$ y un $\sigma' : C'$ tal que $\sigma : C$,
$\overline{\sigma} : \overline{C}$, $C \concat \overline{C} = C'$ y 
$\sigma \concat \overline{\sigma} = \sigma'$.

\begin{itemize}

\item Casos base
\begin{itemize}
\item Supongamos $\pi \vdash b : \boolexp$, \\

$\semBrcks{\boolexp}(h,s)(\semBrcks{\pi \vdash b : \boolexp}C \ \eta) \sigma'$ $=$
$\semBrcks{\boolexp}(h,s)(\lambda \sigma. \ \iota \ b) \sigma'$ $=$ \\
$((\lambda \sigma. \ \iota \ b) \circ h)\sigma'$ $=$
$(\lambda \sigma. \ \iota \ b) (h \sigma')$ $=$
$\iota \ b$ $=$ $\semBrcks{\pi \vdash b : \boolexp}C'(\semBrcks{\pi}(h,s)\eta)\sigma'$

\item (Analogo $\intexp$ y $\realexp$)

\item Supongamos $\pi \vdash \iota : \theta$,\\

por un lado tenemos,
$\semBrcks{\theta}(h,s)(\semBrcks{\pi \vdash \iota : \theta}C \ \eta)$ $=$
$\semBrcks{\theta}(h,s)(\eta \iota)$ $=$ $(\star)$ \\

y por el otro, $\semBrcks{\pi \vdash \iota : \theta}C'(\semBrcks{\pi}(h,s)\eta)$ $=$
$(\semBrcks{\pi}(h,s)\eta) \iota$ $=$ $(\star \star)$,\\

ahora separamos en casos segundo $\theta$.

\begin{itemize}
\item Supongamos $\theta = \deltaexp$ y $\eta\iota = e$, \\

$(\star)$ $=$ $\eta\iota \circ h$ $=$ $e \circ h$\\

$(\star\star)$ $=$ $e \circ h$, esto ultimo ya que acomodar el ambiente con forma
$C$ a la forma $C'$, es componer con $h$ a todos los valores del tipo $\deltaexp$.

\item Supongamos $\theta = \commt$ y $\eta\iota = c$,\\

$(\star)$ $=$ $s(\eta\iota)$ $=$ $s \ c$\\

$(\star\star)$ $=$ $s \ c$, como para el caso de $\deltaexp$ pero ahora con valores
de tipo $\commt$.

\item Supongamos $\theta = \deltaacc$ y $\eta\iota = a$,\\

$(\star)$ $=$ $s \circ \eta\iota$ $=$ $s \circ a$\\

$(\star\star)$ $=$ $s \circ a$, al igual que para $\commt$ y $\deltaexp$.

\item Supongamos $\theta = \theta_0 \rightarrow \theta_1$ y $\eta \iota = f$,\\

$(\star)$ $=$ $\lambda \widehat{C} . \ (\eta\iota)(\overline{C}\concat\widehat{C})$ $=$ 
$\lambda \widehat{C} . \ f(\overline{C}\concat\widehat{C})$

$(\star\star)$ $=$ $\lambda \widehat{C} . \ f(\overline{C}\concat\widehat{C})$, al igual
que en los casos anteriores.
\end{itemize}
\end{itemize}

\item Casos inductivos
\begin{itemize}
\item Supongamos $\pi \vdash \neg e : \boolexp$,\\

$\semBrcks{\boolexp}(h,s)(\semBrcks{\pi \vdash \neg e : \boolexp}C\eta)\sigma'$ $=$\\
$\semBrcks{\boolexp}(h,s)(\lambda \sigma . \ 
 (\lambda b. \ \iotabot \neg b)_{\dbot}(\semBrcks{\pi \vdash e : \boolexp}C\eta\sigma))\sigma'$ $=$\\
$((\lambda b. \ \iotabot \neg b)_{\dbot}(\semBrcks{\pi \vdash e : \boolexp}C\eta\sigma) 
	\circ 
	h) \sigma'$ $=$ \\
$(\lambda b. \ \iotabot \neg b)_{\dbot}(\semBrcks{\pi \vdash e : \boolexp}C\eta(h\sigma'))$ $=$\\
$(\lambda b. \ \iotabot \neg b)_{\dbot}
	((\semBrcks{\pi \vdash e : \boolexp}C\eta \circ h)\sigma'))$ $=$\\
$(\lambda b. \ \iotabot \neg b)_{\dbot}
	(\semBrcks{\boolexp}(h,s)(\semBrcks{\pi \vdash e : \boolexp}C\eta)\sigma')$\\
	
hasta ac\'a ha sido simplemente reescribir usando definiciones, de esta manera llegamos
a poder aplicar la hip\'otesis inductiva,\\

$(\lambda b. \ \iotabot \neg b)_{\dbot}
	(\semBrcks{\boolexp}(h,s)(\semBrcks{\pi \vdash e :\boolexp}C\eta)\sigma')$ $=$\\
$(\lambda b. \ \iotabot \neg b)_{\dbot}
	(\semBrcks{\pi \vdash e : \boolexp}C(\semBrcks{\pi}(h,s)\eta)\sigma')$ $=$\\
$\semBrcks{\pi \vdash \neg e : \boolexp}C(\semBrcks{\pi}(h,s)\eta)\sigma'$

\item (Analogo operadores binarios)

\item Supongamos $\pi \vdash \cifthenelse{b}{e}{e'} : \theta$, para este caso
nos vamos a enfocar en probar el caso para $\theta = \deltaexp$ ya que los dem\'as
son an\'alogos o incluso iguales pensando en $\commt$.\\

$\semBrcks{\deltaexp}(h,s)
	(\semBrcks{\pi \vdash \cifthenelse{b}{e}{e'} : \deltaexp}C\eta)\sigma'$ $=$\\
$(\semBrcks{\pi \vdash \cifthenelse{b}{e}{e'} : \deltaexp}C\eta \circ h)\sigma'$ $=$\\
$\semBrcks{\pi \vdash \cifthenelse{b}{e}{e'} : \deltaexp}C\eta (h\sigma')$ $=$\\
$(\lambda b . \ if \ b $ $then \ \semBrcks{ \pi \vdash e : \deltaexp}C \ \eta \ (h\sigma')$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
$else \ \semBrcks{ \pi \vdash e' : \deltaexp}C \ \eta \ (h\sigma'))_{\dbot}$ \\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$(\semBrcks{ \pi \vdash b : \boolexp}C \ \eta \ (h\sigma'))$\\

resolviendo el otro lado de la igualdad,\\

$\semBrcks{\pi \vdash \cifthenelse{b}{e}{e'} : \deltaexp}C'
							(\semBrcks{\pi}(h,s)\eta)\sigma'$ $=$\\
$(\lambda b . \ if \ b $ $then \ \semBrcks{ \pi \vdash e : \deltaexp}C' \ 
						(\semBrcks{\pi}(h,s)\eta) \ \sigma'$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
$else \ \semBrcks{ \pi \vdash e' : \deltaexp}C' \ 
						(\semBrcks{\pi}(h,s)\eta) \ \sigma')_{\dbot}$ \\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$(\semBrcks{ \pi \vdash b : \boolexp}C' \ (\semBrcks{\pi}(h,s)\eta) \ \sigma')$\\

ahora vamos a usar hip\'otesis inductiva en el juicio de tipado de $b$,\\

$\semBrcks{ \pi \vdash b : \boolexp}C \ \eta \ (h\sigma')$ $=$
$\semBrcks{ \pi \vdash b : \boolexp}C' \ (\semBrcks{\pi}(h,s)\eta) \ \sigma'$\\

y entonces vamos a suponer que la evaluaci\'on de juicio de tipado
$\pi \vdash b : \boolexp$ es verdadera, luego tenemos que ver que\\

$\semBrcks{ \pi \vdash e : \deltaexp}C \ \eta \ (h\sigma')$ $=$ 
$\semBrcks{ \pi \vdash e : \deltaexp}C' \ (\semBrcks{\pi}(h,s)\eta) \ \sigma'$\\

pero esto es directo usando hip\'otesis inductiva. Por otro lado, si supus\'ieramos
la evaluaci\'on $\pi \vdash b : \boolexp$ es falso, entonces es directo de la misma
manera que antes.

\item Supongamos $\pi \vdash ee' : \theta'$, \\

$\semBrcks{\pi \vdash ee' : \theta'}C'(\semBrcks{\pi}(h,s)\eta)$ $=$\\
$\semBrcks{\pi \vdash e' : \theta \rightarrow \theta'}C'
		(\semBrcks{\pi}(h,s)\eta)\lrangles{}
		(\semBrcks{\pi \vdash e : \theta}C'(\semBrcks{\pi}(h,s)\eta))$ $=$\\
$(\semBrcks{\theta \rightarrow \theta'}(h,s)
	(\semBrcks{\pi \vdash e' : \theta \rightarrow \theta'}C \eta))\lrangles{}
	(\semBrcks{\theta}(h,s)(\semBrcks{\pi \vdash e : \theta}C\eta))$ $=$\\
$\semBrcks{\pi \vdash e' : \theta \rightarrow \theta'}C \eta \overline{C}
	(\semBrcks{\theta}(h,s)(\semBrcks{\pi \vdash e : \theta}C\eta))$\\

hasta ac\'a usamos la definici\'on de la ecuaci\'on sem\'antica de la aplicaci\'on,
aplicamos hip\'otesis inductiva dos veces y usamos la definici\'on del funtor
$\semBrcks{\theta \rightarrow \theta'}$ aplicado a $(h,s)$ y 
$(\semBrcks{\pi \vdash e' : \theta \rightarrow \theta'}C \eta)$, donde 
$\overline{C}$ es tal que $C \concat \overline{C} = C'$.\\
Ahora si analizamos un poco mas la definici\'on de este funtor que mencion\'abamos
nos damos cuenta que $\semBrcks{\pi \vdash e' : \theta \rightarrow \theta'}C \eta$
es una transformaci\'on natural indexada por objetos de $\C$ que va del funtor
$\semBrcks{\theta}$ al funtor $\semBrcks{\theta'}$, luego el siguiente diagrama
debe conmutar,

\begin{center}
\begin{diagram}
   \semBrcks{\theta}C & & \rTo^{\semBrcks{\pi \vdash e' : \theta \rightarrow \theta'}C \eta \lrangles{}} & & \semBrcks{\theta'}C \\
   \dTo^{\semBrcks{\theta}(h,s)} & & & & \dTo^{\semBrcks{\theta'}(h,s)} & \\
   \semBrcks{\theta}C' & & \rTo^{\semBrcks{\pi \vdash e' :  \theta \rightarrow \theta'}C' \eta \overline{C}} & & \semBrcks{\theta'}C' &
\end{diagram}
\end{center}

es decir, la conmutatividad del diagrama anterior nos da la siguiente igualdad,\\

$\semBrcks{\theta'}(h,s) 
\circ 
\semBrcks{\pi \vdash e' \theta \rightarrow \theta'}C\eta\lrangles{}$ $=$
$\semBrcks{\pi \vdash e' \theta \rightarrow \theta'}C\eta\overline{C} 
\circ
\semBrcks{\theta}(h,s) 
$\\

luego usando esta igualdad obtenemos,\\

$\semBrcks{\pi \vdash e' : \theta \rightarrow \theta'}C \eta \overline{C}
	(\semBrcks{\theta}(h,s)(\semBrcks{\pi \vdash e : \theta}C\eta))$ $=$\\
$\semBrcks{\theta'}(h,s)(
\semBrcks{\pi \vdash e' \theta \rightarrow \theta'}C\eta\lrangles{} 
(\semBrcks{\pi \vdash e \theta}\C\eta))$ $=$\\
$\semBrcks{\theta'}(h,s)(\semBrcks{\pi \vdash ee' : \theta'}C\eta)$\\

\item Supongamos $\pi \vdash \rec{e} : \theta$, \\

(\textcolor{red}{Me acabo de dar cuenta que tengo cosas que revisar bien para
escribir esta prueba. ¿ que es una flecha entre transformaciones naturales ?})

\item Supongamos $\pi \vdash \cskip : \commt$,\\

$\semBrcks{\commt}(h,s)(\semBrcks{\pi \vdash \cskip}C\eta)\sigma'$ $=$
$s(\semBrcks{\pi \vdash \cskip}C\eta)\sigma'$ $=$\\
$s(\lambda \sigma . \ \iotabot \sigma)\sigma'$ $=$
$(\lambda \sigmahat . \ (\lambda \sigma. \ 
			\sigma \concat tail_{\overline{C}}\sigmahat)_{\bot}
		((\lambda \sigma . \ \iotabot \sigma)(h \sigmahat)))\sigma'$ $=$\\
$(\lambda \sigma. \ \sigma \concat tail_{\overline{C}}\sigma')_{\bot}
		((\lambda \sigma . \iotabot \sigma)(head_{C} \sigma'))$ $=$\\
$\iotabot (head_{C} \sigma' \concat tail_{\overline{C}}\sigma')$ $=$ $\iotabot \sigma'$ $=$
$\semBrcks{\pi \vdash \cskip : \commt}C'(\semBrcks{\pi}(h,s)\eta)\sigma'$\\

\item Supongamos $\pi \vdash \cseq{e}{e'} : \commt$,\\

$\semBrcks{\commt}(h,s)(\semBrcks{\pi \vdash \cseq{e}{e'} : \commt}C\eta)$ $=$\\
$\semBrcks{\commt}(h,s)
	((\semBrcks{\pi \vdash e' : \commt}C\eta)_{\dbot} 
	\circ
	\semBrcks{\pi \vdash e : \commt}C\eta
	)$ $=$ \\
$s((\semBrcks{\pi \vdash e' : \commt}C\eta)_{\dbot} 
	\circ
	\semBrcks{\pi \vdash e : \commt}C\eta
	)$\\

ahora usando la proposici\'on 3 podemos reescribir de la siguiente manera,\\

$s((\semBrcks{\pi \vdash e' : \commt}C\eta)_{\dbot} 
	\circ
	\semBrcks{\pi \vdash e : \commt}C\eta
	)$ $=$\\
$s(\semBrcks{\pi \vdash e' : \commt}C\eta)_{\dbot} 
	\circ
	s(\semBrcks{\pi \vdash e : \commt}C\eta)$ $=$\\
$\semBrcks{\commt}(h,s)(\semBrcks{\pi \vdash e' : \commt}C\eta)_{\dbot} 
	\circ
 \semBrcks{\commt}(h,s)(\semBrcks{\pi \vdash e : \commt}C\eta)$\\

usando ahora hip\'otesis inductiva dos veces obtenemos,\\

$\semBrcks{\commt}(h,s)(\semBrcks{\pi \vdash e' : \commt}C\eta)_{\dbot} 
	\circ
 \semBrcks{\commt}(h,s)(\semBrcks{\pi \vdash e : \commt}C\eta)$ $=$\\
$\semBrcks{\pi \vdash e' : \commt}C'(\semBrcks{\pi}(h,s)\eta)_{\dbot}
	\circ
\semBrcks{\pi \vdash e : \commt}C'(\semBrcks{\pi}(h,s)\eta)$ $=$\\
$\semBrcks{\pi \vdash \cseq{e}{e'} : \commt}C'(\semBrcks{\pi}(h,s)\eta)$\\

\item Supongamos $\pi \vdash \cwhiledo{b}{e} : \commt$, para este caso
recordamos que $\sigma \concat \overline{\sigma} = \sigma'$,\\

$\semBrcks{\commt}(h,s)(\semBrcks{\pi \vdash \cwhiledo{b}{e} : \commt}C\eta)\sigma'$ $=$\\
$s(\semBrcks{\pi \vdash \cwhiledo{b}{e} : \commt}C\eta)\sigma'$ $=$\\
$(\lambda \sigma. \ \sigma \concat \sigmaover)_{\bot}
				(\semBrcks{\pi \vdash \cwhiledo{b}{e} : \commt}C \ \eta \ \sigma)$\\

olvid\'emonos por un momento de $(\lambda \sigma. \ \sigma \concat \sigmaover)_{\bot}$
y analicemos $\semBrcks{\pi \vdash \cwhiledo{b}{e} : \commt}C \ \eta \ \sigma$, utilizando
la definici\'on de la ecuaci\'on\\

$\semBrcks{\pi \vdash \cwhiledo{b}{e} : \commt} C \eta \sigma$ $=$ \\
\indent \ \ \ \ \ \ \ \
$\Y_{\semBrcks{\commt}C} (\lambda c . \lambda \sigma . (\lambda b . if \ b$ \\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$then \ c_{\dbot}(\semBrcks{\pi \vdash e : \commt}C \eta \sigma)$ \\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$else \ \iotabot \sigma)_{\dbot} (\semBrcks{\pi \vdash b : \boolexp}C\eta\sigma))\sigma$ \\

podemos notar que si el comando eval\'ua a un $\iotabot\sigmahat$, es porque 
existieron evaluaciones de $\semBrcks{\pi \vdash e : \commt}C \eta \sigma$
con resultados $\sigma_0, \sigma_1, \ldots, \sigma_n, \sigmahat$. Adem\'as 
el resultado de la evaluaci\'on completa ser\'a ,
$(\lambda \sigma. \ \sigma \concat \sigmaover)_{\bot} \iotabot \sigmahat$ $=$
$\iotabot (\sigmahat \concat \sigmaover)$, es decir, solamente modificamos la parte del estado
con forma $C$. Tomemos ahora el otro lado de la igualdad que queremos probar,\\

$\semBrcks{\pi \vdash \cwhiledo{b}{e} : \commt} C' (\semBrcks{\pi}(h,s)\eta) \sigma'$ $=$ \\
\indent \ \ \ \ \ \ \ \
$\Y_{\semBrcks{\commt}C'} (\lambda c' . \lambda \sigma' . (\lambda b . if \ b$ \\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$then \ c'_{\dbot}(\semBrcks{\pi \vdash e : \commt}C'(\semBrcks{\pi}(h,s)\eta) \sigma')$ \\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$else \ \iotabot \sigma')_{\dbot} 
	(\semBrcks{\pi \vdash b : \boolexp}C'(\semBrcks{\pi}(h,s)\eta)\sigma'))\sigma'$ \\

luego aplicando hip\'otesis inductiva en los juicios de tipado de $b$ y $e$ y reescribiendo
un poco las ecuaciones obtenemos,\\

$\semBrcks{\pi \vdash \cwhiledo{b}{e} : \commt} C' (\semBrcks{\pi}(h,s)\eta) \sigma'$ $=$ \\
\indent \ \ \ \ \ \ \ \
$\Y_{\semBrcks{\commt}C'} (\lambda c' . \lambda \sigma' . (\lambda b . if \ b$ \\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$then \ c'_{\dbot}((\lambda \sigma. \ \sigma \concat \sigmaover)_{\bot}
					\semBrcks{\pi \vdash e : \commt}C \eta \sigma)$ \\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$else \ \iotabot \sigma')_{\dbot} 
	(\semBrcks{\pi \vdash b : \boolexp}C \eta \sigma))\sigma'$ \\
	
ahora vamos a suponer, como antes, que existieron evaluaciones de 
$\semBrcks{\pi \vdash e : \commt}C \eta \sigma$
con resultados $\sigma_0, \sigma_1, \ldots, \sigma_n, \sigmahat$, luego
aplicar cada $\sigma_i$ a $(\lambda \sigma . \ \sigma \concat \sigmaover)$ nos
genera la sucesi\'on de resultados 
$\sigma_0\concat\sigmaover, \sigma_1\concat\sigmaover, \ldots, 
\sigma_n\concat\sigmaover, \sigmahat\concat\sigmaover$, por lo tanto el resultado
de evaluar el comando completo es $\iotabot (\sigmahat\concat\sigmaover)$.

\item Supongamos $\pi \vdash \assig{a}{e} : \commt$, empecemos desarrollando cada
extremo de la igualdad que queremos probar,\\

$\semBrcks{\commt}(h,s)(\semBrcks{\pi \vdash \assig{a}{e} : \commt}C\eta)\sigma'$ $=$\\
$(\lambda \sigma. \ \sigma \concat \sigmaover)_{\bot}
				(\semBrcks{\pi \vdash \assig{a}{e} : \commt}C\eta\sigma)$ $=$\\
$(\lambda \sigma. \ \sigma \concat \sigmaover)_{\bot}(
	(\lambda v. \ \semBrcks{\pi \vdash a : \deltaacc}C\eta \ v \ \sigma)_{\dbot}
	(\semBrcks{\pi \vdash e : \deltaexp}C\eta\sigma))$\\
	
$\semBrcks{\pi \vdash \assig{a}{e} : \commt}C'(\semBrcks{\pi}(h,s)\eta)\sigma'$ $=$\\
$(\lambda v. \ 
	\semBrcks{\pi \vdash a : \deltaacc}C'(\semBrcks{\pi}(h,s)\eta)\ v \ \sigma')_{\dbot}$
$(\semBrcks{\pi \vdash e : \deltaexp}C'(\semBrcks{\pi}(h,s)\eta)\sigma')$ \\

usando hip\'otesis inductiva dos veces obtenemos por un lado,\\

$\semBrcks{\pi \vdash a : \deltaacc}C'(\semBrcks{\pi}(h,s)\eta)\ v \ \sigma'$ $=$\\
$\semBrcks{\deltaacc}(h,s)(\semBrcks{\pi \vdash a : \deltaacc}C\eta) v \ \sigma'$ $=$
$s(\semBrcks{\pi \vdash a : \deltaacc} C \eta \ v)\sigma'$ $=$\\
$(\lambda \sigma . \sigma \concat \sigmaover)_{\bot}
				(\semBrcks{\pi \vdash a : \deltaacc} C \eta \ v \ \sigma)$
				
y por otro lado,\\

$\semBrcks{\pi \vdash e : \deltaexp}C'(\semBrcks{\pi}(h,s)\eta)\sigma'$ $=$\\
$\semBrcks{\deltaexp}(h,s)(\semBrcks{\pi \vdash e : \deltaexp}C \eta)\sigma'$ $=$
$(\semBrcks{\pi \vdash e : \deltaexp}C \eta \circ h)\sigma'$ $=$\\
$\semBrcks{\pi \vdash e : \deltaexp}C \eta \sigma$\\

usando estos dos resultados que acabamos de deducir, pasando en limpio tenemos\\

$(\lambda v. \ 
	\semBrcks{\pi \vdash a : \deltaacc}C'(\semBrcks{\pi}(h,s)\eta)\ v \ \sigma')_{\dbot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$(\semBrcks{\pi \vdash e : \deltaexp}C'(\semBrcks{\pi}(h,s)\eta)\sigma')$ $=$\\
$(\lambda v. \ (\lambda \sigma . \sigma \concat \sigmaover)_{\bot}
				(\semBrcks{\pi \vdash a : \deltaacc} C \eta \ v \ \sigma))_{\dbot}$
$(\semBrcks{\pi \vdash e : \deltaexp}C \eta \sigma)$ \\

luego podemos suponer $\semBrcks{\pi \vdash e : \deltaexp}C \eta \sigma$ $=$ $\iotabot v$ distinto
de $\bot$,\\

$(\lambda \sigma . \sigma \concat \sigmaover)_{\bot}
				(\semBrcks{\pi \vdash a : \deltaacc} C \eta \ v \ \sigma)$ $=$\\
$(\lambda \sigma . \sigma \concat \sigmaover)_{\bot}
	((\semBrcks{\pi \vdash a : \deltaacc} C \eta \ v \ \sigma)_{\dbot}
			(\semBrcks{\pi \vdash e : \deltaexp}C \eta \sigma))$ $=$\\
$\semBrcks{\commt}(h,s)(\semBrcks{\pi \vdash \assig{a}{e} : \commt}C\eta)\sigma'$\\

\item Supongamos $\pi \vdash \clambda{\iota}{\theta}{\ e} : \theta \rightarrow \theta'$, tomemos
$\Chat$ objeto de $\C$ y un $z : \semBrcks{\theta}(C'\concat\Chat)$ \\

$\semBrcks{\theta \rightarrow \theta'}(h,s)
(\semBrcks{\pi \vdash 
	\clambda{\iota}{\theta}{\ e} : \theta \rightarrow \theta'}C \eta)\Chat \ z$ $=$\\
$\semBrcks{\pi \vdash \clambda{\iota}{\theta}{\ e} : \theta \rightarrow \theta'}C 
	\eta (\Cover \concat \Chat) \ z$ $=$\\
$\semBrcks{\pi,\iota:\theta \vdash e : \theta'}
	(C \concat \Cover \concat \Chat)
	[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:z \ ]$ $=$\\
$\semBrcks{\pi,\iota:\theta \vdash e : \theta'}
	(C' \concat \Chat)
	[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:z \ ]$ $=$\\

ahora bien, empezamos notando que el operador $\concat$ es asociativo por lo tanto
$(C \concat (\Cover \concat \Chat)) = (C' \concat \Chat)$, luego adem\'as
$(\hover,\sover) : C \rTo (C \concat \Cover \concat \Chat)$, y por lo tanto
$(\hover,\sover) : C \rTo (C' \concat \Chat)$.\\

$\semBrcks{\pi \vdash \clambda{\iota}{\theta}{\ e} : \theta \rightarrow \theta'}
		C'(\semBrcks{\pi}(h,s)\eta)\Chat \ z$ $=$\\
$\semBrcks{\pi,\iota:\theta \vdash e : \theta'}(C' \concat \Chat)
			[ \ \semBrcks{\pi}(h',s')(\semBrcks{\pi}(h,s)\eta) \ | \ \iota:z \ ]$\\

donde $(h',s') : C' \rTo (C' \concat \Chat)$,
ahora si prestamos atenci\'on a las dos expresiones finales que nos quedaron, nos 
damos cuenta que ya casi estar\'iamos si no fuera por la forma en que acomodamos
el ambiente, el plan entonces ser\'a probar que $(\hover,\sover) = (h \circ h',s'\circ s)$
donde por definici\'on $(h \circ h',s'\circ s) = (h',s') \circ (h,s)$, luego usando
que $\semBrcks{\pi}$ podemos concluir,

\begin{center}
$\semBrcks{\pi}(\hover,\sover)$ $=$ $\semBrcks{\pi}(h',s') \circ \semBrcks{\pi}(h,s)$
\end{center}

Empecemos probando que $\hover = h \circ h'$, tomamos un estado 
$\sigma \concat \sigmaover \concat \sigmahat$ con forma $C' \concat \Chat$\\

$\hover : (C' \concat \Chat) \rightarrow C$\\
$\hover (\sigma \concat \sigmaover \concat \sigmahat)$ $=$ 
$head_{C} (\sigma \concat \sigmaover \concat \sigmahat)$ $=$ $\sigma$\\

$h : C' \rightarrow C$\\
$h' : (C' \concat \Chat) \rightarrow C'$\\
$(h \circ h') (\sigma \concat \sigmaover \concat \sigmahat)$ $=$
$head_{C}(head_{C'} (\sigma \concat \sigmaover \concat \sigmahat))$ $=$\\
$head_{C}(\sigma \concat \sigmaover)$ $=$ $\sigma$\\

probemos ahora $\sover = s' \circ s$, tomemos $c : C \rightarrow C_\bot$ y
suponemos $c \sigma = \iotabot \sigmatil$\\

$\sover : (C \rightarrow C_\bot) \rightarrow 
		  ((C' \concat \Chat) \rightarrow (C' \concat \Chat)_\bot)$\\
$\sover \ c \ (\sigma \concat \sigmaover \concat \sigmahat)$ $=$
$(\lambda \sigma . \ 
	\sigma \concat (\sigmaover \concat \sigmahat))_{\bot} (c \sigma)$ $=$\\
$\iotabot (\sigmatil \concat \sigmaover \concat \sigmahat)$\\

$s : (C \rightarrow C_\bot) \rightarrow (C' \rightarrow C'_\bot)$\\
$s' : (C' \rightarrow C'_\bot) \rightarrow 
   	  ((C' \concat \Chat) \rightarrow (C' \concat \Chat)_\bot)$\\
$(s' \circ s) \ c \ (\sigma \concat \sigmaover \concat \sigmahat)$ $=$
$s' (s \ c) (\sigma \concat \sigmaover \concat \sigmahat)$ $=$\\
$(\lambda \sigma. \ \sigma \concat \sigmahat)_{\bot}
	(s \ c \ (\sigma \concat \sigmaover))$ $=$\\
$(\lambda \sigma . \ \sigma \concat \sigmahat)_{\bot}
((\lambda \sigma . \ \sigma \concat \sigmaover)_{\bot}(c \sigma))$ $=$\\
$(\lambda \sigma . \ \sigma \concat \sigmahat)_{\bot}
(\iotabot (\sigmatil \concat \sigmaover))$ $=$ 
$\iotabot (\sigmatil \concat \sigmaover \concat \sigmahat)$\\

por lo tanto $(\hover,\sover) = (h \circ h',s'\circ s)$.\\

\item Supongamos $\pi \vdash \newdeltavar{\iota}{ei}{c} : \commt$, la estrategia para
este juicio de tipado ser\'a, resolver por completo un lado haciendo un par de suposiciones
hasta llegar a un estado y luego tomar el lado restante para llegar, usando las suposiciones,
a este mismo estado. Para esto entonces suponemos dos cosas relevantes,

\begin{itemize}
\item $\semBrcks{\pi \vdash ei : \deltaexp}C\eta\sigma = \iotabot v$
\item $\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]
(\sigma\concat \lrangles{v})$ $=$ $\iotabot (\sigmatil \concat \lrangles{\tilde{v}})$
\end{itemize}

\

$\semBrcks{\commt}(h,s)(\semBrcks{\pi \vdash \newdeltavar{\iota}{ei}{c} : \commt}C\eta)\sigma'$ $=$\\
$s (\lambda \sigma . \ \Hbot ((\lambda v .$ \\
\indent \ \ 
	$\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
			$[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]
			(\sigma\concat \lrangles{v}))_{\dbot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
		$(\semBrcks{\pi \vdash ei : \deltaexp}C\eta\sigma)) ) \sigma'$ $=$\\
$(\lambda \sigma . \ \sigma \concat \sigmaover)_{\bot}({head_{C}}_{\bot} ((\lambda v .$ \\
\indent \ \ 
	$\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
			$[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]
			(\sigma\concat \lrangles{v}))_{\dbot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
		$(\semBrcks{\pi \vdash ei : \deltaexp}C\eta\sigma)))$ $=$\\
$(\lambda \sigma . \ \sigma \concat \sigmaover)_{\bot}({head_{C}}_{\bot} ($ \\
\indent \ \ 
	$\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
			$[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]
			(\sigma\concat \lrangles{v})))$ $=$\\
$(\lambda \sigma . \ \sigma \concat \sigmaover)_{\bot}
({head_{C}}_{\bot} (\iotabot (\sigmatil \concat \lrangles{\tilde{v}})))$ $=$\\
$((\lambda \sigma . \ \sigma \concat \sigmaover) \circ
head_{C})_{\bot} (\iotabot (\sigmatil \concat \lrangles{\tilde{v}}))$ $=$\\
$\iotabot (\sigmatil \concat \sigmaover)$\\

detallando ahora los tipos de algunos componentes que van a ser relevantes
mas adelante tenemos,\\

$a : S_\delta \rightarrow 
(C \concat \lrangles{S_\delta}) \rightarrow (C \concat \lrangles{S_\delta})_{\bot}$\\
$e : (C \concat \lrangles{S_\delta}) \rightarrow (S_\delta)_{\bot}$\\
$(\hover,\sover) : C \rTo (C \concat \lrangles{S_\delta})$\\

ahora continuemos con el otro extremo de la igualdad que queremos probar, teniendo 
siempre en cuenta las suposiciones que hicimos al principio de este caso\\

$\semBrcks{\pi \vdash \newdeltavar{\iota}{ei}{c} : \commt}C'(\semBrcks{\pi}(h,s)\eta)\sigma'$ $=$\\
${head_{C'}}_{\bot} ((\lambda v .$ \\
\indent \ \ 
	$\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C' \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
			$[ \ \semBrcks{\pi}(h',s')(\semBrcks{\pi}(h,s)\eta) \ | \ \iota:\lrangles{a',e'} \ ]
			(\sigma' \concat \lrangles{v}))_{\dbot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
	$(\semBrcks{\pi \vdash ei : \deltaexp}C'(\semBrcks{\pi}(h,s)\eta)\sigma'))$\\
	
donde $a' : S_\delta \rightarrow (C' \concat \lrangles{S_\delta}) 
			\rightarrow (C' \concat \lrangles{S_\delta})_{\bot}$\\
$e' : (C' \concat \lrangles{S_\delta}) \rightarrow (S_\delta)_\bot$\\
$(h',s') : C' \rTo (C' \concat \lrangles{S_\delta})$\\

si nos enfocamos en la expresi\'on 
$\semBrcks{\pi \vdash ei : \deltaexp}C'(\semBrcks{\pi}(h,s)\eta)\sigma'$ nos damos cuenta
que podemos aplicar hip\'otesis inductiva, de manera tal que nos quede\\

$\semBrcks{\pi \vdash ei : \deltaexp}C'(\semBrcks{\pi}(h,s)\eta)\sigma'$ $=$\\
$\semBrcks{\deltaexp}(h,s)(\semBrcks{\pi \vdash ei : \deltaexp}C\eta)\sigma'$ $=$\\
$(\semBrcks{\pi \vdash ei : \deltaexp}C\eta \circ head_C) \sigma'$ $=$\\
$\semBrcks{\pi \vdash ei : \deltaexp}C\eta\sigma$ $=$ $\iotabot v$\\

podemos utilizar este resultado entonces para ir reescribiendo\\

${head_{C'}}_{\bot} ((\lambda v .$ \\
\indent \ \ 
	$\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C' \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
			$[ \ \semBrcks{\pi}(h',s')(\semBrcks{\pi}(h,s)\eta) \ | \ \iota:\lrangles{a',e'} \ ]
			(\sigma' \concat \lrangles{v}))_{\dbot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ 
	$(\semBrcks{\pi \vdash ei : \deltaexp}C'(\semBrcks{\pi}(h,s)\eta)\sigma'))$ $=$\\
${head_{C'}}_{\bot} 
	(\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C' \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
			$[ \ \semBrcks{\pi}(h',s')(\semBrcks{\pi}(h,s)\eta) \ | \ \iota:\lrangles{a',e'} \ ]
			(\sigma' \concat \lrangles{v}))$\\
			
llegado este punto, para continuar, lo ideal ser\'ia poder hacer algo parecido
a lo que hicimos hace un instante para evaluar el juicio de tipado de $ei$ el problema
que surge es que no podemos aplicar hip\'otesis inductiva porque nuestro ambiente
no tiene la forma correcta, es decir, nosotros quisi\'eramos que el ambiente
fuera algo de la forma $\semBrcks{\pi,\iota:\deltavar}(\hhat,\shat)\widehat{\eta}$, pero
adem\'as no con cualquiera $\widehat{\eta}$, si no que este sea
$[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]$. 
En resumen, quisi\'eramos que la siguiente igualdad valga

\begin{center}
$\semBrcks{\pi,\iota:\deltavar}(\hhat,\shat)
([ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ])$\\ 
$=$\\
$[ \ \semBrcks{\pi}(h',s')(\semBrcks{\pi}(h,s)\eta) \ | \ \iota:\lrangles{a',e'} \ ]$
\end{center}

donde
$(\hhat,\shat) : (C\concat\lrangles{S_\delta}) \rTo (C'\concat\lrangles{S_\delta})$ 

as\'i que vamos a hacer lo siguiente, vamos a suponer esta igualdad vale, completar la prueba
y para finalizar probaremos la igualdad. Pero antes, nos falta el detalle importante sobre
como son las funciones de la flecha $(\hhat,\shat)$, es decir, en general para cualquier
flecha com\'un podemos saber quienes son las funciones viendo el tipo de la flecha, pero
en particular el tipo de esta flecha no es una simple extensi\'on, presentemos la definici\'on
de cada una\\

$\hhat : (C'\concat\lrangles{S_\delta}) \rightarrow (C\concat\lrangles{S_\delta})$\\
$\hhat \ \sigma = head_{C} (head_{C'}\sigma) \concat tail_{\lrangles{S_{\delta}}}\sigma$\\
$\shat : ((C\concat\lrangles{S_\delta}) \rightarrow (C\concat\lrangles{S_\delta})_{\bot}) 
		 \rightarrow
		 ((C'\concat\lrangles{S_\delta}) \rightarrow (C'\concat\lrangles{S_\delta})_{\bot})$
$\shat \ f \ \sigma = (\lambda \sigma_{v} . \  
				(\hover \sigma_{v}) \concat 
				tail_{\Cover}(tail_{C'}\sigma) \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot} (f (\hhat \sigma))$\\

Entonces, reescribiendo utilizando la igualdad tenemos\\

${head_{C'}}_{\bot}
	(\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C' \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
			$[ \ \semBrcks{\pi}(h',s')(\semBrcks{\pi}(h,s)\eta) \ | \ \iota:\lrangles{a',e'} \ ]
			(\sigma' \concat \lrangles{v}))$ $=$\\
${head_{C'}}_{\bot}
	 (\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C' \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
			$(\semBrcks{\pi,\iota:\deltavar}(\hhat,\shat)
			([ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]))
			(\sigma' \concat \lrangles{v}))$ $=$\\
${head_{C'}}_{\bot}
	(\semBrcks{\commt}(\hhat,\shat)
			(\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
			$[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ])
			(\sigma' \concat \lrangles{v}))$ $=$\\
${head_{C'}}_{\bot}
	(\shat (\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
			$[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ])
			(\sigma' \concat \lrangles{v}))$ $=$\\
${head_{C'}}_{\bot}($\\
$(\lambda \sigma_{v} . \  
				(\hover \sigma_{v}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{v})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot}$ \\
\indent \ \ \ \ \ \ \ \
$(\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]) 
(\hhat (\sigma' \concat \lrangles{v}))))$ $=$\\
${head_{C'}}_{\bot}($\\
$(\lambda \sigma_{v} . \  
				(\hover \sigma_{v}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{v})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot}$ \\
\indent \ \ \ \ \ \ \ \
$(\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]) 
(\sigma \concat \lrangles{v})))$\\

y por fin estamos en condiciones de reescribir usando la segunda suposici\'on sobre
el juicio de tipado de $c$\\

${head_{C'}}_{\bot}($\\
$(\lambda \sigma_{v} . \  
				(\hover \sigma_{v}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{v})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot}$ \\
\indent \ \ \ \ \ \ \ \
$(\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]) 
(\sigma \concat \lrangles{v})))$ $=$\\
${head_{C'}}_{\bot}($\\
$(\lambda \sigma_{v} . \
				(\hover \sigma_{v}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{v})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot}$ \\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
  \ \ \ \ \ \ \ \ \ \
$(\iotabot (\sigmatil \concat \lrangles{\tilde{v}})))$ $=$\\
${head_{C'}}_{\bot}($\\
$(\lambda \sigma_{v} . \
				(\hover \sigma_{v}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{v})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot}$ \\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
  \ \ \ \ \ \ \ \ \ \
$(\iotabot (\sigmatil \concat \lrangles{\tilde{v}})))$ $=$\\
${head_{C'}}_{\bot}($
$(\lambda \sigma_{v} . \
				(\hover \sigma_{v}) \concat 
				\sigmaover \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot}$
$(\iotabot (\sigmatil \concat \lrangles{\tilde{v}})))$ $=$\\
$(head_{C'}$
$\circ$
$(\lambda \sigma_{v} . \
				(\hover \sigma_{v}) \concat 
				\sigmaover \concat
				tail_{\lrangles{S_\delta}}\sigma_{v}))_{\bot}$
$(\iotabot (\sigmatil \concat \lrangles{\tilde{v}}))$ $=$\\
$\iotabot (head_{C'} (\sigmatil \concat \sigmaover \concat \lrangles{\tilde{v}}))$ $=$
$\iotabot (\sigmatil \concat \sigmaover)$\\

por lo tanto, hemos probado la igualdad para el caso del $\cnew \deltavar$. Nos resta 
probar entonces la suposici\'on que hicimos sobre los ambientes, recordando deber\'iamos
probar\\

\begin{center}
$\semBrcks{\pi,\iota:\deltavar}(\hhat,\shat)
([ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ])$\\ 
$=$\\
$[ \ \semBrcks{\pi}(h',s')(\semBrcks{\pi}(h,s)\eta) \ | \ \iota:\lrangles{a',e'} \ ]$
\end{center}

Supongamos un $\kappa$ identificador y dos valores $v$ y $x$ en $S_\delta$, cualesquiera

\begin{itemize}
\item S\'i $\kappa = \iota$, \\

$(\semBrcks{\pi,\iota:\deltavar}(\hhat,\shat)
([ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]))\kappa$ $=$\\
$\semBrcks{(\pi,\iota:\deltavar) \kappa}(\hhat,\shat)\lrangles{a,e}$ $=$\\
$\lrangles{\semBrcks{\deltavar}(\hhat,\shat)a,\semBrcks{\deltavar}(\hhat,\shat)e}$\\

$[ \ \semBrcks{\pi}(h',s')(\semBrcks{\pi}(h,s)\eta) \ | \ \iota:\lrangles{a',e'} \ ] \kappa$ $=$
$\lrangles{a',e'}$\\

probemos ahora que $a' = \semBrcks{\deltavar}(\hhat,\shat)a$ y 
$e' = \semBrcks{\deltavar}(\hhat,\shat)e$\\

$\semBrcks{\deltavar}(\hhat,\shat) \ e \ (\sigma \concat \sigmaover \concat \lrangles{v})$ $=$
$e \ (\hhat (\sigma \concat \sigmaover \concat \lrangles{v}))$ $=$\\
$\iotabot (last_{S_\delta} (\sigma \concat \lrangles{v}))$ $=$ $\iotabot \ v$ $=$
$\iotabot (last_{S_\delta} (\sigma \concat \sigmaover \concat \lrangles{v}))$ $=$ \\
$e' (\sigma \concat \sigmaover \concat \lrangles{v})$\\

$\semBrcks{\deltavar}(\hhat,\shat) \ a \ x \ (\sigma \concat \sigmaover \concat \lrangles{v})$ $=$
$\shat (a \ x) (\sigma \concat \sigmaover \concat \lrangles{v})$ $=$\\
$(\lambda \sigma_{x} . \  \iotabot (
				(\hover \sigma_{x}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{x})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{x}))_{\dbot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$((a \ x)(\hhat (\sigma \concat \sigmaover \concat \lrangles{v})))$ $=$\\
$(\lambda \sigma_{x} . \  \iotabot (
				(\hover \sigma_{x}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{x})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{x}))_{\dbot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ 
$(\lambda \sigma. \ \iotabot \ 
		head_{C}\sigma \concat \lrangles{x})(\sigma \concat \lrangles{v})$ $=$\\
$(\lambda \sigma_{x} . \ \iotabot (
				(\hover \sigma_{x}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{x})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{x}))_{\dbot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$(\iotabot (\sigma \concat \lrangles{x}))$ $=$\\
$\iotabot (\sigma \concat \sigmaover \concat \lrangles{x})$ $=$\\
$\iotabot (head_{C'}(\sigma \concat \sigmaover \concat \lrangles{v}) \concat \lrangles{x})$ $=$
$a' \ x \ (\sigma \concat \sigmaover \concat \lrangles{v})$\\

\item S\'i $\kappa \neq \iota$,\\

$(\semBrcks{\pi,\iota:\deltavar}(\hhat,\shat)
([ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]))\kappa$ $=$
$\semBrcks{\pi,\iota:\deltavar}(\hhat,\shat)(\semBrcks{\pi}(\hover,\sover)\eta) \kappa$\\

$[ \ \semBrcks{\pi}(h',s')(\semBrcks{\pi}(h,s)\eta) \ | \ \iota:\lrangles{a',e'} \ ] \kappa$ $=$
$\semBrcks{\pi}(h',s')(\semBrcks{\pi}(h,s)\eta)\kappa$\\

para probar esto vamos a utilizar que $\semBrcks{\pi}$ es funtor como ya hemos hecho
para el caso de la abstracci\'on lambda. Es decir, deber\'iamos probar que 
$(\hover \circ \hhat,\shat \circ \sover) = (h \circ h',s' \circ s)$. Supongamos
$f : C \rightarrow C_\bot$\\

$(\hover \circ \hhat) (\sigma \concat \sigmaover \concat \lrangles{v})$ $=$
$\hover (\hhat (\sigma \concat \sigmaover \concat \lrangles{v}))$ $=$
$\hover (\sigma \concat \lrangles{v})$ $=$ $\sigma$\\

$(h \circ h') (\sigma \concat \sigmaover \concat \lrangles{v})$ $=$
$h (h' (\sigma \concat \sigmaover \concat \lrangles{v}))$ $=$
$h (\sigma \concat \sigmaover)$ $=$ $\sigma$\\

para la segunda funci\'on de la flecha, supongamos adem\'as 
$f(\hover(\hhat (\sigma \concat \sigmaover \concat \lrangles{v}))) = \iota \sigmatil$ y empecemos
notando que \\
$f(\hover(\hhat (\sigma \concat \sigmaover \concat \lrangles{v})))$
$=$ $f(h(h'(\sigma \concat \sigmaover \concat \lrangles{v})))$ $=$
$f(h(\sigma \concat \sigmaover))$\\

$(\shat \circ \sover) \ f \ (\sigma \concat \sigmaover \concat \lrangles{v})$ $=$
$\shat (\sover \ f) \ (\sigma \concat \sigmaover \concat \lrangles{v})$ $=$\\
$(\lambda \sigma_{v} . \
				(\hover \sigma_{v}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{v})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$(\sover \ f (\hhat (\sigma \concat \sigmaover \concat \lrangles{v})))$ $=$\\
$(\lambda \sigma_{v} . \
				(\hover \sigma_{v}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{v})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$((\lambda \sigma . \ \sigma \concat \lrangles{v})_{\bot} 
	(f (\hover (\hhat (\sigma \concat \sigmaover \concat \lrangles{v}))))$ $=$\\
$(\lambda \sigma_{v} . \
				(\hover \sigma_{v}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{v})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \
$((\lambda \sigma . \ \sigma \concat \lrangles{v})_{\bot} (\iotabot \sigmatil))$ $=$\\
$(\lambda \sigma_{v} . \
				(\hover \sigma_{v}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{v})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \  \ \ \ \
  \ \ \ \ \ \ \ \ \ \ \ \ \
$(\iotabot (\sigmatil \concat \lrangles{v}))$ $=$\\
$\iotabot (\sigmatil \concat \sigmaover \concat \lrangles{v})$\\

$(s' \circ s) \ f \ (\sigma \concat \sigmaover \concat \lrangles{v})$ $=$
$(s' (s \ f) \ (\sigma \concat \sigmaover \concat \lrangles{v})$ $=$\\
$(\lambda \sigma . \ \sigma \concat \lrangles{v})_{\bot} 
		((s \ f) (h'(\sigma \concat \sigmaover \concat \lrangles{v})))$ $=$\\
$(\lambda \sigma . \ \sigma \concat \lrangles{v})_{\bot}
((\lambda \sigma . \ \sigma \concat \sigmaover)_{\bot} (f \ (h (\sigma \concat \sigmaover))))$ $=$\\
$(\lambda \sigma . \ \sigma \concat \lrangles{v})_{\bot} 
		(\iotabot (\sigmatil \concat \sigmaover))$ $=$
$\iotabot (\sigmatil \concat \sigmaover \concat \lrangles{v})$\\

Finalmente, con la igualdad entre estas flechas que acabamos de probar, hemos completado
la prueba de naturalidad para el comando $\cnew \deltavar$ y adem\'as hemos completado
la prueba de naturalidad para nuestro lenguaje $\Alike$.
\end{itemize}
\end{itemize}
\end{itemize}
\end{proof}
