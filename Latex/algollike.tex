\chapter{Lenguajes Algol-like}
\label{chap:algollike}

En el cap\'itulo anterior hicimos dos cosas relevantes 
para este cap\'itlo, la primera fue definir la gram\'atica
abstracta de un lenguaje, la cual va a ser exactamente la
misma, segundo fue definir los tipos necesarios para este 
lenguaje. \\

En este cap\'itulo vamos a darle sem\'antica al lenguaje
que antes mencion\'abamos, la idea es que este lenguaje 
pertenece a la clase de lenguajes Algol-like, estos combinan
aspectos funcionales con imperativos y se basan en evaluaci\'on
normal. Una propiedad importante de este tipo de lenguajes es
la forma en la que se eval\'ua la aplicaci\'on de procedimientos
en un programa, lo que sucede es que la evaluaci\'on del programa
ocurre en dos partes, en la primera se reduce el programa hasta que
la aplicaci\'on del procedimiento desaparece quedando de esta manera 
la parte imperativa por evaluar y que es exactamente la segunda parte.
En resumen, primero se reducen las aplicaciones del calculo lambda
del lenguaje y luego se ejecuta la parte imperativa. Otra propiedad 
importante es la de stack discipline, la cual veremos que con 
algunas pocas modificaciones de nuestra sem\'antica podemos capturar
o no.\\

\noindent
\mnote{ Creo deber\'ia de estudiar un poco Essence of algol para contar
cosas un poco mas interesantes.
 }\\

Presentamos de nuevo la gram\'atica de nuestro lenguaje,\\

\noindent
$\lrangles{Phrase} ::=$ $\lrangles{PBool}$ $|$ $\lrangles{PInt}$ $|$ $\lrangles{PReal}$ \\
\indent \indent \indent $|$ 
$\odot \lrangles{Phrase}$ $|$ $\lrangles{Phrase} \otimes \lrangles{Phrase} $ \\ 
\indent \indent \indent $|$ 
$\assig{\lrangles{Phrase}}{\lrangles{Phrase}}$ $|$ $\cskip$ $|$ $\seq{\lrangles{Phrase}}{\lrangles{Phrase}}$ \\ 
\indent \indent \indent $|$ 
$\cifthenelse{\lrangles{Phrase}}{\lrangles{Phrase}}{\lrangles{Phrase}}$ \\ 
\indent \indent \indent $|$ 
$\cwhiledo{\lrangles{Phrase}}{\lrangles{Phrase}}$ \\ 
\indent \indent \indent $|$ 
$\newdeltavar{\lrangles{Id}}{\lrangles{Phrase}}{\lrangles{Phrase}}$ \\ 
\indent \indent \indent $|$ 
$\lrangles{Id}$ $|$ $\lrangles{Phrase}\lrangles{Phrase}$ \\
\indent \indent \indent $|$ 
$\clambda{\lrangles{Id}}{\theta}{\lrangles{Phrase}} $ \\
\indent \indent \indent $|$ 
$\rec{\lrangles{Phrase}}$
\\

donde $\delta \in \lrangles{Data \ types}$, $\odot \in \{-, \neg\}$ y 
$\otimes \in \{+,-,*,/,\div,\rem,\wedge,\vee,\Rightarrow,\Leftrightarrow, =,\neq,<,>,\leq,\geq\}$\\

En conclusi\'on, para definir la sem\'antica de este lenguaje vamos 
a proceder de la siguiente manera, primero vamos a definir una categor\'ia
de contexto, una vez con esta definida vamos a darle sem\'antica a las frases
mas simples de nuestro lenguaje, como pueden ser los operadores unarios y binarios
as\'i como algunos comandos simples y dejando para el final la definici\'on
de la declaraci\'on de variables imperativas, es interesante que en la 
b\'usqueda de dos sem\'anticas distintas, una que exprese stack discipline
y otra que no, lo \'unico que necesitamos es cambiar la sem\'antica \'esta.

\section{Categor\'ias}

En el cap\'itulo anterior introducimos tres categor\'ias importantes que
nos hac\'ian falta para determinar la sem\'antica de los tipos, en su
momento no terminamos de resolver concretamente varias cuestiones de la
definici\'on, empecemos entonces repasando estas categor\'ias y resolviendo
los detalles que hayan quedado libres anteriormente. \\
Sobre la categor\'ia de los tipos no hay mucho que agregar pero veremos que
la vamos a necesitar para definir otra categor\'ia mas de la cual hasta el
momento no hemos mencionado nada, repasemos entonces la definici\'on de la
categor\'ia $\C$ de "conjuntos con cierta forma". En particular desambiguemos 
a que nos referimos con esto ultimo y comentemos el fin de esta categor\'ia.\\

Lo mejor tal vez sea comenzar explicando el fin de la categor\'ia $\C$, antes
coment\'abamos la necesidad de expresar stack discipline, para hacer este
trabajo es que necesitamos de esta categor\'ia, ac\'a la idea sera que los
objetos de $\C$ sean lo suficientemente generales para representar un secuencia
de valores, pero que ademas, este relacionada con otras de manera de poder
expandir o contraer la secuencia. Si pensamos entonces que una secuencia 
representara un estado, de la evaluaci\'on de nuestro programa, expandir o
contraer la secuencia representara declarar una variable nueva o perder el
alcance de una variable, respectivamente.\\

Definamos los objetos de $\C$, un objeto $C$ sera un conjunto de secuencias 
pertenecientes a $S_1 \times \ldots \times S_n$, con $0 \leq n$ y $S_i$ conjunto, 
luego entonces, diremos que $C$ tiene forma $<S_1,\ldots,S_n>$. Por otro lado
la definici\'on de las flechas las dejamos para mas adelante cuando definamos 
la sem\'antica del la declaraci\'on de variables imperativas ya que, en parte,
variando la definici\'on de las flechas obtenemos stack discipline o no.\\

Definamos ahora la categor\'ia de los contextos, cuando nos referimos a contextos
pensamos en los que definimos en el cap\'itulo anterior la primera vez que definimos
inferencia de tipos. Estos ser\'an los objetos de nuestra categor\'ia, analicemos
como ser\'an las flechas, para esto vamos a tener que definir una relaci\'on
entre dos contextos, sean $\pi$ y $\pi'$ dos contextos cualquiera, decimos que 
$\pi \leq \pi'$ cuando $dom(\pi)$ $=$ $dom(\pi')$ y $\forall \iota \in dom(\pi)$ 
$\pi \iota \leq \pi' \iota$. Ahora estamos en condiciones de definir la 
categor\'ia de contextos que simbolizaremos con $\Pi$,\\

\noindent 
$\Pi_0$ $=$ $\{\pi \ | \ \pi \ \in \lrangles{Context} \}$\\
$\Pi_1$ $=$ $\{\pi \rTo \pi' \ | \ \pi,\pi' \ \in \lrangles{Context} \wedge \pi \leq \pi' \}$\\

Entonces, como pasaba con la categor\'ia de los tipos que defin\'iamos un funtor
$\semBrcks{ \ } : \Theta \rTo \DC$, ahora vamos a definir un funtor igual pero
$\semBrcks{ \ } : \Pi \rTo \DC$. Este funtor nos va a permitir acomodar el environment
cada vez que se declaren varibles. Tomemos $C$, $C'$ objetos de $\C$ y $(h,s): C \rTo C'$
flecha en $\C$, luego\\

\noindent
$\semBrcks{\pi}C$ $=$ $\prod\limits_{\iota \in dom(\pi)} \semBrcks{\pi \iota}C$\\
$\semBrcks{\pi}(h,s)$ $:$ $\semBrcks{\pi}C \rTo \semBrcks{\pi'}C'$\\

\noindent
Para definir como act\'ua el funtor para las flechas vamos a tomar un $\eta$ $:$ $\semBrcks{\pi}C$
cualquiera, luego\\

\noindent
$\semBrcks{\pi}(h,s)\eta$ $:$ $\semBrcks{\pi}C'$\\

\noindent
y entonces ahora definimos punto a punto para cualquier $\iota$\\

\noindent
$\semBrcks{\pi}(h,s)\eta\iota$ $=$ $\semBrcks{\pi \iota}(h,s)(\eta\iota)$

\section{Sem\'antica}

Ha llegado el momento de definir la sem\'antica de las frases de nuestro lenguaje,
para comenzar hay que aclarar que en realidad la sem\'antica no sera sobre
las frases, si no sobre los juicios de tipado, es decir que para evaluar una frase
esta tiene que estar correctamente tipada. Antes vimos que tanto para los tipos
como para los contexto estos se correspond\'ian mediante un funtor $\semBrcks{ \ }$
con objeto de la categor\'ia $\DC$, los cuales eran funtores. Ahora veremos que
la sem\'antica de un juicio de tipado sera una transformaci\'on natural en $\DC$,
es decir una flecha, entre un funtor $\semBrcks{ \ }$ aplicado a un contexto y
$\semBrcks{ \ }$ aplicado a un tipo. Formalmente, sean $e$ una frase del lenguaje
$\theta$ un tipo, $\pi$ un contexto y $\pi \vdash e : \theta$ un juicio de tipado, 
luego\\

\noindent
$\semBrcks{ \pi \vdash e : \theta }$ $:$ $\semBrcks{\pi} \rTo \semBrcks{\theta}$\\

\noindent
y cuya definici\'on para las distintas frases del lenguaje veremos a continuaci\'on.

\subsection{Constantes}

$\semBrcks{ \pi \vdash \true : \boolexp }C\eta\sigma$ $=$ $\iotabot true$\\

\noindent
$\semBrcks{ \pi \vdash \false : \boolexp }C\eta\sigma$ $=$ $\iotabot false$\\

\noindent
$\semBrcks{ \pi \vdash i : \intexp }C\eta\sigma$ $=$ $\iotabot i$\\

\noindent
$\semBrcks{ \pi \vdash r : \realexp }C\eta\sigma$ $=$ $\iotabot r$\\

\subsection{Operadores unarios}

$\semBrcks{ \pi \vdash \neg b : \boolexp }C\eta\sigma$ 
$=$ 
$(\lambda b . \iotabot \neg b)_{\dbot}\semBrcks{\pi \vdash b : \boolexp}C\eta\sigma$\\

\noindent
$\semBrcks{ \pi \vdash -n : \deltaexp }C\eta\sigma$ 
$=$ 
$(\lambda n . \iotabot -n)_{\dbot}\semBrcks{\pi \vdash n : \deltaexp}C\eta\sigma$\\

\noindent
con $\delta \in \{ \intt,\realt \}$

\subsection{Operadores binarios}

$\semBrcks{ \pi \vdash b \otimes b' : \boolexp }C\eta\sigma$ 
$=$ \\
\indent
$(\lambda b . (\lambda b' . \iotabot (b \otimes b'))_{\dbot}
\semBrcks{\pi \vdash b' : \boolexp}C\eta\sigma)_{\dbot}
\semBrcks{\pi \vdash b : \boolexp}C\eta\sigma$\\

con $\otimes \in \{ \wedge,\vee,\Rightarrow,\Leftrightarrow \}$\\

\noindent
$\semBrcks{ \pi \vdash i \odot i' : \intexp }C\eta\sigma$ 
$=$ \\
\indent
$(\lambda i . (\lambda i' . \iotabot (i \odot i'))_{\dbot}
\semBrcks{\pi \vdash i' : \intexp}C\eta\sigma)_{\dbot}
\semBrcks{\pi \vdash i : \intexp}C\eta\sigma$\\

con $\odot \in \{ \div,\rem \}$\\

\noindent
$\semBrcks{ \pi \vdash r / r' : \realexp }C\eta\sigma$ 
$=$ \\
\indent
$(\lambda r . (\lambda r' . \iotabot (r / r'))_{\dbot}
\semBrcks{\pi \vdash r' : \realexp}C\eta\sigma)_{\dbot}
\semBrcks{\pi \vdash r : \realexp}C\eta\sigma$\\

\noindent
$\semBrcks{ \pi \vdash i \ominus i' : \deltaexp }C\eta\sigma$ 
$=$ \\
\indent
$(\lambda i . (\lambda i' . \iotabot (i \ominus i'))_{\dbot}
\semBrcks{\pi \vdash i' : \deltaexp}C\eta\sigma)_{\dbot}
\semBrcks{\pi \vdash i : \deltaexp}C\eta\sigma$\\

con $\odot \in \{ +,-,* \}$, $\delta \in \{\intt,\realt\}$\\

\noindent
$\semBrcks{ \pi \vdash e \oplus e' : \boolexp }C\eta\sigma$ 
$=$ \\
\indent
$(\lambda e . (\lambda e' . \iotabot (e \oplus e'))_{\dbot}
\semBrcks{\pi \vdash e' : \theta}C\eta\sigma)_{\dbot}
\semBrcks{\pi \vdash e : \theta}C\eta\sigma$\\

con $\oplus \in \{ =,\neq,\leq,\geq,<,> \}$, $\theta \in \{\intexp,\realexp,\boolexp\}$\\

\subsection{Calculo lambda}

$\semBrcks{ \pi \vdash \iota : \theta }C\eta$ $=$ $\eta\iota$

cuando $\pi$ contiene el par $\iota:\theta$\\

\noindent
$\semBrcks{ \pi \vdash ee' : \theta' }C\eta$ 
$=$ 
$\semBrcks{ \pi \vdash e : \theta \rightarrow \theta' }C\eta\langle\rangle
(\semBrcks{ \pi \vdash e' : \theta }C\eta)$\\

\noindent
$\semBrcks{ \pi \vdash \lambda \iota_{\theta} . e : \theta \rightarrow \theta' }C \eta C'z$ 
$=$ 
$\semBrcks{ \pi \vdash e : \theta' }(C \concat C')
[\semBrcks{(\pi)}(C \rTo C')\eta | \iota:z]$\\

\noindent
$\semBrcks{ \pi \vdash \rec e : \theta \rightarrow \theta' }C \eta$ 
$=$ 
$\Y_{\semBrcks{\theta}C} 
(\semBrcks{ \pi \vdash e : \theta \rightarrow \theta}C\eta\langle\rangle)$\\

\section{Comandos}

$\semBrcks{ \pi \vdash \cskip : \commt }C\eta\sigma$ 
$=$ $\iotabot sigma$\\

\noindent
$\semBrcks{ \pi \vdash \cifthenelse{b}{e}{e'}: \theta }C\eta\sigma$ 
$=$ \\
\indent
$(\lambda b . if \ b $ $then \semBrcks{ \pi \vdash e : \theta}C\eta\sigma$\\
\indent \indent \indent \ \ 
$else \semBrcks{ \pi \vdash e' : \theta}C\eta\sigma)_{\dbot}$\\
\indent \indent \indent \indent
$(\semBrcks{ \pi \vdash b : \boolexp}C\eta\sigma)$\\

\noindent
$\semBrcks{ \pi \vdash \assig{e}{e'} : \commt }C\eta\sigma$ 
$=$ 
$(\lambda x . \semBrcks{\pi \vdash e : \deltaacc}C\eta x)_{\dbot}
(\semBrcks{ \pi \vdash e : \deltaexp }C\eta\sigma)$\\

\noindent
$\semBrcks{ \pi \vdash \seq{e}{e'} : \commt }C\eta\sigma$ 
$=$ 
$(\lambda \sigmahat . \semBrcks{\pi \vdash e : \commt}C\eta\sigmahat)_{\dbot}
(\semBrcks{ \pi \vdash e : \commt}C\eta\sigma)$\\

\noindent
$\semBrcks{ \pi \vdash \cwhiledo{b}{e'} : \commt }C\eta$ 
$=$ \\
\indent 
$\Y_{\semBrcks{\commt}C}$ $(\lambda c . \lambda \sigma .$\\
\indent \indent \indent
$(\lambda b . if \ b $ $then \ c_{\dbot} \semBrcks{\pi \vdash e : \commt}C\eta\sigma$\\
\indent \indent \indent \indent \indent \ \ 
$else \ \iotabot \sigma)_{\dbot}$\\
\indent \indent \indent \indent \indent \indent
$(\semBrcks{ \pi \vdash b : \boolexp}C\eta\sigma))$\\

\section{Comando para declarar variable imperativa}









