\chapter{Lenguaje Algol-like}
\label{chap:algollike}

Al final del cap\'itulo anterior terminamos con el estudio
del lenguaje $\lambdaleq$, este era un lenguaje funcional con subtipado.
En este cap\'itulo vamos a tomar a $\lambdaleq$ y vamos a agregar
aspectos imperativos, este nuevo lenguaje lo llamaremos $\Alike$.

Este nuevo lenguaje que vamos a estudiar pertenecer\'a a la clase
de lenguaje Algol-like estos combinan
aspectos funcionales con imperativos y se basan en evaluaci\'on
normal. Una propiedad importante de este tipo de lenguajes es
la forma en la que se eval\'ua la aplicaci\'on de procedimientos
en un programa, lo que sucede es que la evaluaci\'on del programa
ocurre en dos etapas, en la primera se reduce el programa hasta que
la aplicaci\'on del procedimiento desaparece quedando de esta manera 
la parte imperativa por evaluar, que es lo que se realiza en una segunda
etapa.

A continuaci\'on presentamos los cinco principio que (ref de the essence of algol)
cree que captura la esencia de los lenguajes Algol-like.

\begin{enumerate}
\item Algol-like se obtiene de un lenguaje imperativo simple imponiendo un
sistema para los procedimientos basado en el calculo lambda "fully typed" y utilizando
call-by-name. Donde con "fully typed" se refiere que todos los errores de tipo deben ser
errores sint\'acticos.

\item Existe dos clases de tipos: Los $\textit{Data Types}$ que representaran los 
conjuntos de valores para expresiones y variables y los $\textit{Phrase Types}$ que
representaran los conjuntos de valores para las frases e identificadores.

\item El orden de evaluaci\'on para las partes de una expresi\'on y su
conversi\'on impl\'icita deber\'ia estar indeterminada, pero el significado
del lenguaje es independiente de la indeterminaci\'on.

\item La definici\'on de procedimientos, recursiones, expresiones condicionales
pueden ser de cualquier $\textit{Phrase Types}$.

\item El lenguaje contiene stack discipline y su definici\'on debe hacer esta disciplina
obvia.

\end{enumerate}

Sobre este ultimo punto vamos a presentar una variante de sem\'antica para el lenguaje
en la cual no tenemos stack discipline. Lo interesante es que lo vamos a lograr cambiando
realmente muy poco sobre las ecuaciones sem\'anticas y los dominios originales que
si contemplan stack discipline.

\section{Sintaxis de $\Alike$}

Como ya mencionamos $\Alike$ sera una extensi\'on de $\lambdaleq$, agregando las
construcciones para un lenguaje imperativo simple. Pero antes de hacer esta extensi\'on
hay algo a acomodar en cuantos a los lenguajes de donde se extiende $\Alike$ y
esta en el hecho de que el lenguaje de tipos de $\lambdaleq$ es demasiado simple debemos
extenderlo seg\'un el punto dos de los principios de algol.

Comencemos entonces acomodando nuestro sistema de tipos, empecemos tomando los tipos
$\boolt$, $\intt$ y $\realt$ de $\lrangles{Type}$ y separándolos por un lado, para
introducir la gram\'atica de los  $\textit{Data Types}$.

\setlength{\grammarindent}{6em}
\begin{grammar}

<Data Types> ::= $\boolt$ | $\intt$ | $\realt$

\end{grammar}

Por otro lado en $\lrangles{Type}$ tenemos el operador funcional $\rightarrow$, este vamos 
a moverlo a nuestra otra clase de tipos $\textit{Phrase Types}$ y vamos a agregar las
construcciones de tipos que representan los valores para los comandos, aceptadores, variables y 
expresiones, este ultimo tipo se lo puede considerar como el nuevo tipo que 
representa a los tipos como los ten\'iamos antes, es decir, si una frase antes
ten\'ia tipo $\intt$ ahora tendr\'a tipo $\intt\textbf{exp}$(resi\'on). Dicho lo
anterior no hay duda sobre la utilidad de $\deltaexp$ como tipo, hagamos un repaso
de los dem\'as tipos que vamos a introducir, el tipo de los comandos no ser\'a
otra cosa que el representante de las frases de la parte imperativa de
nuestro lenguaje, el tipo de las variables encapsular\'a las dos posibles utilizaciones
de un identificador de variable, es decir, ya sea como valor o como almacenamiento,
para este primero es que tenemos el tipo de las expresiones y para el segundo es
donde aparece el tipo de los aceptadores, este b\'asicamente se encarga de 
representar a un identificador de variables como un almac\'en de valores.

\setlength{\grammarindent}{8em}
\begin{grammar}

<Phrase Types> ::= $\commt$
\alt $\boolacc$ \ | $\intacc$ \ | $\realacc$
\alt $\boolexp$ | $\intexp$ | $\realexp$
\alt $\boolvar$ \ | $\intvar$ \ | $\realvar$
\alt <Phrase Types> $\rightarrow$ <Phrase Types>

\end{grammar}

Ahora que hemos actualizado el lenguaje de tipos necesario para $\Alike$, presentemos
la gram\'atica, como mencionamos anteriormente este lenguaje va a ser una extensi\'on de $\lambdaleq$, agregando los construcciones para un lenguaje imperativo simple. Estas construcciones 
ser\'an los comandos para la declaraci\'on de variables ($\cnew \deltavar$), 
asignaci\'on($\cassig$), comando neutro ($\cskip$), concatenaci\'on de comandos ($\concatdots$)
y un comando para iteraciones ($\cwhile$).

\setlength{\grammarindent}{6em}
\begin{grammar}

<Phrase> ::= <PBool> | <PInt> | <PReal>
\alt $\odot$ <Phrase> | <Phrase> $\circledcirc$ <Phrase>
\alt \textbf{if} <Phrase> \textbf{then} <Phrase> \textbf{else} <Phrase>
\alt <Id> 
\alt <Phrase> <Phrase>
\alt $\lambda$ <Id>$_\theta$ . <Phrase>
\alt \textbf{rec} <Phrase>
\alt $\cnewv$ $\deltavar$ <Id> $\cassig$ <Phrase> $\cin$ <Phrase>
\alt <Phrase> $\cassig$ <Phrase> | $\cskip$ | <Phrase> $\concatdots$ <Phrase>
\alt $\cwhile$ <Phrase> $\cdo$ <Phrase>


<PBool> ::= True | False

<PNat>  ::= 0 | 1 | 2 | ...

<PInt>  ::= ... | -2 | -1 | <PNat> 

<PReal> ::= <PNat>.\{<PNat>\}+ 
\alt - <PNat>.\{<PNat>\}+

\end{grammar}

\noindent
donde \ 

$\lrangles{\textit{Id}}$ es un conjunto numerable.

$\theta \in \phraseTypes$ \

$\odot \in \{-, \neg\}$ y \

$\circledcirc \in \{+,-,*,/,\div,\rem,\wedge,\vee,\Rightarrow,\Leftrightarrow, =,\neq,<,>,\leq,\geq\}$

\section{Reglas de inferencia para $\Alike$}

La modificaci\'on de los tipos nos obliga a actualizar las reglas de inferencia 
concretas del subtipado, ya que ahora como mencion\'abamos antes el tipo de una
expresi\'on entera no sera $\intt$ si no $\intexp$. Pero antes de acomodar esto
definamos una nueva relaci\'on de orden para los tipos de $\dataTypes$, en esta
nueva relaci\'on vamos a retirar $\boolt \leq \intt$, cuyo fin en $\lambdaleq$
era tener casos interesantes de transitividad entre los tipos, luego nos quedara 
la siguiente relaci\'on entre los tipos,

\begin{diagram}[loose,height=2em]
   \realt & \\
   \dLine & \\
   \intt  & \boolt
\end{diagram}

Ahora utilizando este diagrama, que b\'asicamente nos dice que $\intt$ es subtipo
de $\realt$ y que no ocurre nada mas interesante, presentamos la relaci\'on de los
tipos de $\phraseTypes$,

\begin{diagram}[loose,height=2em,width=3em]
   \intacc & & \realexp  & \\
   \dLine & \rdLine(2,4) \ldLine(2,4) & \dLine   & \\
   \realacc  & & \intexp & &    \boolacc    &      &    \boolexp  & \\
   \dLine   & & \dLine   & &        &    \rdLine(1,2)  \ldLine(1,2)     &     & \\
   \realvar  & & \intvar & &        &       \boolvar   &            & \commt
\end{diagram}

Expliquemos un poco que estamos viendo, por un lado respetando la idea de que
$\intt$ es ahora $\intexp$ y $\realt$ es $\realexp$, entonces vamos a tener
$\intexp \leq \realexp$, esta relaci\'on se da vuelta si pensamos en el tipo
de los aceptadores, ya que si podemos almacenaren un valor de 
tipo $\realexp$ entonces podemos almacenar un valor de tipo $\intexp$
y entonces tenemos $\realacc \leq \intacc$. Finalmente 
si pensamos que una variable puede ser usada tanto como valor o contenedor,
vamos a tener que, tomando $\delta \in \dataTypes$, $\deltavar \leq \deltaexp$ y
$\deltavar \leq \deltaacc$.

Por ultimo podemos prestar especial atenci\'on al supremo que aparece
entre $\realvar$ e $\intvar$, el cual podr\'ia determinar un tipo particular
de variable que vista como aceptador tiene tipo $\intacc$ y vista como 
valor tiene tipo $\realexp$. De hecho, si nuestro lenguaje soportara el 
operador de tipos intersecci\'on ($\&$), podr\'iamos definir a
este tipo particular de variable como $\intacc$ $\&$ $\realexp$ y mas aun, 
podr\'iamos definir a nuestro tipo actual $\deltavar$ como $\deltaacc$ $\&$ $\deltaexp$.\\

Dicho esto escribamos las nuevas reglas de tipado para estas relaciones nuevas
y aprovechemos para actualizar nuestras metavaribles en relaci\'on a nuestros
nuevos tipos.

\begin{center}
\begin{tabular}{ l r }
	$\theta$ $\phraseTypes$ & $\delta$ $\dataTypes$
\end{tabular}
\end{center}

\noindent
$\texttt{Ty Rule:}$ intexpTorealexp.

\begin{center}
\AxiomC{}
\UnaryInfC{$\intexp \leq \realexp$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ realaccTointacc.

\begin{center}
\AxiomC{}
\UnaryInfC{$\realacc \leq \intacc$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ $\delta$varTo$\delta$exp.

\begin{center}
\AxiomC{}
\UnaryInfC{$\deltavar \leq \deltaexp$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ $\delta$varTo$\delta$acc.

\begin{center}
\AxiomC{}
\UnaryInfC{$\deltavar \leq \deltaacc$}
\DisplayProof
\end{center}

Adem\'as de estas reglas de inferencia para el subtipado, nos van a hacer
falta actualizar las reglas de inferencia de lambda leq con los tipos correspondientes
del lenguaje $\Alike$ y luego faltara tambi\'en agregar reglas para los juicios de 
tipado de las nuevas frases. Pero antes vamos a necesitar definir el nuevo lenguaje
de los contextos, como ha venido ocurriendo, esto ser\'a actualizar los tipos
viejos por los nuevos.

\begin{definition}\label{alike:context}

Un contexto estar\'a definido por la siguiente gram\'atica,\

\begin{grammar}

<Context> ::= $\varnothing$ | <Context>,<Id>:<Phrase Types>

\end{grammar}

tal que dado cualquier contexto $\iota_0:\theta_0,\ldots,\iota_n:\theta_n$, los
identificadores $\iota_0,\ldots,\iota_n$ son todos distintos.

\end{definition}

Ahora s\'i, reescribamos las reglas de $\lambdaleq$ con los nuevos tipos, b\'asicamente
lo que vamos a hacer es cambiar un tipo $\delta$ por $\deltaexp$,

\

\noindent
$\texttt{Ty Rule:}$ Constantes.

\begin{center}
\AxiomC{}
\UnaryInfC{$\pi \vdash b : \boolexp$}
\DisplayProof
\quad
\AxiomC{}
\UnaryInfC{$\pi \vdash i : \intexp$}
\DisplayProof
\quad
\AxiomC{}
\UnaryInfC{$\pi \vdash r : \realexp$}
\DisplayProof
\end{center}

\newpage

\noindent
$\texttt{Ty Rule:}$ Operadores b\'asicos.

\begin{center}
\AxiomC{$\pi \vdash e : \intexp$}
\UnaryInfC{$\pi \vdash -e : \intexp$}
\DisplayProof
\quad
\AxiomC{$\pi \vdash e : \realexp$}
\UnaryInfC{$\pi \vdash -e : \realexp$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{$\pi \vdash e : \boolexp$}
\UnaryInfC{$\pi \vdash \neg e : \boolexp$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{$\pi \vdash e : \intexp$}
\AxiomC{$\pi \vdash e' : \intexp$}
\RightLabel{$\otimes \in \{+,-,*,/\ , \textbf{rem}\}$}
\BinaryInfC{$\pi \vdash e \otimes e' : \intexp$}
\DisplayProof

\quad

\quad

\AxiomC{$\pi \vdash e : \realexp$}
\AxiomC{$\pi \vdash e' : \realexp$}
\RightLabel{$\otimes \in \{+,-,*\}$}
\BinaryInfC{$\pi \vdash e \otimes e' : \realexp$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{$\pi \vdash e : \boolexp$}
\AxiomC{$\pi \vdash e' : \boolexp$}
\RightLabel{$\owedge \in \{\wedge,\vee,\Rightarrow,\Leftrightarrow\}$}
\BinaryInfC{$\pi \vdash e \owedge e' : \boolexp$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{$\pi \vdash e : \delta$}
\AxiomC{$\pi \vdash e' : \delta$}
\RightLabel{$\delta \in \{\intexp, \realexp \}, \olessthan \in \{<,>,\leq,\geq\}$}
\BinaryInfC{$\pi \vdash e \olessthan e' : \boolexp$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{$\pi \vdash e : \deltaexp$}
\AxiomC{$\pi \vdash e' : \deltaexp$}
\RightLabel{$\ominus \in \{=,\neq\}$}
\BinaryInfC{$\pi \vdash e \ominus e' : \boolexp$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ Aplicaci\'on.

\begin{center}
\AxiomC{$\pi \vdash e : \theta \rightarrow \theta'$}
\AxiomC{$\pi \vdash e': \theta$}
\BinaryInfC{$\pi \vdash ee' : \theta'$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ Operador de punto fijo.

\begin{center}
\AxiomC{$\pi \vdash e : \theta \rightarrow \theta$}
\UnaryInfC{$\pi \vdash \rec{e} : \theta$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ Identificador.

\begin{center}
\AxiomC{}
\RightLabel{$v:\theta \in \pi$}
\UnaryInfC{$\pi \vdash v : \theta$}
\DisplayProof
\end{center}

\noindent
$\texttt{Ty Rule:}$ Abstracci\'on lambda.

\begin{center}
\AxiomC{$\pi,\iota:\theta \vdash e : \theta'$}
\UnaryInfC{$\pi \vdash \clambda{\iota}{\theta}{e} : \theta \rightarrow \theta'$}
\DisplayProof
\end{center}

\newpage

\noindent
$\texttt{Ty Rule:}$ Expresi\'on condicional.

\begin{center}
\AxiomC{$\pi \vdash b  : \boolexp$}
\AxiomC{$\pi \vdash e  : \theta$}
\AxiomC{$\pi \vdash e' : \theta$}
\TrinaryInfC{$\pi \vdash \cifthenelse{b}{e}{e'} : \theta$}
\DisplayProof

\

con $\theta \in \{\deltavar,\deltaacc,\deltaexp,\commt\}$.\\
\end{center}


Hasta aqu\'i lo que hemos hecho es recompilar y actualizar las reglas de inferencia
para la parte aplicativa del lenguaje, ahora definamos las regla de los comandos 
$\cskip$, $\cwhile$ y $\concatdots$ que no presentan ninguna particularidad que valga 
la pena comentar y luego sigamos con las reglas $\cnew \ \deltavar$ y $\cassig$. Pero
antes notamos el hecho de que el juicio de tipado para la expresi\'on
condicional no es todo lo general que plantea el punto 4 del comienzo del capitulo,
la respuesta para esta decisi\'on se encuentra al momento de definir la ecuaci\'on
sem\'antica para este comando.

\

\noindent
$\texttt{Ty Rule:}$ $\cskip$.

\begin{center}
\AxiomC{}
\UnaryInfC{$\pi \vdash \cskip : \commt$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ $\cwhile$.

\begin{center}
\AxiomC{$\pi \vdash e : \boolexp$}
\AxiomC{$\pi \vdash e' : \commt$}
\BinaryInfC{$\pi \vdash \cwhiledo{e}{e'} : \commt$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ Composici\'on.

\begin{center}
\AxiomC{$\pi \vdash e  : \commt$}
\AxiomC{$\pi \vdash e' : \commt$}
\BinaryInfC{$\pi \vdash \cseq{e}{e'} : \commt$}
\DisplayProof
\end{center}

En la regla de inferencia para la declaraci\'on de variable, ocurre 
algo muy similar a lo que ocurre con la regla de la abstracci\'on lambda
en cuanto a que se extiende el contexto, la principal diferencia ser\'a
que solamente vamos a poder agregar el identificador con un phrase type "fijo",
donde con "fijo" nos referimos a que solamente un identificador podr\'a ser
de tipo $\deltavar$.

\

\noindent
$\texttt{Ty Rule:}$ Declaraci\'on de variable.

\begin{center}
\AxiomC{$\pi \vdash e  : \deltaexp$}
\AxiomC{$\pi,\iota:\deltavar \vdash e' : \commt$}
\BinaryInfC{$\pi \vdash \newdeltavar{\iota}{e}{e'} : \commt$}
\DisplayProof
\end{center}

Antes mencin\'abamos que el tipo $\deltavar$ encapsulaba de manera bien
separada la noci\'on de un identificador utilizado como contenedor de un
valor o utilizado como un valor en si mismo. En la regla de la asignaci\'on
se ve como para guardar un valor hace falta que la parte izquierda tenga
tipo $\deltaacc$, es decir el tipo $\deltavar$ visto como contenedor y
la parte derecha tenga tipo $\deltaexp$, que en el caso de ser un identificador
es el tipo $\deltavar$ visto como valor.

\

\noindent
$\texttt{Ty Rule:}$ Asignaci\'on.

\begin{center}
\AxiomC{$\pi \vdash e   : \deltaacc$}
\AxiomC{$\pi \vdash e'  : \deltaexp$}
\BinaryInfC{$\pi \vdash \assig{e}{e'} : \commt$}
\DisplayProof
\end{center}


\section{Sem\'antica para $\Alike$}

A nivel sint\'actico vimos que $\Alike$ esta compuesto por las frases
de $\lambdaleq$ mas frases que representan la parte imperativa, de hecho al 
presentar las reglas de inferencia para las frases de $\Alike$, las
reglas de la parte de $\lambdaleq$ sufrieron un \'unico cambio simple
en cuanto a los nombre de los tipos y pudimos aprovechar la definici\'on
completa. Ahora que vamos a dar la sem\'antica 
de $\Alike$ y no vamos a poder hacer algo similar con la sem\'antica, es decir aprovechar las
ecuaciones sem\'anticas que definimos para $\lambdaleq$, la raz\'on principal es
que el significado de nuestros tipos ya no ser\'a tan simple debido a que
nos aparecen cuestiones relacionadas con el stack discipline. \\

Adem\'as para definir las dos sem\'anticas que pretendemos para $\Alike$,
con y sin stack discipline, vamos a tener definiciones extras, una
para el juicio de tipado de la declaraci\'on de variables imperativas
y otra para la categor\'ia de estados de la parte imperativa. 
Lo interesante de notar sobre estas definiciones extras es que dadas todas las ecuaciones
sem\'anticas de nuestro lenguaje, con solo seleccionar una sola
ecuaci\'on vamos a decidir sobre el tipo de implementaci\'on en
relaci\'on al stack discipline.\\

Comencemos adaptando la categor\'ia de tipos $\Theta$, lo \'unico 
por hacer ser\'a cambiar la clase de tipos de $\lambdaleq$ por los de
$\Alike$.

\begin{definition}\label{algol:typescategory}
La categor\'ia de tipos, que nombraremos $\Theta$, se define como sigue\\

$\Theta_0$ $=$ $\{\theta \ | \ \theta \ \in \phraseTypes \}$\\
\indent
$\Theta_1(\theta,\theta')$ $=$ $\{\theta \rTo \theta' \ | \ \theta \leq \theta'\}$

\end{definition}

Sobre la categor\'ia de contextos no hay nada que cambiar, luego
lo que nos queda por actualizar es la categor\'ia $\CD$, esta 
en $\lambdaleq$ la hab\'iamos definido como la categor\'ia concreta
$\Dom$, la cuesti\'on es que ahora es que no nos alcanza solamente con esta y vamos a 
necesitar un enfoque bastante distinto debido a que la separaci\'on 
que existe entre el calculo lambda y la parte imperativa nos induce
una separac\'ion entre los ambientes y los estados. As\'i por ejemplo
sucede que $\semBrcks{\intexp}$ ya no ser\'a un $S_\intt$ que represente
el conjunto de enteros, si no que pasar\'a a ser una funci\'on de
estados en $S_\intt$.\\

Pero antes de continuar, definamos que ser\'a un estado en nuestra sem\'antica,
para el cual tendremos dos versiones, una versi\'on ser\'a un conjunto de valores 
pero con la particularidad de tener forma, donde aclarando un poco a que 
nos referimos con forma, es que si tom\'aramos un estado $(1,True)$ que 
pertenece a $\Z \times \B$, diremos que este estado tiene 
forma $\lrangles{\Z,\B}$. Para la otra versi\'on un estado ser\'a una funci\'on
de de identificadores en valores.

\begin{definition}\label{algol:disciplinestates}

Un estado ser\'a un elemento perteneciente a $S_1 \times \ldots \times S_n$, 
con $1 \leq n$ con $S_i$ conjuntos. Diremos adem\'as que este estado tiene
forma $\lrangles{S_1,\ldots,S_n}$\\

Adem\'as dados dos estados $\sigma$ y $\sigma'$, diremos que $\sigma$ extiende
a $\sigma'$ cuando la forma de $\sigma$ sea tramo inicial de la forma de $\sigma'$.

\end{definition}

Introduzcamos algunas funciones \'utiles que nos van a servir para
operar sobre los estados y las formas de los estados. Vamos a usar
$ \concat $ para definir la concatenaci\'on de estados y formas de estado,
adem\'as para operar sobre los estados vamos a tener tres funciones b\'asicas,
$head$, $tail$ y $last$. 

\begin{definition}\label{algol:statesfunctions}

Sea $\sigma$ un estado con forma $\alpha \concat \alpha'$ luego definimos
$head_\alpha \sigma$ y $tail_\alpha¿ \sigma$ como los \'unicos
estados tal que $head_\alpha \sigma \concat tail_\alpha¿ \sigma$ $=$ $\sigma$.\\

Adem\'as dado un estado $\sigma$ con forma $alpha \concat \lrangles{S}$, 
tenemos que $last_S \sigma$ sera el ultimo valor contenido en el estado $\sigma$.

\end{definition}

Hasta aqu\'i entonces hemos definido la primera versi\'on de estados, esta ser\'a la que
se corresponda con la categor\'ia de estados para la sem\'antica con stack discipline.
Pasemos a definir la segunda versi\'on, la cual se corresponder\'a entonces con
la categor\'ia de estados para la sem\'antica sin stack discipline. Como ya
mencionamos antes estos estados ahora ser\'an funciones de identificadores
en valores, en un sentido similar a como es un ambiente, la raz\'on principal
por la cual vamos a tener esta segunda versi\'on se basa en que vamos a querer
dejar de lado la idea de que los estados tengan forma y el problema que 
trae esto es que, justamente la forma es lo que nos permite actualizar o consultar
los valores de nuestro estado, por lo tanto necesitamos otro tipo
de estado con otro mecanismo para realizar esas acciones.
Para resolver esto usamos una idea similar a la propuesta en (referencia Reynolds Theories...)
para el lenguaje Iswim.

\begin{definition}\label{algol:states}

Un estado ser\'a un elemento perteneciente a 
$\bigcup\limits_{I \in \FinId} I \rightarrow S$

donde $\FinId$ ser\'a un conjunto de subconjuntos finitos de $\lrangles{Id}$ y
$S = S_\intt + S_\realt + S_\boolt$\\

A este conjunto de estados lo llamaremos $\Sigma$.\\

\end{definition}

Ahora con los estados definidos, vamos a dar las dos definiciones de
la categor\'ia de estados, una ser\'a la categor\'ia en la que b\'asicamente cada objeto ser\'a
un conjunto de estados con la misma forma y una flecha entre dos objetos
determinar\'a como contraer la forma de un objeto y como transformar un estado
con cierta forma en un estado mas grande. Y la otra categor\'ia tendr\'a
un solo objeto que agrupar\'a a todos los estados sin importar la forma y
cuya \'unica flecha ser\'a la identidad.

\begin{definition}\label{algol:disciplinestatecategory}
La categor\'ia de estados, que nombraremos $\C$, se define como sigue,\\

\indent
$\C_0$ $=$ $\{C$ $|$ $C$ es el conjunto de todos los estados con determinada forma$\}$\\
\indent
$\C_1(C,C')$ $=$ $\{C \rTo^{(h,s)} C'$ $|$ $C'$ extiende a $C\}$\\

donde \ $h: C' \rightarrow C$\\
\indent \indent \indent
	  $h = head_C$\\
\indent \indent \indent
	  $s: (C \rightarrow C_{\bot}) \rightarrow (C' \rightarrow C'_{\bot})$\\
\indent \indent \indent
	  $s \ c \ \sigmahat =$ 
	  	   $(\lambda \sigma. \ \sigma \concat (tail_{\overline{C}} \ \sigmahat))_{\bot}$
	  	   	$(c(h \ \sigmahat))$\\
\indent \indent \indent
	 $C' = C \concat \overline{C}$

\end{definition}

Notar que si tomamos un objeto $C$ de $\C$ podemos hablar de que este objeto
tiene cierta forma, b\'asicamente la forma de los estados que agrupa, luego
podemos hablar de que dado otro objeto $C'$, este extiende a $C$ y esta extensi\'on
se determina de la misma manera que para los estados. Adem\'as aprovechamos 
que podemos hablar acerca de que $C$ tiene forma, para hacer un abuso de 
notaci\'on en $head$ y $tail$.\\

Ahora definamos la segunda categor\'ia de estados que mencionamos anteriormente.

\begin{definition}\label{algol:statecategory}
La categor\'ia de estados, que nombraremos $\C$, se define como sigue,\\

\indent
$\C_0$ $=$ $\{\ \Sigma \ \}$\\

y cuya \'unica flecha es $(1_h,1_s) : \Sigma \rightarrow \Sigma$, tal que\\

$1_h : \Sigma \rightarrow \Sigma$\\
\indent
$1_h \sigma = \sigma$\\
\indent
$1_s: (\Sigma \rightarrow \Sigma_{\bot}) \rightarrow (\Sigma \rightarrow \Sigma_{\bot})$\\
\indent
$1_s \ c = c$

\end{definition}

Una aclaraci\'on importante es que, salvo aclaraci\'on, cuando hablemos de 
la categor\'ia $\C$ vamos a estar refiri\'endonos a cualquiera de las dos
que acabamos de definir. Dicho esto, estamos en condiciones de definir quien
ser\'a $\CD$, una idea inicial es pensar en la categor\'ia funtorial
$\Dom^\C$ como sugiere (ref Reynolds, Theories of programming... Cap. 19.), pero
parece existir un problema seg\'un se menciona en (ref Oles, Functor categories and 
store shapes, Chap. 11.) que tiene que ver con que $\Dom^\C$ parece no ser $\CCC$
a pesar de que $\Dom$ lo sea y hab\'iamos mencionado que \'ibamos a querer que
nuestra categor\'ia $\CD$ sea $\CCC$. En esta ultima referencia entonces se
plantea el uso de $\PDom$, luego $\CD$ nos queda como la categor\'ia funtorial $\PDom^\C$.\\

Para la definici\'on de las ecuaciones sem\'anticas primero vamos a tener
que acomodar la sem\'antica de nuestros tipos y contextos, antes ya mencionamos
que la representaci\'on que vamos a necesitar, por ejemplo, para el tipo $\intexp$
ya no ser\'a tan simple como antes. 

Notar que como nuestra categor\'ia $\CD$ es ahora una categor\'ia funtorial, 
vamos a tener que la sem\'antica de un objeto $\theta$ de $\Theta$ ser\'a un funtor,\\

$\semBrcks{\theta}$ $:$ $\C \rightarrow \PDom$\\

tal que aplicado a un objeto $C$, de $\C$ es,\\

$\semBrcks{\theta} C$ $:$ $\PDom$\\

y aplicado a una flecha $C \rTo^{(h,s)} C'$ es,\\

$\semBrcks{\theta} (h,s)$ $:$ $\semBrcks{\theta} C \rightarrow \semBrcks{\theta} C'$.\\

en general, el comportamiento de este funtor aplicado a una flecha ser\'a la traducci\'on del estado actual con forma $C$ a un estado extendido con forma $C'$. 

\noindent
Adem\'as, la sem\'antica de una flecha $\theta \rTo^{\leq} \theta'$ de $\Theta$ ser\'a
una transformaci\'on natural, indexada por objetos de $\C$,\\

$\semBrcks{\theta \rTo^{\leq} \theta'}C$ $:$ $\semBrcks{\theta}C \rightarrow \semBrcks{\theta'}C$.

\begin{definition}\label{algol:typesemfunctor}
Sea $\semBrcks{ \_ } : \Theta \rightarrow \CD$ un funtor, tal que\\

$\semBrcks{\deltaexp}_0 C$ $=$ $C \rightarrow (S_\delta)_\bot$\\ 
\indent
$\semBrcks{\deltaexp}_0 (h,s) \ e$ $=$ $e \circ h$\\
\

$\semBrcks{\commt}_0 C$ $=$ $C \rightarrow C_\bot$\\
\indent
$\semBrcks{\commt}_0 (h,s) \ c$ $=$ $s \ c$\\
\

$\semBrcks{\deltaacc}_0 C$ $=$ $S_\delta \rightarrow \semBrcks{\commt}C$\\
\indent
$\semBrcks{\deltaacc}_0 (h,s) \ a$ $=$ $s \circ a$\\
\

$\semBrcks{\deltavar}_0 C$ $=$ $\semBrcks{\deltaacc}C \times \semBrcks{\deltaexp}C$\\
\indent
$\semBrcks{\deltavar}_0 (h,s) \ (a,e)$ $=$ $( \semBrcks{\deltaacc}(h,s) \ a
										     , \semBrcks{\deltaexp}(h,s) \ e
										     )$\\
\

$\semBrcks{\theta \rightarrow \theta'}_0 C$ $=$ 
					$\Hom{\semBrcks{\theta}(C \concat \_)}{\semBrcks{\theta'}(C \concat \_)}$\\
\indent
$\semBrcks{\theta \rightarrow \theta'}_0 (h,s) \ f \ \widehat{C}$ $=$ 
														$f(\overline{C} \concat \widehat{C})$\\
\indent \indent donde $C \concat \overline{C} = C'$.\\
\

\indent
$\semBrcks{\intexp \leq \realexp}_1 C \ e$ $=$ $\J \circ e$\\
\

\indent
$\semBrcks{\realacc \leq \intacc}_1 C \ a$ $=$ $a \circ \J$\\
\

\indent
$\semBrcks{\deltavar \leq \deltaexp}_1 C \ (a,e)$ $=$ $e$\\
\

\indent
$\semBrcks{\deltavar \leq \deltaacc}_1 C \ (a,e)$ $=$ $a$\\
\

\indent
$\semBrcks{\theta \leq \theta}_1 C$ $=$ $1_{\semBrcks{\theta} C}$\\
\

\indent
$\semBrcks{\theta \leq \theta''}_1 C$ $=$ 
					$\semBrcks{\theta' \leq \theta''}_1 C \circ \semBrcks{\theta \leq \theta'}_1 C$\\
\

\indent
$\semBrcks{(\theta_0 \rightarrow \theta'_0) \leq (\theta_1 \rightarrow \theta'_1)}_1 C \ f \ \widehat{C}$ \\
			\indent \indent \indent \indent \indent \indent
			$=$ 
			$\semBrcks{\theta'_0 \leq \theta'_1}_1 (C \concat \widehat{C}) 
				\circ 
			(f \ \widehat{C}) 
				\circ 
			\semBrcks{\theta_1 \leq \theta_0}_1 (C \concat \widehat{C}) 
			$\\

con $\J$ la inyecci\'on de enteros en reales.

\end{definition}

Ahora que hemos definido las ecuaciones sem\'anticas para nuestros tipos 
hagamos un repaso sobre las mas relevantes de ellas. En determinados momentos
vamos a hablar acerca de $\textit{alcance con forma}$, a lo que nos vamos
a referir es, no solo al contexto en el cual un identificador tiene sentido,
si no adem\'as la forma que debe tener un estado en ese contexto.

\begin{itemize}
\item $\semBrcks{\deltaexp}C$, como ya hemos mencionado ser\'a una funci\'on 
de un estado en un conjunto $S_\delta$ de valores, la motivaci\'on de 
esta definici\'on es poder disponer del estado para obtener el valor de 
una variable imperativa cuando se la utiliza como expresi\'on.

\item $\semBrcks{\deltaexp}(h,s) \ e$, acá $e : C \rightarrow S_\delta$, luego
hacemos la transformaci\'on componiendo con $h : C' \rightarrow C$, para obtener
$e \circ h : C' \rightarrow S_\delta$.

\item $\semBrcks{\commt}C$, esta tal vez sea la mas intuitiva, ser\'a
una funci\'on de un estado con forma $C$ en otro con la misma forma $C$ y
como en todos los casos contemplando la no terminaci\'on.

\item $\semBrcks{\commt}(h,s) \ c$, parecido a como pasaba para $\deltaexp$,
tenemos un $c : C \rightarrow C_\bot$ y tenemos que 
$s : (C \rightarrow C_\bot) \rightarrow (C' \rightarrow C'_\bot)$, luego
$s \ c : C' \rightarrow C'_\bot$.

\item $\semBrcks{\deltaacc}C$, el tipo representa a la variable como contenedora
de valores, luego la sem\'antica ser\'a una funci\'on que toma un valor en $S_\delta$,
un estado y devuelve un nuevo estado con el valor de la variable modificado.

\item $\semBrcks{\deltaacc}(h,s) \ a$, como mencion\'abamos antes, 
$a : S_\delta \rightarrow (C \rightarrow C_\bot)$ y
$s : (C \rightarrow C_\bot) \rightarrow (C' \rightarrow C'_\bot)$, por lo tanto
con la composici\'on $s \circ a : S_\delta \rightarrow (C' \rightarrow C'_\bot)$
obtenemos la nueva funci\'on que actualiza valores de una variable en un estado
extendido.

\item $\semBrcks{\theta \rightarrow \theta'}C$, para interpretar esta ecuaci\'on
podemos empezar cuestionando porque no podr\'ia estar definida de la siguiente 
manera,\\

$\semBrcks{\theta \rightarrow \theta'}C = \semBrcks{\theta}C \rightarrow \semBrcks{\theta'}C$\\

y el problema esta en bajo que alcance se realiza la aplicaci\'on, 
b\'asicamente puede suceder que la aplicaci\'on suceda en un alcance
que tiene nuevas declaraciones y como consecuencia de esto, el estado tenga diferente
forma. La soluci\'on entonces se basa en obtener cuanto se extendió el estado.

\item $\semBrcks{\theta \rightarrow \theta'} (h,s) \ f$, pensemos que $f$ puede
aplicarse en un alcance con, por lo menos, forma $C$ y queremos que pase a, por lo menos,
poder aplicarse en un alcance con forma $C'$, entonces ampliamos hasta por lo menos
la forma $C'$, con $\overline{C}$ y agregamos la posibilidad de seguir ampliando con $\widehat{C}$.

\item $\semBrcks{(\theta_0 \rightarrow \theta'_0) \leq (\theta_1 \rightarrow \theta'_1)}_1 C \ f \ \widehat{C}$,
lo que sucede con esta ecuaci\'on no es muy diferente a lo que pasa con la definici\'on hecha en
lambda leq, el \'unico cuidado que hay que tener es el de extender la forma de $C$.

\end{itemize}

Pasemos ahora a definir la sem\'antica de nuestros contextos, de igual manera que
hicimos con los tipos, empecemos analizando los tipos de las ecuaciones que vamos
a definir. Sea $\pi$ un objeto de $\Pi$ luego tenemos que,\\

$\semBrcks{\pi}C : \PDom$, \\

$\semBrcks{\pi}(h,s) : \semBrcks{\pi}C \rightarrow \semBrcks{\pi}C'$ y\\

$\semBrcks{\pi \rTo^{\leq} \pi'}_1C : \semBrcks{\pi}C \rightarrow \semBrcks{\pi'}C$\\

\newpage

\begin{definition}\label{algol:contextsemfunctor}
Sea $\semBrcks{ \_ } : \Pi \rightarrow \CD$ un funtor, tal que\\

$\semBrcks{\pi}_0C$ $=$ $\prod\limits_{\iota \in dom \ \pi} \semBrcks{\pi\iota}C$\\
\

\indent
$\semBrcks{\pi}_0(h,s) \ \eta$ $=$ $\prod\limits_{\iota \in dom \ \pi} 
												\semBrcks{\pi\iota}(h,s)(\eta\iota)$\\
\

\

\indent
$\semBrcks{\pi \leq \pi'}_1C$ $=$ $\prod\limits_{\iota \in dom \ \pi} 
												\semBrcks{\pi\iota \leq \pi'\iota}C(\eta\iota)$

\end{definition}

De la pasada definici\'on la ecuaci\'on que nos va a interesar ser\'a $\semBrcks{\pi}_0(h,s) \ \eta$,
esta nos servir\'a para acomodar un ambiente $\eta$ a una determinada forma cuando lo extendemos
agregando un valor, veremos adem\'as que esto pasa solamente para la abstracci\'on lambda y
la declaraci\'on de variable imperativa.\\

Ahora que hemos definido la sem\'antica de contextos y tipos, podemos continuar con
la sem\'antica de los juicios de tipado de las frases. Como hicimos antes vamos a definir un 
funtor, solo que este tomar\'a un juicio de tipado $\pi \vdash e : \theta$ y 
devolver\'a una transformaci\'on natural del funtor $\semBrcks{\pi}$ en el funtor $\semBrcks{\theta}$ 
indexada por objetos de $\C$.\\
\

\noindent
$\texttt{Denotal Sem:}$ Constantes.\\

$\semBrcks{ \pi \vdash b : \boolexp }C \ \eta \ \sigma$ $=$ $\iotabot \ b$\\

$\semBrcks{ \pi \vdash i : \intexp  }C \ \eta \ \sigma$ $=$ $\iotabot \ i$\\

$\semBrcks{ \pi \vdash r : \realexp }C \ \eta \ \sigma$ $=$ $\iotabot \ r$\\

\noindent
$\texttt{Denotal Sem:}$ Operadores unarios.\\

$\semBrcks{ \pi \vdash \neg b : \boolexp }C$ 
$=$ 
$(\lambda b . \ \iotabot \neg b)_{\dbot} \circ \semBrcks{\pi \vdash b : \boolexp}C$\\

$\semBrcks{ \pi \vdash -i : \intexp }C$ 
$=$ 
$(\lambda i . \ \iotabot -i)_{\dbot} \circ \semBrcks{\pi \vdash i : \intexp}C$\\

$\semBrcks{ \pi \vdash -r : \realexp }C$ 
$=$ 
$(\lambda r . \ \iotabot -r)_{\dbot} \circ \semBrcks{\pi \vdash r : \realexp}C$\\

\noindent
$\texttt{Denotal Sem:}$ Operadores binarios\\

$\semBrcks{ \pi \vdash b \owedge b' : \boolexp }C \ \eta \ \sigma$ 
$=$ \\
\indent \indent \indent
$(\lambda b . \ (\lambda b' . \ \iotabot (b \owedge b'))_{\dbot}
\semBrcks{\pi \vdash b' : \boolexp}C \ \eta \ \sigma)_{\dbot}
\semBrcks{\pi \vdash b : \boolexp}C \ \eta \ \sigma$\\

con $\owedge \in \{ \wedge,\vee,\Rightarrow,\Leftrightarrow \}$\\

$\semBrcks{ \pi \vdash i \oplus i' : \deltaexp }C \ \eta \ \sigma$ 
$=$ \\
\indent \indent \indent
$(\lambda i . \ (\lambda i' . \ \iotabot (i \oplus i'))_{\dbot}
\semBrcks{\pi \vdash i' : \deltaexp}C \ \eta \ \sigma)_{\dbot}
\semBrcks{\pi \vdash i : \deltaexp}C \ \eta \ \sigma$\\

con $\oplus \in \{ +,-,*,/\,\rem \}$, $\delta \in \{\intt,\realt\}$\\

$\semBrcks{ \pi \vdash e \ominus e' : \boolexp }C \ \eta \ \sigma$ 
$=$ \\
\indent \indent \indent 
$(\lambda e . (\lambda e' . \iotabot (e \ominus e'))_{\dbot}
\semBrcks{\pi \vdash e' : \deltaexp}C \ \eta \ \sigma)_{\dbot}
\semBrcks{\pi \vdash e : \deltaexp}C \ \eta \ \sigma$\\

con $\ominus \in \{\leq,\geq,<,> \}$, $\delta \in \{\intt,\realt\}$\\

$\semBrcks{ \pi \vdash e \ominus e' : \boolexp }C \ \eta \ \sigma$ 
$=$ \\
\indent \indent \indent 
$(\lambda e . (\lambda e' . \iotabot (e \ominus e'))_{\dbot}
\semBrcks{\pi \vdash e' : \deltaexp}C \ \eta \ \sigma)_{\dbot}
\semBrcks{\pi \vdash e : \deltaexp}C \ \eta \ \sigma$\\

con $\ominus \in \{=,\neq\}$\\

\noindent
$\texttt{Denotal Sem:}$ Expresi\'on condicional.\\

$\semBrcks{ \pi \vdash \cifthenelse{b}{e}{e'}: \deltaacc}C \ \eta \ z \ \sigma$ 
$=$ \\
\indent \indent \indent 
$(\lambda b . \ if \ b $ $then \ \semBrcks{ \pi \vdash e : \deltaacc}C \ \eta \ z \ \sigma$\\
\indent \indent \indent \indent \indent \ \ \ \
$else \ \semBrcks{ \pi \vdash e' : \deltaacc}C \ \eta \ z \ \sigma)_{\dbot}$ 
$(\semBrcks{ \pi \vdash b : \boolexp}C \ \eta \ \sigma)$\\

$\semBrcks{ \pi \vdash \cifthenelse{b}{e}{e'}: \deltaexp}C \ \eta \ \sigma$ 
$=$ \\
\indent \indent \indent 
$(\lambda b . \ if \ b $ $then \ \semBrcks{ \pi \vdash e : \deltaexp}C \ \eta \ \sigma$\\
\indent \indent \indent \indent \indent \ \ \ \
$else \ \semBrcks{ \pi \vdash e' : \deltaexp}C \ \eta \ \sigma)_{\dbot}$ 
$(\semBrcks{ \pi \vdash b : \boolexp}C \ \eta \ \sigma)$\\

$\semBrcks{ \pi \vdash \cifthenelse{b}{e}{e'}: \commt}C \ \eta \ \sigma$ 
$=$ \\
\indent \indent \indent 
$(\lambda b . \ if \ b $ $then \ \semBrcks{ \pi \vdash e : \commt}C \ \eta \ \sigma$\\
\indent \indent \indent \indent \indent \ \ \ \
$else \ \semBrcks{ \pi \vdash e' : \commt}C \ \eta \ \sigma)_{\dbot}$ 
$(\semBrcks{ \pi \vdash b : \boolexp}C \ \eta \ \sigma)$\\

$\semBrcks{ \pi \vdash \cifthenelse{b}{e}{e'}: \deltavar}C\eta$ 
$=$ \\ 
\indent \indent
$\langle \ \semBrcks{ \pi \vdash \cifthenelse{b}{e}{e'}: \deltaacc}C\eta$
$, \semBrcks{ \pi \vdash \cifthenelse{b}{e}{e'}: \deltaexp}C\eta \ \rangle$ \\

En este punto vamos a hacer un par\'entesis para comentar lo que cuando
presentamos los juicios de tipado validos para el lenguaje quedo pospuesto.
Recordado, \'ibamos a evitar que el juicio de tipado
$\pi \vdash \cifthenelse{b}{e}{e'} : \theta \rightarrow \theta'$, 
sea valido y, bas\'andonos en las ecuaciones sem\'anticas para los 
distintos juicios de tipado de la expresi\'on condicional que hemos
dado, la raz\'on entonces esta en notar que para evaluar el comando
condicional tenemos que "rescatar" el estado para poder evaluar
el juicio de la guarda $\pi \vdash b : \boolexp$, entonces para
el caso en que nuestra expresi\'on condicional tipa a 
$\deltaexp$ o $\commt$ es sencillo porque el estado esta "a la mano",
ya para $\deltaacc$ no es tan cierto pero no es una limitaci\'on vemos
que primero tenemos que "rescatar" un $z$ y despu\'es reci\'en aparece
el estado. \\
Veamos ahora algunas de las complicaciones cuando
el tipo de nuestro juicio de tipado para la expresi\'on condicional 
tiene varias flechas($\rightarrow$), supongamos tenemos el juicio
$\pi \vdash \cifthenelse{b}{f}{f'} : \theta \rightarrow \theta' \rightarrow \theta''$ y
recordemos que la sem\'antica de $\theta_0 \rightarrow \theta_1$ se puede 
resumir en, tomar una posible expansi\'on del estado, un valor para agregar 
al ambiente que
ser\'a el valor pasado por argumento y finalmente aparece nuestro estado 
en alguna de las formas que sabemos "rescatarlo" siempre y cuando $\theta_1$
no sea algo de tipo flecha.\\
La pregunta que surge entonces es 
¿Como saber cuantos $z'$s y $C'$s hay que rescatar hasta encontrarse el estado?; 
continuando con el ejemplo, $f$ podr\'ia ser la expresi\'on $\lambda v. ff$ tal que, 
abusando de notaci\'on, $v : \theta \rightarrow \theta'$. Esto 
implicar\'ia rescatar un solo $z$ y un solo $C$ para encontrar el estado, una 
primera idea podr\'ia ser usar la informaci\'on del tipo de $v$ ya que tenemos
tipado explicito, luego 
tomar\'iamos este $z$ y $C$ y evaluar\'iamos cada caso de la expresi\'on
condicional pasando estos valores, parecido a como hacemos cuando
tenemos el tipo $\deltaacc$. Esta entonces parecer\'ia ser una posible 
soluci\'on, pero surge otra complicaci\'on supongamos $f'$ es igual a
$(\lambda v' . \lambda v . ff)h$ es decir, $f'$ tipa correctamente pero
sin embargo no es una abstracci\'on lambda, si no que hay una aplicaci\'on
y esto implica entonces que rescatar el estado es distinto para una componente
que para otra de la expresi\'on condicional. En resumen, no es tan sencillo
saber de que forma "rescatar" el estado para, recordando, evaluar la guarda.\\

Una soluci\'on podr\'ia llegar a tener que ver con siempre tener el estado
"a mano" para poder "rescatarlo", con esta idea en mente proponemos entonces
la siguiente idea. Lo primero ser\'a agregar un tipo nuevo a nuestros 
$\phraseTypes$, para esto entonces vamos a tener que acomodar la sintaxis y dar
nuevas reglas de tipado, adem\'as de dar el significado sem\'antico, tanto
del tipo nuevo como de su nuevo juicio de tipado.

\setlength{\grammarindent}{8em}
\begin{grammar}

<Phrase Types> ::= <Phrase Types> | $\IF$ <Phrase Types>

\end{grammar}

Ahora con este nuevo tipo entonces lo que hacemos es actualizar el juicio de
tipado de la expresi\'on condicional de la siguiente manera\\

\begin{center}
\AxiomC{$\pi \vdash b  : \boolexp$}
\AxiomC{$\pi \vdash e  : \theta$}
\AxiomC{$\pi \vdash e' : \theta$}
\TrinaryInfC{$\pi \vdash \cifthenelse{b}{e}{e'} : \IF \ \theta$}
\DisplayProof
\end{center}

prestando especial atenci\'on a que ahora no restringimos $\theta$, sacando 
$\rightarrow$. Donde el significado de nuestro tipo $\IF \ \theta$ ser\'a
un funtor de $\C \rTo \D$ tal que, tomando una flecha $(h,s) : C \rTo C'$\\

$\semBrcks{ \IF \ \theta }C$ $:$ $\D$\\
\indent
$\semBrcks{ \IF \ \theta }C$ $=$ $C \rightarrow \semBrcks{\theta}C$\\

$\semBrcks{ \IF \ \theta }(h,s)$ $:$ $\semBrcks{ \IF \ \theta }C 
										\rTo 
										\semBrcks{ \IF \ \theta }C'$\\
\indent
$\semBrcks{ \IF \ \theta }(h,s) \ if$ $=$ $if \circ h$\\

para finalizar, actualizamos nuestra ecuaci\'on sem\'antica para el 
juicio de tipado. Es interesante que con esta nueva definici\'on no nos
har\'an falta separa por casos en el tipo $\theta$\\

$\semBrcks{ \pi \vdash \cifthenelse{b}{e}{e'}: \IF \ \theta}C \ \eta$
$:$ $\semBrcks{ \IF \ \theta }C$\\
\indent
$\semBrcks{ \pi \vdash \cifthenelse{b}{e}{e'}: \IF \ \theta}C \ \eta$
$:$ $C \rightarrow \semBrcks{\theta}C$\\
\indent
$\semBrcks{ \pi \vdash \cifthenelse{b}{e}{e'}: \IF \ \theta}C \ \eta \ \sigma$ 
$=$ \\
\indent \indent \indent 
$(\lambda b . \ if \ b $ $then \ \semBrcks{ \pi \vdash e : \theta}C \ \eta $\\
\indent \indent \indent \indent \indent \ \ \ \
$else \ \semBrcks{ \pi \vdash e' : \theta}C \ \eta)_{\dbot}$ 
$(\semBrcks{ \pi \vdash b : \boolexp}C \ \eta \ \sigma)$\\

Ahora bien, esta posible soluci\'on no ser\'a estudiada en detalle y solamente
vale como ejercicio para tener una idea mas formal de lo que ser\'ia practico
tener como ecuaci\'on sem\'antica para la expresi\'on condicional. En el resto 
del cap\'itulo vamos a seguir considerando la idea original.\\

\noindent
$\texttt{Denotal Sem:}$ Aplicaci\'on.\\

$\semBrcks{ \pi \vdash ee' : \theta' }C \ \eta$ 
$=$ 
$\semBrcks{ \pi \vdash e : \theta \rightarrow \theta' }C \ \eta \ \lrangles{} \
(\semBrcks{ \pi \vdash e' : \theta }C \ \eta)$\\

\noindent
$\texttt{Denotal Sem:}$ Operador de punto fijo.\\

$\semBrcks{ \pi \vdash \rec e : \theta}C \ \eta$ 
$=$ 
$\Y_{\semBrcks{\theta}C} \ 
(\semBrcks{ \pi \vdash e : \theta \rightarrow \theta}C \ \eta \ \lrangles{})$\\

\noindent
$\texttt{Denotal Sem:}$ Identificador.\\

$\semBrcks{ \pi \vdash \iota : \theta }C \ \eta$ $=$ $\eta \ \iota$
\ \ \ \ \ \ \ \ \ \ \ \ \ \ cuando $\iota:\theta$ $\in$ $\pi$.\\

\noindent
$\texttt{Denotal Sem:}$ \cskip.\\

$\semBrcks{ \pi \vdash \cskip : \commt }C \ \eta \ \sigma$ $=$ $\iotabot \ \sigma$\\

\noindent
$\texttt{Denotal Sem:}$ Composici\'on.\\

$\semBrcks{ \pi \vdash \cseq{e}{e'} : \commt }C \ \eta$ 
$=$ 
$(\semBrcks{\pi \vdash e' : \commt}C \ \eta)_{\dbot}
\circ
(\semBrcks{ \pi \vdash e : \commt}C \ \eta)$\\

\noindent
$\texttt{Denotal Sem:}$ \cwhile.\\

$\semBrcks{ \pi \vdash \cwhiledo{b}{e} : \commt }C \ \eta$ 
$=$ \\
\indent \indent \indent
$\Y_{\semBrcks{\commt}C}$ $(\lambda c . \ \lambda \sigma . \ $\\
\indent \indent \indent \indent \indent \indent
$(\lambda b . \ if \ b $ $then \ c_{\dbot} (\semBrcks{\pi \vdash e : \commt}C \ \eta \ \sigma)$\\
 \indent \indent  \indent \indent \indent \indent \indent \indent \ \ \ \
$else \ \iotabot \ \sigma)_{\dbot}$ \
$(\semBrcks{ \pi \vdash b : \boolexp}C \ \eta \ \sigma))$\\

\noindent
$\texttt{Denotal Sem:}$ Asignaci\'on.\\

$\semBrcks{ \pi \vdash \assig{e}{e'} : \commt }C \ \eta \ \sigma$ 
$=$ \\
\indent \indent \indent \indent \indent 
$(\lambda x . \ \semBrcks{\pi \vdash e : \deltaacc}C \ \eta \ x \ \sigma)_{\dbot}
(\semBrcks{ \pi \vdash e' : \deltaexp }C \ \eta \ \sigma)$\\

\noindent
$\texttt{Denotal Sem:}$ Abstracci\'on lambda.\\

$\semBrcks{ \pi \vdash \lambda \iota_{\theta} . \ e : \theta \rightarrow \theta' }C \ \eta \ C' \ z$ 
$=$ 
$\semBrcks{ \pi,\iota:\theta \vdash e : \theta' } \ (C \concat C') \
[ \ \semBrcks{\pi}(h,s) \ \eta \ | \ \iota:z \ ]$\\

con $(h,s)$ $:$ $C \rTo (C \concat C')$ \\

Hasta aqu\'i hemos definido todas las ecuaciones sem\'anticas de $\Alike$ salvo
para el comando $\cnew \ \deltavar$, para este vamos a tener dos definiciones
y con estas, en conjunto con las dos categor\'ias de estados, vamos a completar 
las dos sem\'anticas que estudiamos.\\

$\texttt{Denotal Sem:}$ Declaraci\'on de variable (Stack discipline).\\

$\semBrcks{\pi \vdash \newdeltavar{\iota}{ei}{c} : \commt}C \ \eta \ \sigma$ 
$=$ \\ \indent \indent
$H_{\bot} ((\lambda \ v . \ \semBrcks{\pi,\iota:\deltavar \vdash c : \commt}
		\ (C\concat\lrangles{S_\delta}) \ \eta_{ext} \ \sigma_{ext})_{\dbot}$
\\ \indent \indent  \indent  \indent  \indent \indent  \indent
\indent \indent \indent \indent \indent \indent \indent
\indent \indent \indent
$(\semBrcks{\pi \vdash ei : \deltaexp}C \ \eta \ \sigma))$\\

con $(h,s)$ $:$ $C \rTo (C \concat \lrangles{S_\delta})$ \\
\indent \indent \ \
$a$ $=$ $\lambda v. \ \lambda \sigmahat . \ \iotabot ((head_{C} \sigmahat) \concat \lrangles{v})$\\
\indent \indent \ \
$e$ $=$ $ \iotabot \circ last_{S_\delta}$\\
\indent \indent \ \
$\sigma_{ext} = \sigma \concat \lrangles{v} $\\
\indent \indent \ \
$\eta_{ext} = [ \ \semBrcks{\pi}(h,s) \ \eta \ | \ \iota:\lrangles{a,e} \ ]$\\
\indent \indent \ \
$H = head_C$\\

\noindent
Expliquemos la ecuaci\'on detenidamente, recordando que esta es la versi\'on
con stack discipline, el comportamiento que este comando deber\'ia tener es evaluar
el comando $c$ en un estado y ambiente extendido con el identificador $\iota$, 
este con el valor inicial correspondiente de haber evaluado $ei$
y al terminar la evaluaci\'on de $c$ contraer el estado y el ambiente, tirando
de esa manera toda referencia al identificador $\iota$.\\

Suponiendo siempre la evaluaci\'on de nuestros comandos es distinta de $\bot$, 
lo primero que hacemos es evaluar el juicio de tipado $\pi \vdash ei : \deltaexp$
con el ambiente y estado sin extender, esta evaluaci\'on nos retorna un valor
que vamos a nombrar $v$, este ser\'a el valor para inicializar el identificador $\iota$.
Luego pasamos a evaluar $\pi \vdash c : \commt$, ac\'a vamos a tener que extender 
el ambiente y el estado, as\'i como tambi\'en el conjunto de estados con el tipo
b\'asico del identificador. \\
Extender el estado ser\'a simplemente pegar por atr\'as el valor $v$ al estado
$\sigma$, extender el ambiente ya no es tan simple por un lado si ocurre que 
agregamos el identificador $\iota$ con el par aceptador-evaluador por atr\'as
pero no al ambiente tal cual lo ten\'iamos, si no a un nuevo ambiente que es
el resultado de acomodar el ambiente original a la extensi\'on del estado, mas
adelante vamos a ver por qu\'e esto es importante. Sobre el par aceptador-evaluador
podemos notar que evaluar $\iota$ como expresi\'on ser\'a evaluar $e$, es decir,
ser\'a obtener el ultimo elemento del estado y evaluar $\iota$ como aceptador ser\'a
recortar el estado hasta justo antes del valor actual y pegar por atr\'as el nuevo
valor.\\
Finalmente al terminar de evaluar $\pi \vdash c : \commt$ obtenemos un estado
con forma $C \concat \lrangles{S_\delta}$ y necesitamos contraerlo para eliminar
el valor de $\iota$, esto lo hace $H_\bot$ recortando el estado hasta justo antes
del valor, justo como pasaba con la evaluaci\'on de $\iota$ como aceptador pero
sin agregar ning\'un valor nuevo.\\

Repasemos con un ejemplo todo lo comentado anteriormente.\\

\noindent
\textbf{Ejemplo}
Supongamos tenemos un comando (programa),\\

$\cnew \ \intvar \ \assig{\iota}{0} \ \cin$\\
\indent \indent
$\cnew \ \intvar \ \assig{\kappa}{1} \ \cin$\\
\indent \indent \indent
$\assig{\kappa}{\iota}$ $\cseq$\\
\indent
$\cskip$\\

y la siguiente derivaci\'on que nos prueba que esta bien tipado para
obtener el juicio de tipado $\vdash \cseq{\cnew \iota \ }{ \ \cskip} : \commt$, donde
$\cnew \iota$ es el primer comando $\cnew \intvar$, adem\'as vamos a
llamar $\cnew \kappa$ al otro comando $\cnew \intvar$. Dividimos la derivaci\'on
en tres partes, en las que $\pi_{\xi_0,\ldots,\xi_n}$, representa el contexto
con $\xi_0,\ldots,\xi_n$ identificadores.

\begin{center}
\AxiomC{}
\UnaryInfC{$\pi_{\iota,\kappa} \vdash \kappa : \intvar$}
\AxiomC{$\intvar \leq \intexp$}
\BinaryInfC{$\pi_{\iota,\kappa} \vdash \kappa : \intacc$}
\AxiomC{}
\UnaryInfC{$\pi_{\iota,\kappa} \vdash \iota : \intvar$}
\AxiomC{$\intvar \leq \intexp$}
\BinaryInfC{$\pi_{\iota,\kappa} \vdash \iota : \intexp$}
\BinaryInfC{$\pi_\iota,\kappa:\intvar \vdash \assig{\kappa}{\iota} : \commt$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{}
\UnaryInfC{$\pi_\iota \vdash 1 : \intexp$}
\AxiomC{}
\UnaryInfC{$\pi_\iota,\kappa:\intvar \vdash \assig{\kappa}{\iota} : \commt$}
\BinaryInfC{$\iota:\intvar \vdash \cnew \kappa : \commt$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{}
\UnaryInfC{$\vdash 0 : \intexp$}
\AxiomC{}
\UnaryInfC{$\iota:\intvar \vdash \cnew \kappa : \commt$}
\BinaryInfC{$\vdash \cnew \iota : \commt$}
\AxiomC{}
\UnaryInfC{$\vdash \cskip : \commt$}
\BinaryInfC{$\vdash \cseq{\cnew \iota \ }{ \ \cskip} : \commt$}
\DisplayProof
\end{center}

\noindent
Ahora que tenemos nuestro juicio de tipado $\vdash \cseq{\cnew \iota \ }{ \ \cskip} : \commt$
podemos continuar con la evaluaci\'on, podemos empezar evaluando a vista y notar que
a lo que pretendemos que evalu\'e este juicio es a $\emptystate$, el estado vac\'io, 
pero adem\'as y es
la principal raz\'on por la que esta el comando $\cskip$, es ver que luego de ejecutar
un $\cnew \ \deltavar$ el comando que siga a este no sabe nada acerca de lo que paso
dentro y con los identificadores. Tomamos ambiente y estado vac\'ios, \\

\noindent
$\semBrcks{\vdash \cseq{\cnew \iota \ }{ \ \cskip} : \commt}\emptyshape\emptyenv\emptystate$ $=$
$((\semBrcks{\vdash \cskip : \commt}\emptyshape\emptyenv)_{\dbot}
\circ 
\semBrcks{\vdash \cnew \iota : \commt}\emptyshape\emptyenv) \emptystate$\\

ahora pasemos a evaluar juicio de tipado para $\cnew \iota$\\

\noindent
$\semBrcks{\vdash \cnew \iota : \commt}\emptyshape\emptyenv\emptystate$
$=$ \\ \indent \indent
$H_{\bot} ((\lambda \ v . \ \semBrcks{\iota:\intvar \vdash \cnew \kappa : \commt}
		\ (\emptyshape \concat\lrangles{S_\intt}) \ \eta_{ext} \ \sigma_{ext})_{\dbot}$
\\ \indent \indent  \indent  \indent  \indent \indent  \indent
\indent \indent \indent \indent \indent \indent \indent
\indent \indent \indent
$(\semBrcks{\vdash 0 : \intexp}\emptyshape \ \emptyenv \ \emptystate))$\\

donde $\eta_{ext}$ ser\'a simplemente agregar el identificador $\iota$ y el
par $\lrangles{a_\iota,e_\iota}$ y $\sigma_{ext}$ ser\'a la lista de valores
con un \'unico valor, el $0$.\\

\noindent
$\semBrcks{\vdash \cnew \iota : \commt}\emptyshape\emptyenv\emptystate$
$=$
$H_{\bot} \semBrcks{\iota:\intvar \vdash \cnew \kappa : \commt}
				    \ \lrangles{S_\intt} \ 
		  	        [ \ \iota : \lrangles{a_\iota,e_\iota} \ ] \ \lrangles{0}$\\

con $a_\iota = \lambda v. \ \lambda \sigmahat . \ \iotabot 
				((head_{\lrangles{}} \sigmahat) \concat \lrangles{v})$\\
\indent \indent \ 
$e_\iota$ $=$ $ \iotabot \circ last_{S_\intt}$\\

evaluamos el $\cnew \kappa$ como hicimos con $\cnew \iota$ pero con el cuidado
de que ahora no tenemos forma, ni ambiente, ni estado vac\'ios\\

\noindent
$\semBrcks{\pi_\iota \vdash \cnew \kappa : \commt}
	\ \lrangles{S_\intt} \ 
	[ \ \iota : \lrangles{a_\iota,e_\iota} \ ] \ \lrangles{0}$ $=$ \\
\indent \indent
$H_{\bot} ((\lambda \ v . \ \semBrcks{\pi_\iota,\kappa:\intvar \vdash \assig{\kappa}{\iota}: \commt}
		\ (\lrangles{S_\intt} \concat\lrangles{S_\intt}) \ \eta_{ext} \ \sigma_{ext})_{\dbot}$
\\ \indent \indent  \indent  \indent  \indent \indent  \indent
\indent \indent \indent \indent \indent \indent \indent
\indent \indent \indent
$(\semBrcks{\pi_\iota \vdash 1 : \intexp}\emptyshape \ \emptyenv \ \emptystate))$\\

como antes, tenemos que ver quienes ser\'an $\eta_{new}$ y $\sigma_{new}$, empezando por
este ultimo es sencillo y es simplemente pegar por atr\'as el valor $1$, en cuanto a
$\eta_{new}$ ya no es tan directo, lo que sucede es que vamos a tener que acomodar el
antiguo ambiente, $[ \ \iota : \lrangles{a_\iota,e_\iota} \ ]$, y luego agregar
el identificador $\kappa$ con el par $\lrangles{a_\kappa,e_\kappa}$.\\
Para acomodar el ambiente utilizamos 
$\semBrcks{\pi_\iota}(h,s)$ donde $\lrangles{S_\intt} \rTo^{(h,s)} \lrangles{S_\intt,S_\intt}$,
es decir, este funtor aplicado a la flecha $(h,s)$ toma un ambiente de tipo
$\semBrcks{\pi_\iota}\lrangles{S_\intt}$ y nos retorna un ambiente con tipo 
$\semBrcks{\pi_\iota}\lrangles{S_\intt,S_\intt}$.\\

$\semBrcks{\pi_\iota}(h,s) \ [ \ \iota : \lrangles{a_\iota,e_\iota} \ ]$ $=$
$[ \ \iota : \semBrcks{\pi_\iota \iota}(h,s) \lrangles{a_\iota,e_\iota} \ ]$ $=$\\

\indent
$[ \ \iota : \semBrcks{\intvar}(h,s) \lrangles{a_\iota,e_\iota} \ ]$ $=$
$[ \ \iota : \lrangles{\semBrcks{\intacc}(h,s) a_\iota,\semBrcks{\intacc}(h,s)e_\iota} \ ]$ $=$\\

\indent
$[ \ \iota : \lrangles{s \circ a_\iota,e_\iota \circ h} \ ]$\\

ahora si podemos extender el ambiente 
$[ \ \iota : \lrangles{s \circ a_\iota,e_\iota \circ h} \ | \
	\kappa : \lrangles{a_\kappa,e_\kappa}\ ]$ y este sera nuestro nuevo ambiente $\eta_{new}$.
Luego podemos avanzar un poco mas con la evaluaci\'on y pasar en limpio la ultima ecuaci\'on,\\

\noindent
$\semBrcks{\pi_\iota \vdash \cnew \kappa : \commt}
	\ \lrangles{S_\intt} \ 
	[ \ \iota : \lrangles{a_\iota,e_\iota} \ ] \ \lrangles{0}$ $=$ \\
	\indent 
	$H_{\bot} 
	\semBrcks{\pi_{\iota,\kappa} \vdash \assig{\kappa}{\iota}: \commt}
		\ \lrangles{S_\intt,S_\intt}
		\ [ \ \iota : \lrangles{s \circ a_\iota,e_\iota \circ h} \ | \
			\kappa : \lrangles{a_\kappa,e_\kappa}\ ] 
		\ \lrangles{0,1}$\\

con $a_\kappa = \lambda v. \ \lambda \sigmahat . \ \iotabot 
				((head_{\lrangles{S_\intt}} \sigmahat) \concat \lrangles{v})$\\
\indent \indent \ 
	$e_\kappa$ $=$ $ \iotabot \circ last_{S_\intt}$\\
\indent \indent \ 
	$(s \circ a_\iota) \ x \ \sigmahat = 
		(\lambda \sigma . \ \sigma \concat tail_{\lrangles{S_\intt}}\sigmahat)_{\bot} 
			(a_\iota \ x \ (head_{\lrangles{S_\intt}} \sigmahat))$\\
\indent \indent \ 
	$e_\iota \circ h = e_\iota \circ head_{\lrangles{S_\intt}}$.\\
	
Haciendo un repaso general de lo que llevamos hecho, tenemos evaluado hasta el comando
de asignaci\'on, esto implica haber evaluado los comandos para introducir variables 
imperativas, lo mas importante a repasar es los pares aceptor-evaluador de los
identificadores $\iota$ y $\kappa$. Empezando con $\iota$, vemos que usarlo como
expresi\'on es utilizar como $e_\iota$ que
sabe como retornar el valor asociado a $\iota$ dado un estado con forma $\lrangles{S_\intt}$,
luego acomodando esto al introducir $\kappa$, lo que sucede es que usar como expresi\'on
a $\iota$ es utilizar $e_\iota \circ head_{\lrangles{S_\intt}}$, es decir, dado
un estado con forma $\lrangles{S_\intt, S_\intt}$, primero nos quedamos con la
parte inicial sin la extensi\'on del identificador $\kappa$ y luego ya podemos
utilizar $e_\iota$ en un estado con forma $\lrangles{S_\intt}$. Notar que
si fuera el caso general de agregar $n$ variables imperativas anidadas, supongamos
$\xi_1,\ldots,\xi_n$, entonces para rescatar
la variable $i$-esima vamos a hacer $n-i$ $head's$ y luego aparece la definici\'on
$e_{\xi_i}$ original de cuando se introdujo el identificador.\\
Si en cambio usamos a $\iota$ como aceptador de valor, entonces ser\'a utilizar
$a_\iota$ que sabe recortar un estado con forma $\lrangles{S_\intt}$ de manera
de perder justo el valor asociado a $\iota$, como pasaba con antes, al agregar
$\kappa$ hay que acomodar la funci\'on a utilizar cuando usamos $\iota$ como aceptador,
para esto vamos a usar 
$s : (\lrangles{S_\intt} \rightarrow \lrangles{S_\intt}_{\bot})
	 \rightarrow 
	 (\lrangles{S_\intt,S_\intt} \rightarrow \lrangles{S_\intt,S_\intt}_{\bot})$, esta
funci\'on b\'asicamente va a tomar $a \ x : \lrangles{S_\intt} \rightarrow \lrangles{S_\intt}_{\bot}$,
recortar un la parte inicial de un estado con forma $\lrangles{S_\intt,S_\intt}$, aplicar
$a \ x$ en ese estado y luego concatenar el resultado de esa aplicaci\'on con la parte
final del estado original con forma $\lrangles{S_\intt,S_\intt}$.\\
Notar que para las funciones $e_\kappa$ y $a_\kappa$ el comportamiento es igual
al comportamiento para $e_\iota$ y $a_\iota$ cuando no se agregan variables imperativas 
nuevas. Hecho este repaso, podemos continuar con la evaluaci\'on del juicio de tipado
de la asignaci\'on, ac\'a vamos a ver como es que utilizamos un identificador 
tanto como aceptor y como valor.\\

$\semBrcks{\pi_{\iota,\kappa} \vdash \assig{\kappa}{\iota}: \commt}
		\ \lrangles{S_\intt,S_\intt} \ \eta_{\iota,\kappa}
		\ \lrangles{0,1}$ $=$\\
\indent \indent \indent \indent
$(\lambda x . \ \semBrcks{\pi_{\iota,\kappa} \vdash \kappa : \intacc}
	\lrangles{S_\intt,S_\intt} 
	\ \eta_{\iota,\kappa}
	\ x \ \lrangles{0,1})_{\dbot}$\\
\indent \indent \indent \indent \indent \indent \indent \indent
$(\semBrcks{ \pi_{\iota,\kappa} \vdash \iota : \intexp } 
	\ \lrangles{S_\intt,S_\intt}
	\ \eta_{\iota,\kappa} 
	\ \lrangles{0,1})$\\
	
evaluemos detenidamente el juicio de tipado para $\iota$, es importante notar que en
la derivaci\'on de nuestro juicio de tipado  para tipar $\iota$ no alcanza con
simplemente buscar en el contexto, ya que $\iota$ tiene tipo $\intvar$ entonces
hay que usar una regla de subtipado, por lo tanto esto impacta de la siguiente
manera en nuestra evaluaci\'on\\

$\semBrcks{ \pi_{\iota,\kappa} \vdash \iota : \intexp } 
	\ \lrangles{S_\intt,S_\intt}
	\ \eta_{\iota,\kappa} 
	\ \lrangles{0,1}$ $=$ \\
	\indent
	$(\semBrcks{\intvar \leq \intexp} \ \lrangles{S_\intt,S_\intt}
	\circ 
	\semBrcks{ \pi_{\iota,\kappa} \vdash \iota : \intvar } \ \lrangles{S_\intt,S_\intt})
		\ \eta_{\iota,\kappa} 
		\ \lrangles{0,1}$ $=$\\
	\indent
	$\semBrcks{\intvar \leq \intexp} \ \lrangles{S_\intt,S_\intt} 
				(\eta_{\iota,\kappa} \ \iota) \ \lrangles{0,1}$ $=$\\
	\indent
	$\semBrcks{\intvar \leq \intexp} \ \lrangles{S_\intt,S_\intt} 
				(\lrangles{s \circ a_\iota,e_\iota \circ h}) \ \lrangles{0,1}$ $=$
	$(e_\iota \circ h) \ \lrangles{0,1}$ $=$\\
	\indent
	$(e_\iota \circ head_{\lrangles{S_\intt}}) \lrangles{0,1}$ $=$
	$\iotabot (last_{S_\intt} (head_{\lrangles{S_\intt}} \ \lrangles{0,1}))$ $=$
	$\iotabot (last_{S_\intt} \lrangles{0})$ $=$ $\iotabot 0$\\
	
volviendo ahora con $\iota$ evaluado como expresi\'on\\

$\semBrcks{\pi_{\iota,\kappa} \vdash \assig{\kappa}{\iota}: \commt}
		\ \lrangles{S_\intt,S_\intt} \ \eta_{\iota,\kappa}
		\ \lrangles{0,1}$ $=$\\
\indent \indent \indent \indent
$\semBrcks{\pi_{\iota,\kappa} \vdash \kappa : \intacc}
	\lrangles{S_\intt,S_\intt} 
	\ \eta_{\iota,\kappa}
	\ 0 \ \lrangles{0,1}$\\

ahora evaluando similar a como hicimos con $\iota$ y teniendo el mismo cuidado
con el subtipado del identificador $\kappa$ de $\intvar$ a $\intacc$\\

$\semBrcks{\pi_{\iota,\kappa} \vdash \kappa : \intacc}
	\lrangles{S_\intt,S_\intt} 
	\ \eta_{\iota,\kappa}
	\ 0 \ \lrangles{0,1}$ $=$\\
	\indent
$(\semBrcks{\intvar \leq \intacc} \ \lrangles{S_\intt,S_\intt}
	\circ 
	\semBrcks{ \pi_{\iota,\kappa} \vdash \kappa : \intvar } \ \lrangles{S_\intt,S_\intt})
		\ \eta_{\iota,\kappa} 
		\ 0 \ \lrangles{0,1}$ $=$\\
	\indent
$\semBrcks{\intvar \leq \intacc} \ \lrangles{S_\intt,S_\intt} (\eta_{\iota,\kappa} \kappa)
		\ 0 \ \lrangles{0,1}$ $=$\\
	\indent
$\semBrcks{\intvar \leq \intacc} \ \lrangles{S_\intt,S_\intt} \lrangles{a_\kappa,e_\kappa}
		\ 0 \ \lrangles{0,1}$ $=$ $a_\kappa \ 0 \ \lrangles{0,1}$ $=$\\
	\indent
$\iotabot ((head_{\lrangles{S_\intt}} \lrangles{0,1}) \concat \lrangles{0})$ $=$
$\iotabot (\lrangles{0} \concat \lrangles{0})$ $=$ $\iotabot \lrangles{0,0}$\\

de nuevo, reescribiendo ahora con la evaluaci\'on terminada de $\kappa$,\\

$\semBrcks{\pi_{\iota,\kappa} \vdash \assig{\kappa}{\iota}: \commt}
		\ \lrangles{S_\intt,S_\intt} \ \eta_{\iota,\kappa}
		\ \lrangles{0,1}$ $=$ $\iotabot \lrangles{0,0}$\\
		
ya casi terminando y volviendo a la evaluaci\'on de la composici\'on entre
$\cnew \iota$ y $\cskip$, \\

$(\semBrcks{\vdash \cskip : \commt}\emptyshape\emptyenv)_{\dbot}
(\semBrcks{\vdash \cnew \iota : \commt}\emptyshape\emptyenv\emptystate)$
$=$\\
\indent 
$(\lambda \sigma . \ \iotabot \sigma)_{\dbot} (H_{\bot} (H_{\bot} \iotabot \lrangles{0,0}))$ $=$\\
\indent
$(\lambda \sigma . \ \iotabot \sigma)_{\dbot}
	((head_{\lrangles{}})_{\bot} ((head_{\lrangles{S_\intt}})_{\bot} \iotabot \lrangles{0,0}))$ $=$\\
\indent
$(\lambda \sigma . \ \iotabot \sigma)_{\dbot}
	(head_{\lrangles{}} \circ head_{\lrangles{S_\intt}})_{\bot} \iotabot \lrangles{0,0}$ $=$\\
\indent
$(\lambda \sigma . \ \iotabot \sigma)_{\dbot}
	((head_{\lrangles{}} (head_{\lrangles{S_\intt}} \ \lrangles{0,0})))$ $=$
$(\lambda \sigma . \ \iotabot \sigma)_{\dbot} (\iotabot \lrangles{})$ $=$ 
$\iotabot \lrangles{}$\\

y con esto terminamos la evaluaci\'on del juicio de tipado completo y adem\'as con 
el resultado esperado.

A continuaci\'on vamos a introducir nuestra versi\'on de ecuaci\'on sem\'antica
que en conjunto con la segunda categor\'ia de estados que dimos conforman la sem\'antica
sin stack discipline. Repasando lo que pretendemos con esta sem\'antica ser\'ia, 
que a diferencia de lo que paso en el ejemplo anterior que al terminar de evaluar
un comando $\cnew \deltavar$ el siguiente comando no sabe nada acerca de los
identificadores y valores a los que se evalu\'o, nosotros queremos esta informaci\'on
quede visible, aunque no sea posible acceder.\\

En el momento en que introducimos las definiciones de estados mencion\'abamos 
que, para esta segunda versi\'on, \'ibamos a abandonar el hecho de que los estados tengan
forma, ahora que avanzamos mas podemos comentar la raz\'on, uno puede pensar para la
versi\'on con stack discipline que la forma del estado esta totalmente relacionada
con la cantidad, y el tipo, de identificadores que se han introducido y son accesibles
en cierto comando anidado del $\cnew \deltavar$, de esta manera cuando termin\'abamos 
de evaluar un $\cnew \deltavar$ autom\'aticamente perd\'iamos un elemento del estado.
La cuesti\'on ahora es que, nosotros queremos que la cantidad de valores de un
estado no tenga relaci\'on con la cantidad de comandos para introducir identificadores.\\

\noindent
$\texttt{Denotal Sem:}$ Declaraci\'on de variable (Sin stack discipline).\\

$\semBrcks{\pi \vdash \newdeltavar{\iota}{e}{c} : \commt}C \ \eta \ \sigma$ 
$=$ \\ \indent \indent
$H_{\bot} ((\lambda \ v . \ \semBrcks{\pi,\iota:\deltavar \vdash c : \commt}
		\ C \ \eta_{new} \ \sigma_{new})_{\dbot}$
$(\semBrcks{\pi \vdash e : \deltaexp}C \ \eta \ \sigma))$\\

con 
$a \ v \ \sigma$ $=$ $\iotabot [ \ \sigma \ | \ \iota:\iotadelta v \ ] $\\
\indent \indent \ \
$e \ \sigma$ $=$ $(\lambda v . v)_{\delta}\sigma \iota$\\
\indent \indent \ \
$\sigma_{new} = [ \ \sigma \ | \ \iota:\iotadelta v \ ]$\\
\indent \indent \ \
$\eta_{new} = [ \ \eta \ | \ \iota:\lrangles{a,e} \ ]$\\
\indent \indent \ \
$H = 1_C$\\

De la misma forma que hicimos con la primera ecuaci\'on sem\'antica de este
comando, repasemos cada parte de la nueva ecuaci\'on. En general todo sobre 
la nueva ecuaci\'on es igual, los detalles importantes est\'an en las funciones
$a$, $e$ y $H$, empecemos notando que $H$ la cual
en la otra sem\'antica era al encargada de recortar el estado cuando terminaba 
la evaluci\'on del cuerpo, ahora es una identidad, es decir, vamos a retornar el
estado tal cual estaba al terminar de evaluar el cuerpo. La funci\'on para evaluar
el identificador como aceptador, es decir $a$, sobrescribe el valor antiguo del estado,
lo nuevo que aparece ac\'a es el $\iota_\delta$ esta funci\'on es la inyecci\'on
de $S_\delta$ en $S$, recordando $S$ era la uni\'on disjunta de $S_\intt$, 
$S_\realt$ y $S_\boolt$.\\
Para explicar la funci\'on para evaluar el identificador
como valor, primero vamos a introducir la funci\'on $(\_)_{\delta}$ que dada una $f$
de $S_\delta$ en $S_\delta$ se define as\'i,
\begin{center}
$f_{\delta}(\iota_{\delta}x) = f \ x$
\end{center}
luego simplemente ser\'a aplicar el estado al identificador, la \'unica 
salvedad importante es que $\sigma \iota : S$ y nosotros necesitamos algo de tipo
$S_\delta$, para esto utilizamos $(\lambda v. \ v)_\delta$.\\

Existe una observaci\'on importantes que surge de pensar el siguiente caso,
supongamos tenemos un $e : \Sigma \rightarrow S_\intt$ y un $\sigma \iota : S_\boolt$,
luego $e$ podr\'ia estar definido as\'i $(\lambda v . v)_{\intt}\sigma \iota$, esto es
un problema ya que $(\lambda v . v)_{\intt}$ espera algo de tipo entero y 
$\sigma \iota$ es algo de tipo booleano, para manejar esto deber\'iamos 
introducir todo un manejo extra de errores de tipos en momento de evaluaci\'on, 
y como consecuencia nuestra sem\'antica sin stack discipline generar\'ia una
nueva clase de errores que la sem\'antica con stack discipline no genera ya que,
seg\'un el primer principio, todos los errores de tipos deben ser sint\'acticos. \\

Para solucionar esto podemos pensar en que casos nuestra sem\'antica sin
stack discipline generar\'ia estos errores, nos damos cuenta que esto puede pasar
solo cuando intentamos evaluar juicios de tipado no cerrados, es decir que 
contienen variables libre. Analicemos por qu\'e esta afirmaci\'on, empecemos
suponiendo que tenemos un comando cerrado y que tenemos un $\sigma$ cualquiera,
es decir que por ejemplo tiene identificadores con valore asociados, luego
cada vez que aparezca un identificador como comando, lo que tiene que haber ocurrido
es que este identificador es un subcomando de uno o varios $\cnew \deltavar$ y por lo
tanto al evaluar este comando pisamos la posible existencia de un identificador
asociado a un valor del tipo inadecuado. El problema entonces surge cuando evaluamos
un comando no cerrado, ya que es posible que nos encontremos con un identificador
como comando a evaluar, sin que este sea subcomando de uno o varios $\cnew \deltavar$
y por lo tanto el tipo del valor asociado al identificador en el estado no sea el 
correcto.\\

La soluci\'on a esto es pensar que, para los programas que vamos a
querer evaluar o que pretendemos sean programas validos a evaluar, nunca 
son no cerrados, por lo tanto este comportamiento extraño que podr\'ia llegar
a tener nuestro evaluador sin stack discipline puede ser despreciable bas\'andonos
en este hecho, y que ser\'a una restricci\'on importante en caso de comparar
las sem\'anticas de uno y otro.

\section{Naturalidad de las ecuaciones sem\'anticas}

Para el lenguaje $\lambdaarrow$, y por lo tanto tambi\'en para $\lambdaleq$, probamos
que las ecuaciones estuvieran bien definidas, es decir que fueran funciones continuas.
Ahora vamos a hacer lo mismo para las ecuaciones de $\Alike$ con la diferencia de que
por las definiciones categ\'oricas que hicimos vamos a probar que nuestras ecuaciones
sean transformaciones naturales. Dado un juicio de tipado valido, $\pi \vdash e : \theta$,
vamos a querer probar que el siguiente diagrama conmuta dada una flecha $C \rTo{(h,s)} C'$
en $\C$,
\begin{center}
\begin{diagram}
   \semBrcks{\pi}C & & \rTo^{\semBrcks{\pi \vdash e : \theta}C} & & \semBrcks{\theta}C \\
   \dTo^{\semBrcks{\pi}(h,s)} & & & & \dTo^{\semBrcks{\theta}(h,s)} & \\
   \semBrcks{\pi}C' & & \rTo^{\semBrcks{\pi \vdash e : \theta}C'} & & \semBrcks{\theta}C' &
\end{diagram}
\end{center}

\

\begin{proposition}
Sea $(h,s) : C \rTo C'$ cualquier y dadas $f : C \rightarrow C_\bot$ y 
$f' : C \rightarrow C_\bot$ vale,

\begin{center}
$s(f'_{\dbot} \circ f)$ $=$ $s(f')_{\dbot} \circ s(f)$
\end{center}

\end{proposition}

\begin{theorem}[de naturalidad]
Dado un juicio de tipado valido $\pi \vdash e : \theta$ y una flecha 
$C \rTo{(h,s)} C'$ en $\C$ se cumple,
\begin{center}
$\semBrcks{\theta}(h,s) \circ \semBrcks{\pi \vdash e : \theta}C$ $=$
$\semBrcks{\pi \vdash e : \theta}C' \circ \semBrcks{\pi}(h,s)$
\end{center}
es decir el diagrama anterior conmuta.

\end{theorem}

\begin{proof}
Procedamos por inducci\'on en la estructura de la derivaci\'on de los juicios de tipado,
supongamos un $\eta : \semBrcks{\pi}C$ y un $\sigma' : C'$ tal que $\sigma : C$,
$\overline{\sigma} : \overline{C}$, $C \concat \overline{C} = C'$ y 
$\sigma \concat \overline{\sigma} = \sigma'$.

\begin{itemize}

\item Casos base
\begin{itemize}
\item Supongamos $\pi \vdash b : \boolexp$, \\

$\semBrcks{\boolexp}(h,s)(\semBrcks{\pi \vdash b : \boolexp}C \ \eta) \sigma'$ $=$
$\semBrcks{\boolexp}(h,s)(\lambda \sigma. \ \iota \ b) \sigma'$ $=$ \\
$((\lambda \sigma. \ \iota \ b) \circ h)\sigma'$ $=$
$(\lambda \sigma. \ \iota \ b) (h \sigma')$ $=$
$\iota \ b$ $=$ $\semBrcks{\pi \vdash b : \boolexp}C'(\semBrcks{\pi}(h,s)\eta)\sigma'$

\item (Analogo $\intexp$ y $\realexp$)

\item Supongamos $\pi \vdash \iota : \theta$,\\

por un lado tenemos,
$\semBrcks{\theta}(h,s)(\semBrcks{\pi \vdash \iota : \theta}C \ \eta)$ $=$
$\semBrcks{\theta}(h,s)(\eta \iota)$ $=$ $(\star)$ \\

y por el otro, $\semBrcks{\pi \vdash \iota : \theta}C'(\semBrcks{\pi}(h,s)\eta)$ $=$
$(\semBrcks{\pi}(h,s)\eta) \iota$ $=$ $(\star \star)$,\\

ahora separamos en casos segundo $\theta$.

\begin{itemize}
\item Supongamos $\theta = \deltaexp$ y $\eta\iota = e$, \\

$(\star)$ $=$ $\eta\iota \circ h$ $=$ $e \circ h$\\

$(\star\star)$ $=$ $e \circ h$, esto ultimo ya que acomodar el ambiente con forma
$C$ a la forma $C'$, es componer con $h$ a todos los valores del tipo $\deltaexp$.

\item Supongamos $\theta = \commt$ y $\eta\iota = c$,\\

$(\star)$ $=$ $s(\eta\iota)$ $=$ $s \ c$\\

$(\star\star)$ $=$ $s \ c$, como para el caso de $\deltaexp$ pero ahora con valores
de tipo $\commt$.

\item Supongamos $\theta = \deltaacc$ y $\eta\iota = a$,\\

$(\star)$ $=$ $s \circ \eta\iota$ $=$ $s \circ a$\\

$(\star\star)$ $=$ $s \circ a$, al igual que para $\commt$ y $\deltaexp$.

\item Supongamos $\theta = \theta_0 \rightarrow \theta_1$ y $\eta \iota = f$,\\

$(\star)$ $=$ $\lambda \widehat{C} . \ (\eta\iota)(\overline{C}\concat\widehat{C})$ $=$ 
$\lambda \widehat{C} . \ f(\overline{C}\concat\widehat{C})$

$(\star\star)$ $=$ $\lambda \widehat{C} . \ f(\overline{C}\concat\widehat{C})$, al igual
que en los casos anteriores.
\end{itemize}
\end{itemize}

\item Casos inductivos
\begin{itemize}
\item Supongamos $\pi \vdash \neg e : \boolexp$,\\

$\semBrcks{\boolexp}(h,s)(\semBrcks{\pi \vdash \neg e : \boolexp}C\eta)\sigma'$ $=$\\
$\semBrcks{\boolexp}(h,s)(\lambda \sigma . \ 
 (\lambda b. \ \iotabot \neg b)_{\dbot}(\semBrcks{\pi \vdash e : \boolexp}C\eta\sigma))\sigma'$ $=$\\
$((\lambda b. \ \iotabot \neg b)_{\dbot}(\semBrcks{\pi \vdash e : \boolexp}C\eta\sigma) 
	\circ 
	h) \sigma'$ $=$ \\
$(\lambda b. \ \iotabot \neg b)_{\dbot}(\semBrcks{\pi \vdash e : \boolexp}C\eta(h\sigma'))$ $=$\\
$(\lambda b. \ \iotabot \neg b)_{\dbot}
	((\semBrcks{\pi \vdash e : \boolexp}C\eta \circ h)\sigma'))$ $=$\\
$(\lambda b. \ \iotabot \neg b)_{\dbot}
	(\semBrcks{\boolexp}(h,s)(\semBrcks{\pi \vdash e : \boolexp}C\eta)\sigma')$\\
	
hasta ac\'a ha sido simplemente reescribir usando definiciones, de esta manera llegamos
a poder aplicar la hip\'otesis inductiva,\\

$(\lambda b. \ \iotabot \neg b)_{\dbot}
	(\semBrcks{\boolexp}(h,s)(\semBrcks{\pi \vdash e :\boolexp}C\eta)\sigma')$ $=$\\
$(\lambda b. \ \iotabot \neg b)_{\dbot}
	(\semBrcks{\pi \vdash e : \boolexp}C(\semBrcks{\pi}(h,s)\eta)\sigma')$ $=$\\
$\semBrcks{\pi \vdash \neg e : \boolexp}C(\semBrcks{\pi}(h,s)\eta)\sigma'$

\item (Analogo operadores binarios)

\item Supongamos $\pi \vdash \cifthenelse{b}{e}{e'} : \theta$, para este caso
nos vamos a enfocar en probar el caso para $\theta = \deltaexp$ ya que los dem\'as
son an\'alogos o incluso iguales pensando en $\commt$.\\

$\semBrcks{\deltaexp}(h,s)
	(\semBrcks{\pi \vdash \cifthenelse{b}{e}{e'} : \deltaexp}C\eta)\sigma'$ $=$\\
$(\semBrcks{\pi \vdash \cifthenelse{b}{e}{e'} : \deltaexp}C\eta \circ h)\sigma'$ $=$\\
$\semBrcks{\pi \vdash \cifthenelse{b}{e}{e'} : \deltaexp}C\eta (h\sigma')$ $=$\\
$(\lambda b . \ if \ b $ $then \ \semBrcks{ \pi \vdash e : \deltaexp}C \ \eta \ (h\sigma')$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
$else \ \semBrcks{ \pi \vdash e' : \deltaexp}C \ \eta \ (h\sigma'))_{\dbot}$ \\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$(\semBrcks{ \pi \vdash b : \boolexp}C \ \eta \ (h\sigma'))$\\

resolviendo el otro lado de la igualdad,\\

$\semBrcks{\pi \vdash \cifthenelse{b}{e}{e'} : \deltaexp}C'
							(\semBrcks{\pi}(h,s)\eta)\sigma'$ $=$\\
$(\lambda b . \ if \ b $ $then \ \semBrcks{ \pi \vdash e : \deltaexp}C' \ 
						(\semBrcks{\pi}(h,s)\eta) \ \sigma'$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
$else \ \semBrcks{ \pi \vdash e' : \deltaexp}C' \ 
						(\semBrcks{\pi}(h,s)\eta) \ \sigma')_{\dbot}$ \\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$(\semBrcks{ \pi \vdash b : \boolexp}C' \ (\semBrcks{\pi}(h,s)\eta) \ \sigma')$\\

ahora vamos a usar hip\'otesis inductiva en el juicio de tipado de $b$,\\

$\semBrcks{ \pi \vdash b : \boolexp}C \ \eta \ (h\sigma')$ $=$
$\semBrcks{ \pi \vdash b : \boolexp}C' \ (\semBrcks{\pi}(h,s)\eta) \ \sigma'$\\

y entonces vamos a suponer que la evaluaci\'on de juicio de tipado
$\pi \vdash b : \boolexp$ es verdadera, luego tenemos que ver que\\

$\semBrcks{ \pi \vdash e : \deltaexp}C \ \eta \ (h\sigma')$ $=$ 
$\semBrcks{ \pi \vdash e : \deltaexp}C' \ (\semBrcks{\pi}(h,s)\eta) \ \sigma'$\\

pero esto es directo usando hip\'otesis inductiva. Por otro lado, si supus\'ieramos
la evaluaci\'on $\pi \vdash b : \boolexp$ es falso, entonces es directo de la misma
manera que antes.

\item Supongamos $\pi \vdash ee' : \theta'$, \\

$\semBrcks{\pi \vdash ee' : \theta'}C'(\semBrcks{\pi}(h,s)\eta)$ $=$\\
$\semBrcks{\pi \vdash e' : \theta \rightarrow \theta'}C'
		(\semBrcks{\pi}(h,s)\eta)\lrangles{}
		(\semBrcks{\pi \vdash e : \theta}C'(\semBrcks{\pi}(h,s)\eta))$ $=$\\
$(\semBrcks{\theta \rightarrow \theta'}(h,s)
	(\semBrcks{\pi \vdash e' : \theta \rightarrow \theta'}C \eta))\lrangles{}
	(\semBrcks{\theta}(h,s)(\semBrcks{\pi \vdash e : \theta}C\eta))$ $=$\\
$\semBrcks{\pi \vdash e' : \theta \rightarrow \theta'}C \eta \overline{C}
	(\semBrcks{\theta}(h,s)(\semBrcks{\pi \vdash e : \theta}C\eta))$\\

hasta ac\'a usamos la definici\'on de la ecuaci\'on sem\'antica de la aplicaci\'on,
aplicamos hip\'otesis inductiva dos veces y usamos la definici\'on del funtor
$\semBrcks{\theta \rightarrow \theta'}$ aplicado a $(h,s)$ y 
$(\semBrcks{\pi \vdash e' : \theta \rightarrow \theta'}C \eta)$, donde 
$\overline{C}$ es tal que $C \concat \overline{C} = C'$.\\
Ahora si analizamos un poco mas la definici\'on de este funtor que mencion\'abamos
nos damos cuenta que $\semBrcks{\pi \vdash e' : \theta \rightarrow \theta'}C \eta$
es una transformaci\'on natural indexada por objetos de $\C$ que va del funtor
$\semBrcks{\theta}$ al funtor $\semBrcks{\theta'}$, luego el siguiente diagrama
debe conmutar,

\begin{center}
\begin{diagram}
   \semBrcks{\theta}C & & \rTo^{\semBrcks{\pi \vdash e' : \theta \rightarrow \theta'}C \eta \lrangles{}} & & \semBrcks{\theta'}C \\
   \dTo^{\semBrcks{\theta}(h,s)} & & & & \dTo^{\semBrcks{\theta'}(h,s)} & \\
   \semBrcks{\theta}C' & & \rTo^{\semBrcks{\pi \vdash e' :  \theta \rightarrow \theta'}C' \eta \overline{C}} & & \semBrcks{\theta'}C' &
\end{diagram}
\end{center}

es decir, la conmutatividad del diagrama anterior nos da la siguiente igualdad,\\

$\semBrcks{\theta'}(h,s) 
\circ 
\semBrcks{\pi \vdash e' \theta \rightarrow \theta'}C\eta\lrangles{}$ $=$
$\semBrcks{\pi \vdash e' \theta \rightarrow \theta'}C\eta\overline{C} 
\circ
\semBrcks{\theta}(h,s) 
$\\

luego usando esta igualdad obtenemos,\\

$\semBrcks{\pi \vdash e' : \theta \rightarrow \theta'}C \eta \overline{C}
	(\semBrcks{\theta}(h,s)(\semBrcks{\pi \vdash e : \theta}C\eta))$ $=$\\
$\semBrcks{\theta'}(h,s)(
\semBrcks{\pi \vdash e' \theta \rightarrow \theta'}C\eta\lrangles{} 
(\semBrcks{\pi \vdash e \theta}\C\eta))$ $=$\\
$\semBrcks{\theta'}(h,s)(\semBrcks{\pi \vdash ee' : \theta'}C\eta)$\\

\item Supongamos $\pi \vdash \rec{e} : \theta$, desarrollemos ambos lados de la
igualdad y luego probemos que los lados desarrollados son iguales, por un lado
entonces tenemos,\\

$\semBrcks{\theta}(h,s)(\semBrcks{\pi \vdash \rec{e} : \theta}C\eta)$ $=$\\
$\semBrcks{\theta}(h,s)(
	\Y_{\semBrcks{\theta}C} 
		(\semBrcks{\pi \vdash e : \theta \rightarrow \theta}C\eta) \lrangles{})$ $=$\\
$\semBrcks{\theta}(h,s)(
\bigsqcup\limits^{\infty}_{i=0} (
	(\semBrcks{\pi \vdash e : \theta \rightarrow \theta}C\eta\lrangles{})^i \bot_{\theta,C})
)$ $=$\\
$\bigsqcup\limits^{\infty}_{i=0}(
\semBrcks{\theta}(h,s)(
	(\semBrcks{\pi \vdash e : \theta \rightarrow \theta}C\eta\lrangles{})^i \bot_{\theta,C})
)$\\

y por el otro, notar que para este lado vamos a usar la hip\'otesis inductiva, tenemos\\

$\semBrcks{\pi \vdash \rec{e} : \theta}C'(\semBrcks{\pi}(h,s)\eta)$ $=$ \\
$\Y_{\semBrcks{\theta}C'}(
\semBrcks{\pi \vdash e : \theta \rightarrow \theta}C'(\semBrcks{\pi}(h,s)\eta)
)\lrangles{}$ $=$\\
$\Y_{\semBrcks{\theta}C'}(
\semBrcks{\theta \rightarrow \theta}(h,s) 
	(\semBrcks{\pi \vdash e : \theta \rightarrow \theta}C\eta)
)\lrangles{}$ $=$\\
$\bigsqcup\limits^{\infty}_{i=0}(
(\semBrcks{\theta \rightarrow \theta}(h,s) 
	(\semBrcks{\pi \vdash e : \theta \rightarrow \theta}C\eta)\lrangles{})^i \bot_{\theta,C'}
)$ $=$\\
$\bigsqcup\limits^{\infty}_{i=0}(
(\semBrcks{\theta \rightarrow \theta}(h,s) 
	(\semBrcks{\pi \vdash e : \theta \rightarrow \theta}C\eta)\lrangles{})^i 
				(\semBrcks{\theta}(h,s)\bot_{\theta,C})
)$ $=$\\
$\bigsqcup\limits^{\infty}_{i=0}(
(\semBrcks{\pi \vdash e : \theta \rightarrow \theta}C\eta\Cover)^i 
				(\semBrcks{\theta}(h,s)\bot_{\theta,C})
)$\\

sobre esta ultima ecuaci\'on es importante notar que 
$\bot_{\theta,C'} = \semBrcks{\theta}(h,s) \bot_{\theta,C}$, por ser $\semBrcks{\theta}(h,s)$
una funci\'on estricta. Ahora bien, para probar la igualdad de las ecuaciones desarrolladas
vamos a utilizar, como ya hicimos para el caso de la aplicaci\'on, el hecho de que\\
$\semBrcks{\pi \vdash e : \theta \rightarrow \theta}C\eta : 
\semBrcks{\theta \rightarrow \theta}C$ es una transformaci\'on natural, luego el siguiente
diagrama conmuta

\begin{center}
\begin{diagram}
   \semBrcks{\theta}C & & \rTo^{\semBrcks{\pi \vdash e : \theta \rightarrow \theta}C \eta \lrangles{}} & & \semBrcks{\theta}C \\
   \dTo^{\semBrcks{\theta}(h,s)} & & & & \dTo^{\semBrcks{\theta}(h,s)} & \\
   \semBrcks{\theta}C' & & \rTo^{\semBrcks{\pi \vdash e :  \theta \rightarrow \theta}C \eta \Cover} & & \semBrcks{\theta}C' &
\end{diagram}
\end{center}

podemos concluir entonces que \\

$\bigsqcup\limits^{\infty}_{i=0}(
\semBrcks{\theta}(h,s)(
	(\semBrcks{\pi \vdash e : \theta \rightarrow \theta}C\eta\lrangles{})^i \bot_{\theta,C})
)$ $=$\\
$\bigsqcup\limits^{\infty}_{i=0}(
(\semBrcks{\pi \vdash e : \theta \rightarrow \theta}C\eta\Cover)^i 
				(\semBrcks{\theta}(h,s)\bot_{\theta,C})
)$\\

\item Supongamos $\pi \vdash \cskip : \commt$,\\

$\semBrcks{\commt}(h,s)(\semBrcks{\pi \vdash \cskip}C\eta)\sigma'$ $=$
$s(\semBrcks{\pi \vdash \cskip}C\eta)\sigma'$ $=$\\
$s(\lambda \sigma . \ \iotabot \sigma)\sigma'$ $=$
$(\lambda \sigmahat . \ (\lambda \sigma. \ 
			\sigma \concat tail_{\overline{C}}\sigmahat)_{\bot}
		((\lambda \sigma . \ \iotabot \sigma)(h \sigmahat)))\sigma'$ $=$\\
$(\lambda \sigma. \ \sigma \concat tail_{\overline{C}}\sigma')_{\bot}
		((\lambda \sigma . \iotabot \sigma)(head_{C} \sigma'))$ $=$\\
$\iotabot (head_{C} \sigma' \concat tail_{\overline{C}}\sigma')$ $=$ $\iotabot \sigma'$ $=$
$\semBrcks{\pi \vdash \cskip : \commt}C'(\semBrcks{\pi}(h,s)\eta)\sigma'$\\

\item Supongamos $\pi \vdash \cseq{e}{e'} : \commt$,\\

$\semBrcks{\commt}(h,s)(\semBrcks{\pi \vdash \cseq{e}{e'} : \commt}C\eta)$ $=$\\
$\semBrcks{\commt}(h,s)
	((\semBrcks{\pi \vdash e' : \commt}C\eta)_{\dbot} 
	\circ
	\semBrcks{\pi \vdash e : \commt}C\eta
	)$ $=$ \\
$s((\semBrcks{\pi \vdash e' : \commt}C\eta)_{\dbot} 
	\circ
	\semBrcks{\pi \vdash e : \commt}C\eta
	)$\\

ahora usando la proposici\'on 3 podemos reescribir de la siguiente manera,\\

$s((\semBrcks{\pi \vdash e' : \commt}C\eta)_{\dbot} 
	\circ
	\semBrcks{\pi \vdash e : \commt}C\eta
	)$ $=$\\
$s(\semBrcks{\pi \vdash e' : \commt}C\eta)_{\dbot} 
	\circ
	s(\semBrcks{\pi \vdash e : \commt}C\eta)$ $=$\\
$\semBrcks{\commt}(h,s)(\semBrcks{\pi \vdash e' : \commt}C\eta)_{\dbot} 
	\circ
 \semBrcks{\commt}(h,s)(\semBrcks{\pi \vdash e : \commt}C\eta)$\\

usando ahora hip\'otesis inductiva dos veces obtenemos,\\

$\semBrcks{\commt}(h,s)(\semBrcks{\pi \vdash e' : \commt}C\eta)_{\dbot} 
	\circ
 \semBrcks{\commt}(h,s)(\semBrcks{\pi \vdash e : \commt}C\eta)$ $=$\\
$\semBrcks{\pi \vdash e' : \commt}C'(\semBrcks{\pi}(h,s)\eta)_{\dbot}
	\circ
\semBrcks{\pi \vdash e : \commt}C'(\semBrcks{\pi}(h,s)\eta)$ $=$\\
$\semBrcks{\pi \vdash \cseq{e}{e'} : \commt}C'(\semBrcks{\pi}(h,s)\eta)$\\

\item Supongamos $\pi \vdash \cwhiledo{b}{e} : \commt$, para este caso
recordamos que $\sigma \concat \overline{\sigma} = \sigma'$,\\

$\semBrcks{\commt}(h,s)(\semBrcks{\pi \vdash \cwhiledo{b}{e} : \commt}C\eta)\sigma'$ $=$\\
$s(\semBrcks{\pi \vdash \cwhiledo{b}{e} : \commt}C\eta)\sigma'$ $=$\\
$(\lambda \sigma. \ \sigma \concat \sigmaover)_{\bot}
				(\semBrcks{\pi \vdash \cwhiledo{b}{e} : \commt}C \ \eta \ \sigma)$\\

olvid\'emonos por un momento de $(\lambda \sigma. \ \sigma \concat \sigmaover)_{\bot}$
y analicemos $\semBrcks{\pi \vdash \cwhiledo{b}{e} : \commt}C \ \eta \ \sigma$, utilizando
la definici\'on de la ecuaci\'on\\

$\semBrcks{\pi \vdash \cwhiledo{b}{e} : \commt} C \eta \sigma$ $=$ \\
\indent \ \ \ \ \ \ \ \
$\Y_{\semBrcks{\commt}C} (\lambda c . \lambda \sigma . (\lambda b . if \ b$ \\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$then \ c_{\dbot}(\semBrcks{\pi \vdash e : \commt}C \eta \sigma)$ \\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$else \ \iotabot \sigma)_{\dbot} (\semBrcks{\pi \vdash b : \boolexp}C\eta\sigma))\sigma$ \\

podemos notar que si el comando eval\'ua a un $\iotabot\sigmahat$, es porque 
existieron evaluaciones de $\semBrcks{\pi \vdash e : \commt}C \eta \sigma$
con resultados $\sigma_0, \sigma_1, \ldots, \sigma_n, \sigmahat$. Adem\'as 
el resultado de la evaluaci\'on completa ser\'a ,
$(\lambda \sigma. \ \sigma \concat \sigmaover)_{\bot} \iotabot \sigmahat$ $=$
$\iotabot (\sigmahat \concat \sigmaover)$, es decir, solamente modificamos la parte del estado
con forma $C$. Tomemos ahora el otro lado de la igualdad que queremos probar,\\

$\semBrcks{\pi \vdash \cwhiledo{b}{e} : \commt} C' (\semBrcks{\pi}(h,s)\eta) \sigma'$ $=$ \\
\indent \ \ \ \ \ \ \ \
$\Y_{\semBrcks{\commt}C'} (\lambda c' . \lambda \sigma' . (\lambda b . if \ b$ \\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$then \ c'_{\dbot}(\semBrcks{\pi \vdash e : \commt}C'(\semBrcks{\pi}(h,s)\eta) \sigma')$ \\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$else \ \iotabot \sigma')_{\dbot} 
	(\semBrcks{\pi \vdash b : \boolexp}C'(\semBrcks{\pi}(h,s)\eta)\sigma'))\sigma'$ \\

luego aplicando hip\'otesis inductiva en los juicios de tipado de $b$ y $e$ y reescribiendo
un poco las ecuaciones obtenemos,\\

$\semBrcks{\pi \vdash \cwhiledo{b}{e} : \commt} C' (\semBrcks{\pi}(h,s)\eta) \sigma'$ $=$ \\
\indent \ \ \ \ \ \ \ \
$\Y_{\semBrcks{\commt}C'} (\lambda c' . \lambda \sigma' . (\lambda b . if \ b$ \\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$then \ c'_{\dbot}((\lambda \sigma. \ \sigma \concat \sigmaover)_{\bot}
					\semBrcks{\pi \vdash e : \commt}C \eta \sigma)$ \\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$else \ \iotabot \sigma')_{\dbot} 
	(\semBrcks{\pi \vdash b : \boolexp}C \eta \sigma))\sigma'$ \\
	
ahora vamos a suponer, como antes, que existieron evaluaciones de 
$\semBrcks{\pi \vdash e : \commt}C \eta \sigma$
con resultados $\sigma_0, \sigma_1, \ldots, \sigma_n, \sigmahat$, luego
aplicar cada $\sigma_i$ a $(\lambda \sigma . \ \sigma \concat \sigmaover)$ nos
genera la sucesi\'on de resultados 
$\sigma_0\concat\sigmaover, \sigma_1\concat\sigmaover, \ldots, 
\sigma_n\concat\sigmaover, \sigmahat\concat\sigmaover$, por lo tanto el resultado
de evaluar el comando completo es $\iotabot (\sigmahat\concat\sigmaover)$.

\item Supongamos $\pi \vdash \assig{a}{e} : \commt$, empecemos desarrollando cada
extremo de la igualdad que queremos probar,\\

$\semBrcks{\commt}(h,s)(\semBrcks{\pi \vdash \assig{a}{e} : \commt}C\eta)\sigma'$ $=$\\
$(\lambda \sigma. \ \sigma \concat \sigmaover)_{\bot}
				(\semBrcks{\pi \vdash \assig{a}{e} : \commt}C\eta\sigma)$ $=$\\
$(\lambda \sigma. \ \sigma \concat \sigmaover)_{\bot}(
	(\lambda v. \ \semBrcks{\pi \vdash a : \deltaacc}C\eta \ v \ \sigma)_{\dbot}
	(\semBrcks{\pi \vdash e : \deltaexp}C\eta\sigma))$\\
	
$\semBrcks{\pi \vdash \assig{a}{e} : \commt}C'(\semBrcks{\pi}(h,s)\eta)\sigma'$ $=$\\
$(\lambda v. \ 
	\semBrcks{\pi \vdash a : \deltaacc}C'(\semBrcks{\pi}(h,s)\eta)\ v \ \sigma')_{\dbot}$
$(\semBrcks{\pi \vdash e : \deltaexp}C'(\semBrcks{\pi}(h,s)\eta)\sigma')$ \\

usando hip\'otesis inductiva dos veces obtenemos por un lado,\\

$\semBrcks{\pi \vdash a : \deltaacc}C'(\semBrcks{\pi}(h,s)\eta)\ v \ \sigma'$ $=$\\
$\semBrcks{\deltaacc}(h,s)(\semBrcks{\pi \vdash a : \deltaacc}C\eta) v \ \sigma'$ $=$
$s(\semBrcks{\pi \vdash a : \deltaacc} C \eta \ v)\sigma'$ $=$\\
$(\lambda \sigma . \sigma \concat \sigmaover)_{\bot}
				(\semBrcks{\pi \vdash a : \deltaacc} C \eta \ v \ \sigma)$
				
y por otro lado,\\

$\semBrcks{\pi \vdash e : \deltaexp}C'(\semBrcks{\pi}(h,s)\eta)\sigma'$ $=$\\
$\semBrcks{\deltaexp}(h,s)(\semBrcks{\pi \vdash e : \deltaexp}C \eta)\sigma'$ $=$
$(\semBrcks{\pi \vdash e : \deltaexp}C \eta \circ h)\sigma'$ $=$\\
$\semBrcks{\pi \vdash e : \deltaexp}C \eta \sigma$\\

usando estos dos resultados que acabamos de deducir, pasando en limpio tenemos\\

$(\lambda v. \ 
	\semBrcks{\pi \vdash a : \deltaacc}C'(\semBrcks{\pi}(h,s)\eta)\ v \ \sigma')_{\dbot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$(\semBrcks{\pi \vdash e : \deltaexp}C'(\semBrcks{\pi}(h,s)\eta)\sigma')$ $=$\\
$(\lambda v. \ (\lambda \sigma . \sigma \concat \sigmaover)_{\bot}
				(\semBrcks{\pi \vdash a : \deltaacc} C \eta \ v \ \sigma))_{\dbot}$
$(\semBrcks{\pi \vdash e : \deltaexp}C \eta \sigma)$ \\

luego podemos suponer $\semBrcks{\pi \vdash e : \deltaexp}C \eta \sigma$ $=$ $\iotabot v$ distinto
de $\bot$,\\

$(\lambda \sigma . \sigma \concat \sigmaover)_{\bot}
				(\semBrcks{\pi \vdash a : \deltaacc} C \eta \ v \ \sigma)$ $=$\\
$(\lambda \sigma . \sigma \concat \sigmaover)_{\bot}
	((\semBrcks{\pi \vdash a : \deltaacc} C \eta \ v \ \sigma)_{\dbot}
			(\semBrcks{\pi \vdash e : \deltaexp}C \eta \sigma))$ $=$\\
$\semBrcks{\commt}(h,s)(\semBrcks{\pi \vdash \assig{a}{e} : \commt}C\eta)\sigma'$\\

\item Supongamos $\pi \vdash \clambda{\iota}{\theta}{\ e} : \theta \rightarrow \theta'$, tomemos
$\Chat$ objeto de $\C$ y un $z : \semBrcks{\theta}(C'\concat\Chat)$ \\

$\semBrcks{\theta \rightarrow \theta'}(h,s)
(\semBrcks{\pi \vdash 
	\clambda{\iota}{\theta}{\ e} : \theta \rightarrow \theta'}C \eta)\Chat \ z$ $=$\\
$\semBrcks{\pi \vdash \clambda{\iota}{\theta}{\ e} : \theta \rightarrow \theta'}C 
	\eta (\Cover \concat \Chat) \ z$ $=$\\
$\semBrcks{\pi,\iota:\theta \vdash e : \theta'}
	(C \concat \Cover \concat \Chat)
	[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:z \ ]$ $=$\\
$\semBrcks{\pi,\iota:\theta \vdash e : \theta'}
	(C' \concat \Chat)
	[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:z \ ]$ $=$\\

ahora bien, empezamos notando que el operador $\concat$ es asociativo por lo tanto
$(C \concat (\Cover \concat \Chat)) = (C' \concat \Chat)$, luego adem\'as
$(\hover,\sover) : C \rTo (C \concat \Cover \concat \Chat)$, y por lo tanto
$(\hover,\sover) : C \rTo (C' \concat \Chat)$.\\

$\semBrcks{\pi \vdash \clambda{\iota}{\theta}{\ e} : \theta \rightarrow \theta'}
		C'(\semBrcks{\pi}(h,s)\eta)\Chat \ z$ $=$\\
$\semBrcks{\pi,\iota:\theta \vdash e : \theta'}(C' \concat \Chat)
			[ \ \semBrcks{\pi}(h',s')(\semBrcks{\pi}(h,s)\eta) \ | \ \iota:z \ ]$\\

donde $(h',s') : C' \rTo (C' \concat \Chat)$,
ahora si prestamos atenci\'on a las dos expresiones finales que nos quedaron, nos 
damos cuenta que ya casi estar\'iamos si no fuera por la forma en que acomodamos
el ambiente, el plan entonces ser\'a probar que $(\hover,\sover) = (h \circ h',s'\circ s)$
donde por definici\'on $(h \circ h',s'\circ s) = (h',s') \circ (h,s)$, luego usando
que $\semBrcks{\pi}$ podemos concluir,

\begin{center}
$\semBrcks{\pi}(\hover,\sover)$ $=$ $\semBrcks{\pi}(h',s') \circ \semBrcks{\pi}(h,s)$
\end{center}

Empecemos probando que $\hover = h \circ h'$, tomamos un estado 
$\sigma \concat \sigmaover \concat \sigmahat$ con forma $C' \concat \Chat$\\

$\hover : (C' \concat \Chat) \rightarrow C$\\
$\hover (\sigma \concat \sigmaover \concat \sigmahat)$ $=$ 
$head_{C} (\sigma \concat \sigmaover \concat \sigmahat)$ $=$ $\sigma$\\

$h : C' \rightarrow C$\\
$h' : (C' \concat \Chat) \rightarrow C'$\\
$(h \circ h') (\sigma \concat \sigmaover \concat \sigmahat)$ $=$
$head_{C}(head_{C'} (\sigma \concat \sigmaover \concat \sigmahat))$ $=$\\
$head_{C}(\sigma \concat \sigmaover)$ $=$ $\sigma$\\

probemos ahora $\sover = s' \circ s$, tomemos $c : C \rightarrow C_\bot$ y
suponemos $c \sigma = \iotabot \sigmatil$\\

$\sover : (C \rightarrow C_\bot) \rightarrow 
		  ((C' \concat \Chat) \rightarrow (C' \concat \Chat)_\bot)$\\
$\sover \ c \ (\sigma \concat \sigmaover \concat \sigmahat)$ $=$
$(\lambda \sigma . \ 
	\sigma \concat (\sigmaover \concat \sigmahat))_{\bot} (c \sigma)$ $=$\\
$\iotabot (\sigmatil \concat \sigmaover \concat \sigmahat)$\\

$s : (C \rightarrow C_\bot) \rightarrow (C' \rightarrow C'_\bot)$\\
$s' : (C' \rightarrow C'_\bot) \rightarrow 
   	  ((C' \concat \Chat) \rightarrow (C' \concat \Chat)_\bot)$\\
$(s' \circ s) \ c \ (\sigma \concat \sigmaover \concat \sigmahat)$ $=$
$s' (s \ c) (\sigma \concat \sigmaover \concat \sigmahat)$ $=$\\
$(\lambda \sigma. \ \sigma \concat \sigmahat)_{\bot}
	(s \ c \ (\sigma \concat \sigmaover))$ $=$\\
$(\lambda \sigma . \ \sigma \concat \sigmahat)_{\bot}
((\lambda \sigma . \ \sigma \concat \sigmaover)_{\bot}(c \sigma))$ $=$\\
$(\lambda \sigma . \ \sigma \concat \sigmahat)_{\bot}
(\iotabot (\sigmatil \concat \sigmaover))$ $=$ 
$\iotabot (\sigmatil \concat \sigmaover \concat \sigmahat)$\\

por lo tanto $(\hover,\sover) = (h \circ h',s'\circ s)$.\\

\item Supongamos $\pi \vdash \newdeltavar{\iota}{ei}{c} : \commt$, la estrategia para
este juicio de tipado ser\'a, resolver por completo un lado haciendo un par de suposiciones
hasta llegar a un estado y luego tomar el lado restante para llegar, usando las suposiciones,
a este mismo estado. Para esto entonces suponemos dos cosas relevantes,

\begin{itemize}
\item $\semBrcks{\pi \vdash ei : \deltaexp}C\eta\sigma = \iotabot v$
\item $\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]
(\sigma\concat \lrangles{v})$ $=$ $\iotabot (\sigmatil \concat \lrangles{\tilde{v}})$
\end{itemize}

\

$\semBrcks{\commt}(h,s)(\semBrcks{\pi \vdash \newdeltavar{\iota}{ei}{c} : \commt}C\eta)\sigma'$ $=$\\
$s (\lambda \sigma . \ \Hbot ((\lambda v .$ \\
\indent \ \ 
	$\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
			$[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]
			(\sigma\concat \lrangles{v}))_{\dbot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
		$(\semBrcks{\pi \vdash ei : \deltaexp}C\eta\sigma)) ) \sigma'$ $=$\\
$(\lambda \sigma . \ \sigma \concat \sigmaover)_{\bot}({head_{C}}_{\bot} ((\lambda v .$ \\
\indent \ \ 
	$\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
			$[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]
			(\sigma\concat \lrangles{v}))_{\dbot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
		$(\semBrcks{\pi \vdash ei : \deltaexp}C\eta\sigma)))$ $=$\\
$(\lambda \sigma . \ \sigma \concat \sigmaover)_{\bot}({head_{C}}_{\bot} ($ \\
\indent \ \ 
	$\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
			$[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]
			(\sigma\concat \lrangles{v})))$ $=$\\
$(\lambda \sigma . \ \sigma \concat \sigmaover)_{\bot}
({head_{C}}_{\bot} (\iotabot (\sigmatil \concat \lrangles{\tilde{v}})))$ $=$\\
$((\lambda \sigma . \ \sigma \concat \sigmaover) \circ
head_{C})_{\bot} (\iotabot (\sigmatil \concat \lrangles{\tilde{v}}))$ $=$\\
$\iotabot (\sigmatil \concat \sigmaover)$\\

detallando ahora los tipos de algunos componentes que van a ser relevantes
mas adelante tenemos,\\

$a : S_\delta \rightarrow 
(C \concat \lrangles{S_\delta}) \rightarrow (C \concat \lrangles{S_\delta})_{\bot}$\\
$e : (C \concat \lrangles{S_\delta}) \rightarrow (S_\delta)_{\bot}$\\
$(\hover,\sover) : C \rTo (C \concat \lrangles{S_\delta})$\\

ahora continuemos con el otro extremo de la igualdad que queremos probar, teniendo 
siempre en cuenta las suposiciones que hicimos al principio de este caso\\

$\semBrcks{\pi \vdash \newdeltavar{\iota}{ei}{c} : \commt}C'(\semBrcks{\pi}(h,s)\eta)\sigma'$ $=$\\
${head_{C'}}_{\bot} ((\lambda v .$ \\
\indent \ \ 
	$\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C' \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
			$[ \ \semBrcks{\pi}(h',s')(\semBrcks{\pi}(h,s)\eta) \ | \ \iota:\lrangles{a',e'} \ ]
			(\sigma' \concat \lrangles{v}))_{\dbot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
	$(\semBrcks{\pi \vdash ei : \deltaexp}C'(\semBrcks{\pi}(h,s)\eta)\sigma'))$\\
	
donde $a' : S_\delta \rightarrow (C' \concat \lrangles{S_\delta}) 
			\rightarrow (C' \concat \lrangles{S_\delta})_{\bot}$\\
$e' : (C' \concat \lrangles{S_\delta}) \rightarrow (S_\delta)_\bot$\\
$(h',s') : C' \rTo (C' \concat \lrangles{S_\delta})$\\

si nos enfocamos en la expresi\'on 
$\semBrcks{\pi \vdash ei : \deltaexp}C'(\semBrcks{\pi}(h,s)\eta)\sigma'$ nos damos cuenta
que podemos aplicar hip\'otesis inductiva, de manera tal que nos quede\\

$\semBrcks{\pi \vdash ei : \deltaexp}C'(\semBrcks{\pi}(h,s)\eta)\sigma'$ $=$\\
$\semBrcks{\deltaexp}(h,s)(\semBrcks{\pi \vdash ei : \deltaexp}C\eta)\sigma'$ $=$\\
$(\semBrcks{\pi \vdash ei : \deltaexp}C\eta \circ head_C) \sigma'$ $=$\\
$\semBrcks{\pi \vdash ei : \deltaexp}C\eta\sigma$ $=$ $\iotabot v$\\

podemos utilizar este resultado entonces para ir reescribiendo\\

${head_{C'}}_{\bot} ((\lambda v .$ \\
\indent \ \ 
	$\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C' \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
			$[ \ \semBrcks{\pi}(h',s')(\semBrcks{\pi}(h,s)\eta) \ | \ \iota:\lrangles{a',e'} \ ]
			(\sigma' \concat \lrangles{v}))_{\dbot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ 
	$(\semBrcks{\pi \vdash ei : \deltaexp}C'(\semBrcks{\pi}(h,s)\eta)\sigma'))$ $=$\\
${head_{C'}}_{\bot} 
	(\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C' \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
			$[ \ \semBrcks{\pi}(h',s')(\semBrcks{\pi}(h,s)\eta) \ | \ \iota:\lrangles{a',e'} \ ]
			(\sigma' \concat \lrangles{v}))$\\
			
llegado este punto, para continuar, lo ideal ser\'ia poder hacer algo parecido
a lo que hicimos hace un instante para evaluar el juicio de tipado de $ei$ el problema
que surge es que no podemos aplicar hip\'otesis inductiva porque nuestro ambiente
no tiene la forma correcta, es decir, nosotros quisi\'eramos que el ambiente
fuera algo de la forma $\semBrcks{\pi,\iota:\deltavar}(\hhat,\shat)\widehat{\eta}$, pero
adem\'as no con cualquiera $\widehat{\eta}$, si no que este sea
$[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]$. 
En resumen, quisi\'eramos que la siguiente igualdad valga

\begin{center}
$\semBrcks{\pi,\iota:\deltavar}(\hhat,\shat)
([ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ])$\\ 
$=$\\
$[ \ \semBrcks{\pi}(h',s')(\semBrcks{\pi}(h,s)\eta) \ | \ \iota:\lrangles{a',e'} \ ]$
\end{center}

donde
$(\hhat,\shat) : (C\concat\lrangles{S_\delta}) \rTo (C'\concat\lrangles{S_\delta})$ 

as\'i que vamos a hacer lo siguiente, vamos a suponer esta igualdad vale, completar la prueba
y para finalizar probaremos la igualdad. Pero antes, nos falta el detalle importante sobre
como son las funciones de la flecha $(\hhat,\shat)$, es decir, en general para cualquier
flecha com\'un podemos saber quienes son las funciones viendo el tipo de la flecha, pero
en particular el tipo de esta flecha no es una simple extensi\'on, presentemos la definici\'on
de cada una\\

$\hhat : (C'\concat\lrangles{S_\delta}) \rightarrow (C\concat\lrangles{S_\delta})$\\
$\hhat \ \sigma = head_{C} (head_{C'}\sigma) \concat tail_{\lrangles{S_{\delta}}}\sigma$\\
$\shat : ((C\concat\lrangles{S_\delta}) \rightarrow (C\concat\lrangles{S_\delta})_{\bot}) 
		 \rightarrow
		 ((C'\concat\lrangles{S_\delta}) \rightarrow (C'\concat\lrangles{S_\delta})_{\bot})$
$\shat \ f \ \sigma = (\lambda \sigma_{v} . \  
				(\hover \sigma_{v}) \concat 
				tail_{\Cover}(tail_{C'}\sigma) \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot} (f (\hhat \sigma))$\\

Entonces, reescribiendo utilizando la igualdad tenemos\\

${head_{C'}}_{\bot}
	(\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C' \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
			$[ \ \semBrcks{\pi}(h',s')(\semBrcks{\pi}(h,s)\eta) \ | \ \iota:\lrangles{a',e'} \ ]
			(\sigma' \concat \lrangles{v}))$ $=$\\
${head_{C'}}_{\bot}
	 (\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C' \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
			$(\semBrcks{\pi,\iota:\deltavar}(\hhat,\shat)
			([ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]))
			(\sigma' \concat \lrangles{v}))$ $=$\\
${head_{C'}}_{\bot}
	(\semBrcks{\commt}(\hhat,\shat)
			(\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
			$[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ])
			(\sigma' \concat \lrangles{v}))$ $=$\\
${head_{C'}}_{\bot}
	(\shat (\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
			$[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ])
			(\sigma' \concat \lrangles{v}))$ $=$\\
${head_{C'}}_{\bot}($\\
$(\lambda \sigma_{v} . \  
				(\hover \sigma_{v}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{v})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot}$ \\
\indent \ \ \ \ \ \ \ \
$(\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]) 
(\hhat (\sigma' \concat \lrangles{v}))))$ $=$\\
${head_{C'}}_{\bot}($\\
$(\lambda \sigma_{v} . \  
				(\hover \sigma_{v}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{v})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot}$ \\
\indent \ \ \ \ \ \ \ \
$(\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]) 
(\sigma \concat \lrangles{v})))$\\

y por fin estamos en condiciones de reescribir usando la segunda suposici\'on sobre
el juicio de tipado de $c$\\

${head_{C'}}_{\bot}($\\
$(\lambda \sigma_{v} . \  
				(\hover \sigma_{v}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{v})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot}$ \\
\indent \ \ \ \ \ \ \ \
$(\semBrcks{\pi,\iota:\deltavar \vdash c : \commt}(C \concat \lrangles{S_\delta})$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$[ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]) 
(\sigma \concat \lrangles{v})))$ $=$\\
${head_{C'}}_{\bot}($\\
$(\lambda \sigma_{v} . \
				(\hover \sigma_{v}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{v})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot}$ \\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
  \ \ \ \ \ \ \ \ \ \
$(\iotabot (\sigmatil \concat \lrangles{\tilde{v}})))$ $=$\\
${head_{C'}}_{\bot}($\\
$(\lambda \sigma_{v} . \
				(\hover \sigma_{v}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{v})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot}$ \\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
  \ \ \ \ \ \ \ \ \ \
$(\iotabot (\sigmatil \concat \lrangles{\tilde{v}})))$ $=$\\
${head_{C'}}_{\bot}($
$(\lambda \sigma_{v} . \
				(\hover \sigma_{v}) \concat 
				\sigmaover \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot}$
$(\iotabot (\sigmatil \concat \lrangles{\tilde{v}})))$ $=$\\
$(head_{C'}$
$\circ$
$(\lambda \sigma_{v} . \
				(\hover \sigma_{v}) \concat 
				\sigmaover \concat
				tail_{\lrangles{S_\delta}}\sigma_{v}))_{\bot}$
$(\iotabot (\sigmatil \concat \lrangles{\tilde{v}}))$ $=$\\
$\iotabot (head_{C'} (\sigmatil \concat \sigmaover \concat \lrangles{\tilde{v}}))$ $=$
$\iotabot (\sigmatil \concat \sigmaover)$\\

por lo tanto, hemos probado la igualdad para el caso del $\cnew \deltavar$. Nos resta 
probar entonces la suposici\'on que hicimos sobre los ambientes, recordando deber\'iamos
probar\\

\begin{center}
$\semBrcks{\pi,\iota:\deltavar}(\hhat,\shat)
([ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ])$\\ 
$=$\\
$[ \ \semBrcks{\pi}(h',s')(\semBrcks{\pi}(h,s)\eta) \ | \ \iota:\lrangles{a',e'} \ ]$
\end{center}

Supongamos un $\kappa$ identificador y dos valores $v$ y $x$ en $S_\delta$, cualesquiera

\begin{itemize}
\item S\'i $\kappa = \iota$, \\

$(\semBrcks{\pi,\iota:\deltavar}(\hhat,\shat)
([ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]))\kappa$ $=$\\
$\semBrcks{(\pi,\iota:\deltavar) \kappa}(\hhat,\shat)\lrangles{a,e}$ $=$\\
$\lrangles{\semBrcks{\deltavar}(\hhat,\shat)a,\semBrcks{\deltavar}(\hhat,\shat)e}$\\

$[ \ \semBrcks{\pi}(h',s')(\semBrcks{\pi}(h,s)\eta) \ | \ \iota:\lrangles{a',e'} \ ] \kappa$ $=$
$\lrangles{a',e'}$\\

probemos ahora que $a' = \semBrcks{\deltavar}(\hhat,\shat)a$ y 
$e' = \semBrcks{\deltavar}(\hhat,\shat)e$\\

$\semBrcks{\deltavar}(\hhat,\shat) \ e \ (\sigma \concat \sigmaover \concat \lrangles{v})$ $=$
$e \ (\hhat (\sigma \concat \sigmaover \concat \lrangles{v}))$ $=$\\
$\iotabot (last_{S_\delta} (\sigma \concat \lrangles{v}))$ $=$ $\iotabot \ v$ $=$
$\iotabot (last_{S_\delta} (\sigma \concat \sigmaover \concat \lrangles{v}))$ $=$ \\
$e' (\sigma \concat \sigmaover \concat \lrangles{v})$\\

$\semBrcks{\deltavar}(\hhat,\shat) \ a \ x \ (\sigma \concat \sigmaover \concat \lrangles{v})$ $=$
$\shat (a \ x) (\sigma \concat \sigmaover \concat \lrangles{v})$ $=$\\
$(\lambda \sigma_{x} . \  \iotabot (
				(\hover \sigma_{x}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{x})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{x}))_{\dbot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$((a \ x)(\hhat (\sigma \concat \sigmaover \concat \lrangles{v})))$ $=$\\
$(\lambda \sigma_{x} . \  \iotabot (
				(\hover \sigma_{x}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{x})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{x}))_{\dbot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ 
$(\lambda \sigma. \ \iotabot \ 
		head_{C}\sigma \concat \lrangles{x})(\sigma \concat \lrangles{v})$ $=$\\
$(\lambda \sigma_{x} . \ \iotabot (
				(\hover \sigma_{x}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{x})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{x}))_{\dbot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$(\iotabot (\sigma \concat \lrangles{x}))$ $=$\\
$\iotabot (\sigma \concat \sigmaover \concat \lrangles{x})$ $=$\\
$\iotabot (head_{C'}(\sigma \concat \sigmaover \concat \lrangles{v}) \concat \lrangles{x})$ $=$
$a' \ x \ (\sigma \concat \sigmaover \concat \lrangles{v})$\\

\item S\'i $\kappa \neq \iota$,\\

$(\semBrcks{\pi,\iota:\deltavar}(\hhat,\shat)
([ \ \semBrcks{\pi}(\hover,\sover)\eta \ | \ \iota:\lrangles{a,e} \ ]))\kappa$ $=$
$\semBrcks{\pi,\iota:\deltavar}(\hhat,\shat)(\semBrcks{\pi}(\hover,\sover)\eta) \kappa$\\

$[ \ \semBrcks{\pi}(h',s')(\semBrcks{\pi}(h,s)\eta) \ | \ \iota:\lrangles{a',e'} \ ] \kappa$ $=$
$\semBrcks{\pi}(h',s')(\semBrcks{\pi}(h,s)\eta)\kappa$\\

para probar esto vamos a utilizar que $\semBrcks{\pi}$ es funtor como ya hemos hecho
para el caso de la abstracci\'on lambda. Es decir, deber\'iamos probar que 
$(\hover \circ \hhat,\shat \circ \sover) = (h \circ h',s' \circ s)$. Supongamos
$f : C \rightarrow C_\bot$\\

$(\hover \circ \hhat) (\sigma \concat \sigmaover \concat \lrangles{v})$ $=$
$\hover (\hhat (\sigma \concat \sigmaover \concat \lrangles{v}))$ $=$
$\hover (\sigma \concat \lrangles{v})$ $=$ $\sigma$\\

$(h \circ h') (\sigma \concat \sigmaover \concat \lrangles{v})$ $=$
$h (h' (\sigma \concat \sigmaover \concat \lrangles{v}))$ $=$
$h (\sigma \concat \sigmaover)$ $=$ $\sigma$\\

para la segunda funci\'on de la flecha, supongamos adem\'as 
$f(\hover(\hhat (\sigma \concat \sigmaover \concat \lrangles{v}))) = \iota \sigmatil$ y empecemos
notando que \\
$f(\hover(\hhat (\sigma \concat \sigmaover \concat \lrangles{v})))$
$=$ $f(h(h'(\sigma \concat \sigmaover \concat \lrangles{v})))$ $=$
$f(h(\sigma \concat \sigmaover))$\\

$(\shat \circ \sover) \ f \ (\sigma \concat \sigmaover \concat \lrangles{v})$ $=$
$\shat (\sover \ f) \ (\sigma \concat \sigmaover \concat \lrangles{v})$ $=$\\
$(\lambda \sigma_{v} . \
				(\hover \sigma_{v}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{v})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$(\sover \ f (\hhat (\sigma \concat \sigmaover \concat \lrangles{v})))$ $=$\\
$(\lambda \sigma_{v} . \
				(\hover \sigma_{v}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{v})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
$((\lambda \sigma . \ \sigma \concat \lrangles{v})_{\bot} 
	(f (\hover (\hhat (\sigma \concat \sigmaover \concat \lrangles{v}))))$ $=$\\
$(\lambda \sigma_{v} . \
				(\hover \sigma_{v}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{v})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \
$((\lambda \sigma . \ \sigma \concat \lrangles{v})_{\bot} (\iotabot \sigmatil))$ $=$\\
$(\lambda \sigma_{v} . \
				(\hover \sigma_{v}) \concat 
				tail_{\Cover}(tail_{C'}(\sigma' \concat \lrangles{v})) \concat
				tail_{\lrangles{S_\delta}}\sigma_{v})_{\bot}$\\
\indent \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \  \ \ \ \
  \ \ \ \ \ \ \ \ \ \ \ \ \
$(\iotabot (\sigmatil \concat \lrangles{v}))$ $=$\\
$\iotabot (\sigmatil \concat \sigmaover \concat \lrangles{v})$\\

$(s' \circ s) \ f \ (\sigma \concat \sigmaover \concat \lrangles{v})$ $=$
$(s' (s \ f) \ (\sigma \concat \sigmaover \concat \lrangles{v})$ $=$\\
$(\lambda \sigma . \ \sigma \concat \lrangles{v})_{\bot} 
		((s \ f) (h'(\sigma \concat \sigmaover \concat \lrangles{v})))$ $=$\\
$(\lambda \sigma . \ \sigma \concat \lrangles{v})_{\bot}
((\lambda \sigma . \ \sigma \concat \sigmaover)_{\bot} (f \ (h (\sigma \concat \sigmaover))))$ $=$\\
$(\lambda \sigma . \ \sigma \concat \lrangles{v})_{\bot} 
		(\iotabot (\sigmatil \concat \sigmaover))$ $=$
$\iotabot (\sigmatil \concat \sigmaover \concat \lrangles{v})$\\

Finalmente, con la igualdad entre estas flechas que acabamos de probar, hemos completado
la prueba de naturalidad para el comando $\cnew \deltavar$ y adem\'as hemos completado
la prueba de naturalidad para nuestro lenguaje $\Alike$.
\end{itemize}
\end{itemize}
\end{itemize}
\end{proof}

\section{Implementaci\'on en Idris}

Sintaxis de los tipos de dato b\'asicos de $\Alike$

\begin{code}
data DataType = IntDT | RealDT | BoolDT
\end{code}

\noindent Sem\'antica de los tipos de dato b\'asicos de $\Alike$

\begin{code}
evalDTy : DataType -> Type
evalDTy IntDT  = Int
evalDTy RealDT = Float
evalDTy BoolDT = Bool
\end{code}

\noindent Sintaxis de los tipos de las frases de $\Alike$
\begin{code}
data PhraseType = IntExp | RealExp | BoolExp 
                | IntAcc | RealAcc | BoolAcc
                | IntVar | RealVar | BoolVar
                | PhraseType :-> PhraseType
                | Comm

-- Conversión entre tipos
dtTOacc : DataType -> PhraseType
dtTOacc IntDT  = IntAcc
dtTOacc RealDT = RealAcc
dtTOacc BoolDT = BoolAcc

dtTOexp : DataType -> PhraseType
dtTOexp IntDT  = IntExp
dtTOexp RealDT = RealExp
dtTOexp BoolDT = BoolExp

dtTOvar : DataType -> PhraseType
dtTOvar IntDT  = IntVar
dtTOvar RealDT = RealVar
dtTOvar BoolDT = BoolVar

evalTyArgs : PhraseType -> Type
evalTyArgs IntExp  = Int
evalTyArgs RealExp = Float
evalTyArgs BoolExp = Bool

ptToDt : PhraseType -> DataType
ptToDt IntExp  = IntDT
ptToDt RealExp = RealDT
ptToDt BoolExp = BoolDT

\end{code}

\noindent Sem\'antica de los tipos de las frases de $\Alike$
\begin{code}
-- Semántica para los phrase types aplicada a objetos con forma.
evalTyO : PhraseType -> Shp -> Type
evalTyO IntExp             C = shapes C -> Int
evalTyO RealExp            C = shapes C -> Float
evalTyO BoolExp            C = shapes C -> Bool
evalTyO IntAcc             C = Int -> evalTyO Comm C
evalTyO RealAcc            C = Float -> evalTyO Comm C
evalTyO BoolAcc            C = Bool -> evalTyO Comm C
evalTyO IntVar             C = (evalTyO IntAcc  C, evalTyO IntExp C)
evalTyO RealVar            C = (evalTyO RealAcc C, evalTyO RealExp C)
evalTyO BoolVar            C = (evalTyO BoolAcc C, evalTyO BoolExp C)
evalTyO Comm               C = shapes C -> shapes C
evalTyO (Theta :-> Theta') C = (C':Shp) -> evalTyO Theta (C ++ C') -> evalTyO Theta' (C ++ C')

-- Transforma la semántica de un tipo en un cierto objeto c, en la semántica
-- de un tipo en otro objeto c', pero mientras c=c' .
convEvTyCtx : {Pt : PhraseType} -> (C : Shp) -> (C' : Shp) -> C = C' -> 
              evalTyO Pt C -> evalTyO Pt C'
convEvTyCtx c c refl eval = eval

-- Semántica para los phrase types aplicada a morfismos entre objetos.
evalTyM : {C:Shp} -> {C':Shp} -> (t:PhraseType) -> C <= C' -> evalTyO t C -> evalTyO t C'
evalTyM IntExp             (morp (h,s,_)) e         = e . h
evalTyM RealExp            (morp (h,s,_)) e         = e . h
evalTyM BoolExp            (morp (h,s,_)) e         = e . h
evalTyM IntAcc             (morp (h,s,_)) a         = s . a
evalTyM RealAcc            (morp (h,s,_)) a         = s . a
evalTyM BoolAcc            (morp (h,s,_)) a         = s . a
evalTyM IntVar             (morp (h,s,_)) (a,e)     = (s . a, e . h)
evalTyM BoolVar            (morp (h,s,_)) (a,e)     = (s . a, e . h)
evalTyM RealVar            (morp (h,s,_)) (a,e)     = (s . a, e . h)
evalTyM Comm               (morp (h,s,_)) c         = s c
evalTyM {C=c} {C'=c'} (Theta :-> Theta') (morp (h,s,(c1 ** p))) f = 
                    \c'' => \v => contract c'' (f (c1++c'') (expand c'' v))
    where
        concatProof : (c'':Shp) -> c' ++ c'' = (c++c1) ++ c''
        concatProof c'' = eqConcat c' (c++c1) c'' p
        
        assocRProof : (c'':Shp) -> (c++c1)++c'' = c++(c1++c'')
        assocRProof c'' = assocR c c1 c''
        
        transProof : (c'':Shp) -> c' ++ c'' = c ++ (c1 ++ c'')
        transProof c'' = trans (concatProof c'') (assocRProof c'')
        
        symmProof : (c'':Shp) -> c ++ (c1 ++ c'') = c' ++ c''
        symmProof c'' = symmShp (transProof c'')
        
        expand : (c'':Shp) -> evalTyO Theta (c'++c'') -> evalTyO Theta (c++(c1++c''))
        expand c'' v = convEvTyCtx (c'++c'') (c ++ (c1 ++ c'')) (transProof c'') v
        
           contract : (c'':Shp) -> evalTyO Theta' (c++(c1++c'')) -> evalTyO Theta' (c'++c'')
        contract c'' v = convEvTyCtx (c ++ (c1 ++ c'')) (c'++c'') (symmProof c'') v

-- Propiedad de que la semántica de un tipo en un objeto c, es la semántica
-- de ese tipo en el objeto c++ShpUnit.
convL : {Pt : PhraseType} -> {C : Shp} -> evalTyO Pt C -> evalTyO Pt (C ++ ShpUnit)
convL {C=c} eval = convEvTyCtx c (c++ShpUnit) (neutDShp c) eval

-- Propiedad de que la semántica de un tipo en un objeto c++ShpUnit, es la semántica
-- de ese tipo en el objeto c.
convR : {Pt : PhraseType} -> {C : Shp} -> evalTyO Pt (C ++ ShpUnit) -> evalTyO Pt C
convR {C=c} eval = convEvTyCtx (c++ShpUnit) c (neutLShp c) eval

toAcc : {c:Shp} -> {pt:PhraseType} -> 
        (d:DataType) -> evalTyO pt c -> evalDTy d -> shapes c -> shapes c
toAcc {pt=IntAcc}  IntDT  p = p
toAcc {pt=RealAcc} RealDT p = p
toAcc {pt=BoolAcc} BoolDT p = p

toExp : {c:Shp} -> {pt:PhraseType} -> 
        (d:DataType) -> evalTyO pt c -> shapes c -> evalDTy d
toExp {pt=IntExp}  IntDT  p = p
toExp {pt=RealExp} RealDT p = p
toExp {pt=BoolExp} BoolDT p = p

toComm : {c:Shp} -> {pt:PhraseType} -> evalTyO pt c -> shapes c -> shapes c
toComm {pt=Comm} p = p

fromAcc : {c:Shp} -> {pt:PhraseType} -> 
          (d:DataType) -> (evalDTy d -> shapes c -> shapes c) -> evalTyO pt c
fromAcc {pt=IntAcc}  IntDT  p = p
fromAcc {pt=RealAcc} RealDT p = p
fromAcc {pt=BoolAcc} BoolDT p = p

fromExp : {c:Shp} -> {pt:PhraseType} -> 
        (d:DataType) -> (shapes c -> evalDTy d) -> evalTyO pt c
fromExp {pt=IntExp}  IntDT  p = p
fromExp {pt=RealExp} RealDT p = p
fromExp {pt=BoolExp} BoolDT p = p

fromFun : {c:Shp} -> (pt,pt',pt'':PhraseType) -> 
          ((c':Shp) -> evalTyO pt (c++c') -> evalTyO pt' (c++c')) -> evalTyO pt'' c
fromFun pt pt' (pt:->pt') p = p

fromVar : {c:Shp} -> {pt:PhraseType} -> 
        (d:DataType) -> ( evalDTy d -> shapes c -> shapes c
                        , shapes c -> evalDTy d
                        ) -> evalTyO pt c
fromVar {pt=IntVar}  IntDT  p = p
fromVar {pt=RealVar} RealDT p = p
fromVar {pt=BoolVar} BoolDT p = p
\end{code}

\noindent Sintaxis y sem\'antica de los contexto de $\Alike$
\begin{code}
-- ################## Versión sintácticas ##################
mutual
    -- Representación de un contexto sintáctico.
    data Ctx : Type where
        CtxUnit : Ctx
        Prepend : (p:Ctx) -> (i:Identifier) -> (pt:PhraseType) -> 
                  Fresh p i -> Ctx
    -- Representa si un identificador es fresco para un contexto.
    data Fresh : Ctx -> Identifier -> Type where
        FUnit : (i:Identifier) -> Fresh CtxUnit i
        FCons : (i:Identifier) -> (pt':PhraseType) -> (i':Identifier) -> 
                (p:Ctx) -> (fi':Fresh p i') -> so (i/=i') -> (Fresh p i) -> 
                Fresh (Prepend p i' pt' fi') i

-- Representa la pertenencia de un identificador en un contexto.
data InCtx : Ctx -> Identifier -> Type where
    InHead : (p:Ctx) -> (i:Identifier) -> (pt:PhraseType) -> 
             (fi:Fresh p i) -> InCtx (Prepend p i pt fi) i
    InTail : (p:Ctx) -> (i:Identifier) -> (pt:PhraseType) -> 
             (j:Identifier) -> (fj:Fresh p j) -> 
             InCtx p i -> InCtx (Prepend p j pt fj) i

-- ################## Versión semánticas ##################

-- Semántica de un contexto en un objeto con forma.
-- Representación de un contexto semántico.
evalCtxO : Ctx -> Shp -> Type
evalCtxO CtxUnit C = ()
evalCtxO (Prepend p _ pt _) C = (evalCtxO p C, evalTyO pt C)

-- Semántica de un contexto aplicado a morfismos entre objetos.
evalCtxM : {C:Shp} -> {C':Shp} -> 
           (p:Ctx) -> C <= C' -> evalCtxO p C -> evalCtxO p C'
evalCtxM CtxUnit m _ = ()
evalCtxM (Prepend p i pt _) m (eta,etai) = (evalCtxM p m eta, evalTyM pt m etai)

-- Transforma un environment con forma C, en uno con forma C ~: Dt
liftEta : (c:Shp) -> (dt:DataType) -> (p:Ctx) -> 
          evalCtxO p c -> evalCtxO p (c ~: dt)
liftEta c dt p eta = evalCtxM p (c >>> (ShpUnit ~: dt)) eta

-- Transforma un environment con forma C, en uno con forma C++C'
liftEta' : (c:Shp) -> (c':Shp) -> (p:Ctx) -> evalCtxO p c -> 
           evalCtxO p (c ++ c')
liftEta' c c' p eta = evalCtxM p (c >>> c') eta

-- Buscar el valor de un identificador en un contexto semántico.
search : (c:Shp) -> (p:Ctx) -> (i:Identifier) -> (pt:PhraseType) ->
         InCtx p i -> evalCtxO p c -> evalTyO pt c
search _ (Prepend _ i pt _) i pt (InHead _ i pt fi) (eta,v) = v
search c (Prepend ctx j pt _) i pt (InTail _ _ pt j _ inc) (eta,_) = search c ctx i pt inc eta

-- Actualizar el valor de un identificador.
update : (c:Shp) -> (p:Ctx) -> evalCtxO p c -> (i:Identifier) -> 
         (pt:PhraseType) -> evalTyO pt c -> (fi:Fresh p i) -> evalCtxO (Prepend p i pt fi) c
update _ p eta i pt z fi = (eta,z)
\end{code}

\noindent Representaci\'on de la categor\'ia de formas
\begin{code}
-- Constructor de morfismo entre dos objetos con forma.
infixr 10 >>>
-- Pegar por detras para objetos con forma.
infixr 10 ~:
-- Concatenar objetos con forma.
infixl 8 ++
-- Concatenar shapes.
infixl 8 <++>

-- Representa la forma del estado de la parte imperativa.
data Shp = ShpUnit | (~:) Shp DataType

instance Eq Shp where
    ShpUnit == ShpUnit = True
    (c~:dt) == (c'~:dt') = dt == dt' && c == c'
    _ == _ = False

-- Transformación de un objeto con forma a la representación
-- de un conjunto de estados con esa forma.
shapes : Shp -> Type
shapes ShpUnit = ()
shapes (c~:dt) = (shapes c,evalDTy dt)

-- Concatena objetos con forma.
(++) : Shp -> Shp -> Shp
C' ++ ShpUnit = C'
C' ++ (c ~: dt) = (C' ++ c) ~: dt

-- Establece la igualdad cuando pegamos por delante a objetos con forma.
cong : (C:Shp) -> (C':Shp) -> (C=C') -> (C ~: dt = C' ~: dt)
cong c c refl = refl

-- Propiedad de simetria para los objetos con forma.
symmShp : {C : Shp} -> {C' : Shp} -> C = C' -> C' = C
symmShp cEqc' = sym cEqc'

eqConcat : (C : Shp) -> (C' : Shp) -> (C'':Shp) -> C = C' -> C++C'' = C'++C''
eqConcat c c c'' refl = refl

trans : {C : Shp} -> {C' : Shp} -> {C'' : Shp} -> C = C' -> C' = C'' -> C = C''
trans refl refl = refl

assocL : (C : Shp) -> (C' : Shp) -> (C'' : Shp) -> C ++ (C' ++ C'') = (C ++ C') ++ C''
assocL c c' ShpUnit = refl
assocL c c' (c'' ~: dt) = cong (c++(c'++c'')) ((c++c')++c'') (assocL c c' c'')

assocR : (C : Shp) -> (C' : Shp) -> (C'' : Shp) -> (C ++ C') ++ C'' = C ++ (C' ++ C'')
assocR c c' ShpUnit = refl
assocR c c' (c'' ~: dt) = cong ((c++c')++c'') (c++(c'++c'')) (assocR c c' c'')

-- Propiedad de neutro a derecha.
neutDShp : (C:Shp) -> C = (C ++ ShpUnit)
neutDShp ShpUnit = refl
neutDShp (c ~: dt) = cong c (c ++ ShpUnit) (neutDShp c)

-- Propiedad de neutro a izquierda.
neutLShp : (C:Shp) -> (C ++ ShpUnit) = C
neutLShp ShpUnit = refl
neutLShp (c ~: dt) = cong (c ++ ShpUnit) c (neutLShp c)

-- Toma el tramo inicial con forma C, de un estado con forma C++C'
head : (C : Shp) -> (C' : Shp) -> shapes (C ++ C') -> shapes C
head c ShpUnit shp = shp
head c (c' ~: dt) (s,d') = head c c' s

-- Toma el tramo final con forma C', de un estado con forma C++C'
tail : (C : Shp) -> (C' : Shp) -> shapes (C ++ C') -> shapes C'
tail c ShpUnit shp = ()
tail c (c' ~: dt) (s,d')  = (tail c c' s,d')

-- Toma el ultimo elemento de tipo Dt del estado con forma C.
last : (C : Shp) -> (Dt:DataType) -> shapes C -> evalDTy Dt
last (c ~: dt) dt (s,v) = v

-- Concatena shapes.
(<++>) : {C:Shp} -> {C' : Shp} -> shapes C -> shapes C' -> shapes (C ++ C')
(<++>) {C'=ShpUnit} s _ = s
(<++>) {C'=c~:dt} s (s',d) = (s <++> s',d)

-- Agrega un valor por detras al estado.
prependShp : {c:Shp} -> {dt:DataType} -> 
            shapes c -> evalDTy dt -> shapes (c ~: dt)
prependShp s z = (s,z)

eqShape : Shp -> Shp -> Shp -> Type
eqShape c c' c'' = c' = c ++ c''

-- Representa un morfismo entre dos objetos con forma.
data (<=) : Shp -> Shp -> Type where 
        morp : {C:Shp} -> {C':Shp} -> 
               ( shapes C' -> shapes C
               , (shapes C -> shapes C) -> (shapes C' -> shapes C')
               , ( c'' : Shp ** eqShape C C' c'')
               ) -> C <= C'

-- Constructor de un morfismo entre dos objetos.
(>>>) : (C : Shp) -> (C' : Shp) -> C <= (C ++ C')
c >>> c' = morp (head c c', sim, (c' ** refl))
    where
        sim : (shapes c -> shapes c) -> (shapes (c ++ c') -> shapes (c ++ c'))
        sim f sigma' = f (head c c' sigma') <++> tail c c' sigma'
\end{code}

\noindent Sintaxis del subtipado.
\begin{code}
data (<~) : PhraseType -> PhraseType -> Type where
    VarToAcc : BoolVar <~ BoolAcc
    VarToExp : BoolVar <~ BoolExp
    
    IntExpToRealExp : IntExp <~ RealExp
    RealAccToIntAcc : RealAcc <~ IntAcc
    
    Reflx : (t:PhraseType) -> t <~ t
    Trans : {t:PhraseType} -> {t':PhraseType} -> {t'':PhraseType} -> 
            t <~ t' -> t' <~ t'' -> t <~ t''
    
    SubsFun : {t0:PhraseType} -> {t0':PhraseType} -> 
              {t1:PhraseType} -> {t1':PhraseType} -> 
              t0 <~ t0' -> t1 <~ t1' -> (t0' :-> t1) <~ (t0 :-> t1')
\end{code}

\noindent Sem\'antica del subtipado
\begin{code}
evalLeq : t <~ t' -> (C:Shp) -> evalTyO t C -> evalTyO t' C
evalLeq VarToAcc c (a,e)    = a
evalLeq VarToExp c (a,e)    = e
evalLeq IntExpToRealExp c f = prim__intToFloat . f
evalLeq {t'=t} (Reflx t) c f = f
evalLeq (Trans leq leq') c f = evalLeq leq' c $ evalLeq leq c f
evalLeq (SubsFun leq leq') c f = \c' => evalLeq leq' (c ++ c') . (f c') . evalLeq leq (c ++ c')
\end{code}

\noindent Juicios de tipado del lenguaje $\Alike$
\begin{code}
using (Pi:Ctx,Theta:PhraseType,Theta':PhraseType)
    data Phrase : Ctx -> PhraseType -> Type where
        Skip    : Phrase Pi Comm
        Seq     : Phrase Pi Comm -> Phrase Pi Comm -> Phrase Pi Comm
        While   : Phrase Pi BoolExp -> Phrase Pi Comm -> Phrase Pi Comm
        If      : {pt :PhraseType} -> Phrase Pi BoolExp -> 
                  Phrase Pi pt -> Phrase Pi pt -> Phrase Pi pt
        
        I       : (i:Identifier) -> InCtx Pi i -> Phrase Pi Theta
        Assig   : (d:DataType) -> Phrase Pi (dtTOacc d) -> 
                  Phrase Pi (dtTOexp d) -> Phrase Pi Comm
        NewVar : (d:DataType) -> (i:Identifier) -> Phrase Pi (dtTOexp d) -> 
                 (fi:Fresh Pi i) -> Phrase (Prepend Pi i (dtTOvar d) fi) Comm -> 
                 Phrase Pi Comm
        
        CInt    : Int   -> Phrase Pi IntExp
        CFloat  : Float -> Phrase Pi RealExp
        CBool   : Bool  -> Phrase Pi BoolExp
        
        BinOp : {a : DataType} -> {b : DataType} -> {d : DataType} -> 
                (evalDTy a -> evalDTy b -> evalDTy d) -> 
                Phrase Pi (dtTOexp a) -> Phrase Pi (dtTOexp b) -> Phrase Pi (dtTOexp d)
        UnOp  : {a:DataType} -> {b:DataType} -> 
                (evalDTy a -> evalDTy b) -> 
                Phrase Pi (dtTOexp a)  -> Phrase Pi (dtTOexp b) 

        Lam   : (i:Identifier) -> (pt:PhraseType) -> (fi:Fresh Pi i) ->
                Phrase (Prepend Pi i pt fi) Theta' -> 
                Phrase Pi (pt :-> Theta')
        App    : Phrase Pi (Theta :-> Theta') -> Phrase Pi Theta -> 
                 Phrase Pi Theta'
        Rec    : Phrase Pi (Theta :-> Theta) -> Phrase Pi Theta
        
        Subs   : t <~ t' -> Phrase Pi t -> Phrase Pi t'
\end{code}

\noindent Sem\'antica de las frases de $\Alike$
\begin{code}
evalPhrase : {Pi:Ctx} -> {Theta:PhraseType} -> 
             Phrase Pi Theta -> (C:Shp) -> evalCtxO Pi C -> evalTyO Theta C
evalPhrase (Subs leq var) c eta = evalLeq leq c (evalPhrase var c eta)
-- Semántica para los comandos.
evalPhrase (Assig d a e) c eta = \sigma => (\x => evalAcc x sigma) (evalExp sigma)
    where
        evalAcc : evalDTy d -> shapes c -> shapes c
        evalAcc = toAcc d $ evalPhrase a c eta
        evalExp : shapes c -> evalDTy d
        evalExp = toExp d $ evalPhrase e c eta
evalPhrase Skip c eta = \sigma => sigma
evalPhrase (Seq comm comm') c eta = \sigma => evalPhrase comm' c eta (evalPhrase comm c eta sigma)
evalPhrase (While b comm) c eta = fix (\f => \sigma => 
                                            if evalPhrase b c eta sigma 
                                                then f (evalPhrase comm c eta sigma)
                                                else sigma)
evalPhrase {Pi=p} {Theta=pt} (I i iIn) c eta = search c p i pt iIn eta
-- Semántica para los valores constantes.
evalPhrase (CInt i)   c eta = \sigma => i
evalPhrase (CFloat r) c eta = \sigma => r
evalPhrase (CBool b)  c eta = \sigma => b
evalPhrase (BinOp {a} {b} {d} op x y) c eta = fromExp d (\sigma => (op (z sigma) (z' sigma)))
    where z : shapes c -> evalDTy a
          z = toExp a $ evalPhrase x c eta
          z' : shapes c -> evalDTy b
          z' = toExp b $ evalPhrase y c eta
evalPhrase (UnOp {a} {b} op x) c eta = fromExp b (\sigma => op (z sigma))
    where
        z : shapes c -> evalDTy a
        z = toExp a $ evalPhrase x c eta
evalPhrase {Theta=(pt :-> t')} {Pi=p} (Lam i pt fi b) c eta = evalLambda
    where
        newLeta : (C':Shp) -> evalTyO pt (c ++ C') -> evalCtxO (Prepend p i pt fi) (c ++ C')
        newLeta c' z = update (c++c') p (liftEta' c c' p eta) i pt z fi
        
        evalLambda : (C':Shp) -> evalTyO pt (c ++ C') -> evalTyO t' (c ++ C')
        evalLambda c' z = evalPhrase b (c++c') (newLeta c' z)
evalPhrase (App e e') c eta = convR $ (evalPhrase e c eta ShpUnit) (convL $ evalPhrase e' c eta)
evalPhrase (Rec e) c eta = fix $ convR . (evalPhrase e c eta ShpUnit) . convL
evalPhrase {Theta=pt} (If {pt} b e e') c eta =
            case pt of
                Comm        => makeComm Comm
                IntExp      => makeExp IntDT
                RealExp     => makeExp RealDT
                BoolExp     => makeExp BoolDT
                IntAcc      => makeAcc IntDT
                RealAcc     => makeAcc RealDT
                BoolAcc     => makeAcc BoolDT
    where
        makeComm : (pt:PhraseType) -> evalTyO pt c
        makeComm Comm = \sigma => if evalPhrase b c eta sigma
                                    then toComm (evalPhrase e c eta) sigma
                                    else toComm (evalPhrase e' c eta) sigma
        makeAcc : DataType -> evalTyO pt c
        makeAcc dt = fromAcc dt (\z => \sigma => if evalPhrase b c eta sigma
                                                    then toAcc dt (evalPhrase e c eta) z sigma
                                                    else toAcc dt (evalPhrase e' c eta) z sigma)
        makeExp : DataType -> evalTyO pt c
        makeExp dt = fromExp dt (\sigma => if evalPhrase b c eta sigma
                                                then toExp dt (evalPhrase e c eta) sigma
                                                else toExp dt (evalPhrase e' c eta) sigma)
evalPhrase {Pi=p} (NewVar d i vInit fi comm) c eta = 
        \sigma => head c shpDT (evalComm (prependShp {dt=d} sigma (evalInit sigma)))
    where
        shpDT : Shp
        shpDT = ShpUnit ~: d
        
        a : evalDTy d -> shapes (c ~: d) -> shapes (c ~: d)
        a = \x => \sigma' => prependShp (head c shpDT sigma') x
        e : shapes (c ~: d) -> evalDTy d
        e = last (c ~: d) d
        
        evalInit : shapes c -> evalDTy d
        evalInit = toExp d $ evalPhrase vInit c eta
        
        zvar : evalTyO (dtTOvar d) (c ~: d)
        zvar = fromVar d (a,e)
        
        newAeta : evalCtxO (Prepend p i (dtTOvar d) fi) (c ~: d)
        newAeta = update (c ~: d) p (liftEta c d p eta) i (dtTOvar d) zvar fi
        
        evalComm : evalTyO Comm (c ~: d)
        evalComm = evalPhrase comm (c ~: d) newAeta

\end{code}
