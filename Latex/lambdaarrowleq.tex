\chapter{Calculo lambda simplemente tipado y con subtipos}
\label{chap:lambdaarrow}

En este cap\'itulo presentamos dos lenguajes, el primer lenguaje, es un
lenguaje funcional con tipado explicito simple. La idea de comenzar con 
este lenguaje, \'el cual ya tiene sem\'antica bien conocida, es introducir
conceptos principales sobre los sistemas de tipado simple, as\'i
como de la sem\'antica denot\'acional del lenguaje, ademas es lo 
suficientemente simple como para no eclipsar el aprendizaje de 
conceptos sobre la implementaci\'on utilizando tipos dependientes.
El segundo lenguaje mantiene las mismas expresiones que el primero
pero vamos a extender los tipos para que soporten subtipado.\\

El c\'apitulo va a estar separado en dos secciones, el estudio
de lambda arrow y el estudio de lambda leq. A su vez, en cada
uno estar\'an las definiciones sint\'acticas, sem\'anticas y de tipos
relacionadas a cada lenguaje.

\section{Lambda arrow}

\subsection{Sint\'axis}

En esta secci\'on vamos a introducir la sint\'axis de dos lenguajes, 
la de $\lambdaarrow$ y la del lenguaje de los tipos.
Con este ultimo vamos a querer representar los conjuntos de booleanos, enteros
y reales, ademas del conjunto de funciones que tiene como dominio
e imagen a cualquiera de los conjuntos anteriores.

Empezamos introduciendo la sint\'axis abstracta de los tipos simples.

\setlength{\grammarindent}{6em}
\begin{grammar}

<Type> ::= $\boolt$ | $\intt$ | $\realt$
\alt <Type> $\rightarrow$ <Type>

\end{grammar}

Como mencion\'abamos antes, $\boolt$, $\intt$ y $\realt$ representaran 
los conjuntos de booleanos, enteros y reales respectivamente, y el
$\theta \rightarrow \theta'$ sera la representaci\'on del conjunto
de funciones que acepta valores de tipo $\theta$ y retorna valores
de tipo $\theta'$. Hay que mencionar que $\rightarrow$ asocia a derecha.\\

Ahora que tenemos el lenguaje de los tipos podemos dar la sint\'axis
abstracta del lenguaje.

\setlength{\grammarindent}{6em}
\begin{grammar}

<Phrase> ::= <PBool> | <PInt> | <PReal>
\alt $\odot$ <Phrase> | <Phrase> $\circledcirc$ <Phrase>
\alt \textbf{if} <Phrase> \textbf{then} <Phrase> \textbf{else} <Phrase>
\alt <Id> 
\alt <Phrase> <Phrase>
\alt $\lambda$ <Id>$_\theta$ . <Phrase>
\alt \textbf{rec} <Phrase>

<PBool> ::= True | False

<PNat>  ::= 0 | 1 | 2 | ...

<PInt>  ::= ... | -2 | -1 | <PNat> 

<PReal> ::= <PNat>.\{<PNat>\}+ 
\alt - <PNat>.\{<PNat>\}+

\end{grammar}

\noindent
donde \ 

$\lrangles{\textit{Id}}$ es un conjunto numerable.

$\theta \in \lrangles{Type}$ \

$\odot \in \{-, \neg\}$ y \

$\circledcirc \in \{+,-,*,/,\div,\rem,\wedge,\vee,\Rightarrow,\Leftrightarrow, =,\neq,<,>,\leq,\geq\}$

\subsection{Tipos simples}

Antes de continuar con la sem\'antica del lenguaje del c\'apitulo
vamos a introducir contextos, juicio de tipado, reglas de inferencia de tipos y
sem\'antica de los tipos.\\

Un contexto ser\'a una lista de pares que relacionan un identificador 
con un tipo, con la restricci\'on de que no pueden
existir identificadores repetidos, esta restricci\'on no es menor y mas
adelante cuando tengamos definidas las reglas de inferencia vamos a
ver alguna consecuencia de esta elecci\'on. En particular, para
definir los contextos usamos una gram\'atica, esta elecci\'on 
nos va a permitir tener una versi\'on sint\'actica de los contextos
y ademas una sem\'antica la cual, un poco mas adelante, vamos a
necesitar para definir la sem\'antica del lenguaje.

\begin{definition}\label{lambdaa:context}

Un contexto estar\'a definido por la siguiente gram\'atica,\

\begin{grammar}

<Context> ::= $\varnothing$ | <Context>,<Id>:<Type>

\end{grammar}

\end{definition}

Ahora que tenemos definido los contextos, podemos definir que es un juicio de 
tipado. 

\begin{definition}\label{lambdaa:typejugment}

Un juicio de tipado sera una relaci\'on entre un contexto $\pi$, una
expresi\'on del lenguaje $e$ y un tipo $\theta$ que establecer\'a que
bajo el contexto $\pi$ la expresi\'on $e$ tiene tipo $\theta$.\\

Lo denotaremos como  $\pi \vdash e : \theta$.

\end{definition}

\subsubsection{Reglas de inferencia}

Antes definimos los contextos como listas de pares y dimos restricciones 
en el sentido de que no cualquier lista de pares era una contexto valido,
ahora necesitamos algo parecido para los juicios de tipado, queremos
una manera de decidir que juicios son validos y cuales no, para esto
vamos a definir las reglas de inferencia, pero antes establezcamos algunas
metavariables generales:

\begin{center}
\begin{tabular}{ l r }
	$\theta$ $\lrangles{Type}$ & $\pi$ $\lrangles{Context}$ \\
	$\delta$ $\{ \boolt,\intt,\realt \}$ & \\
	$e$ $\lrangles{Phrase}$ & $x$ $\lrangles{Id}$ \\
	$n$, $m$ \ \ $\N$ & $b$ \ \ $\B$ \\
	$i$ \ \ $\Z$ & $r$ \ \ $\R$ 
\end{tabular}
\end{center}

\noindent 
Ahora s\'i presentamos las reglas de inferencia:

\

\

\

\noindent
$\texttt{Ty Rule:}$ Constantes.

\begin{center}
\AxiomC{}
\UnaryInfC{$\pi \vdash b : \boolt$}
\DisplayProof
\quad
\AxiomC{}
\UnaryInfC{$\pi \vdash i : \intt$}
\DisplayProof
\quad
\AxiomC{}
\UnaryInfC{$\pi \vdash r : \realt$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ Operadores b\'asicos.

\begin{center}
\AxiomC{$\pi \vdash e : \intt$}
\UnaryInfC{$\pi \vdash -e : \intt$}
\DisplayProof
\quad
\AxiomC{$\pi \vdash e : \realt$}
\UnaryInfC{$\pi \vdash -e : \realt$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{$\pi \vdash e : \boolt$}
\UnaryInfC{$\pi \vdash \neg e : \boolt$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{$\pi \vdash e : \intt$}
\AxiomC{$\pi \vdash e' : \intt$}
\RightLabel{$\otimes \in \{+,-,*,/\ , \textbf{rem}\}$}
\BinaryInfC{$\pi \vdash e \otimes e' : \intt$}
\DisplayProof

\quad

\quad

\AxiomC{$\pi \vdash e : \realt$}
\AxiomC{$\pi \vdash e' : \realt$}
\RightLabel{$\otimes \in \{+,-,*\}$}
\BinaryInfC{$\pi \vdash e \otimes e' : \realt$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{$\pi \vdash e : \boolt$}
\AxiomC{$\pi \vdash e' : \boolt$}
\RightLabel{$\owedge \in \{\wedge,\vee,\Rightarrow,\Leftrightarrow\}$}
\BinaryInfC{$\pi \vdash e \owedge e' : \boolt$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{$\pi \vdash e : \delta$}
\AxiomC{$\pi \vdash e' : \delta$}
\RightLabel{$\delta \in \{\intt, \realt \}, \olessthan \in \{<,>,\leq,\geq\}$}
\BinaryInfC{$\pi \vdash e \olessthan e' : \boolt$}
\DisplayProof
\end{center}

\

\begin{center}
\AxiomC{$\pi \vdash e : \delta$}
\AxiomC{$\pi \vdash e' : \delta$}
\RightLabel{$\ominus \in \{=,\neq\}$}
\BinaryInfC{$\pi \vdash e \ominus e' : \boolt$}
\DisplayProof
\end{center}

Hasta aqu\'i hemos definido las reglas de inferencia para las constantes y
operadores b\'asicos, algo particular en relaci\'on a estas reglas es que,
por la clase de expresiones el tipado es implicito, en contraste como veremos
a continuaci\'on con la regla para la abstracci\'on lambda. Ademas el contexto
no juega ning\'un papel para determinar la valides de un juicio.\\

Veamos ahora las reglas referentes a la parte del calculo lambda simplemente tipado, 
ademas de la regla para el tipado de un identificador.

\

\noindent
$\texttt{Ty Rule:}$ Aplicaci\'on.

\begin{center}
\AxiomC{$\pi \vdash e : \theta \rightarrow \theta'$}
\AxiomC{$\pi \vdash e': \theta$}
\BinaryInfC{$\pi \vdash ee' : \theta'$}
\DisplayProof
\end{center}

\

\

\noindent
$\texttt{Ty Rule:}$ Operador de punto fijo.

\begin{center}
\AxiomC{$\pi \vdash e : \theta \rightarrow \theta$}
\UnaryInfC{$\pi \vdash \rec{e} : \theta$}
\DisplayProof
\end{center}

En la regla de tipado de un identificador se observa como hace falta
consultar el contexto para determinar el tipo del identificador. Esta
consulta ayuda a chequear, por supuesto el tipo, pero ademas que el
identificador no este libre.

\

\noindent
$\texttt{Ty Rule:}$ Identificador.

\begin{center}
\AxiomC{}
\RightLabel{$v:\theta \in \pi$}
\UnaryInfC{$\pi \vdash v : \theta$}
\DisplayProof
\end{center}

En la regla anterior consult\'abamos el contexto, en la regla para
la abstracci\'on lambda vamos a agregar un identificador con su respectivo 
tipo. La abstracci\'on lambda la podr\'iamos haber definido de dos maneras bien distintas,
con tipado explicito o tipado impl\'icito, la diferencia esta en si especificamos
el tipo del identificador o no. La elecci\'on final fue utilizar tipado explicito
ya que no hace falta inferir el tipo del identificador, el cual para este lenguaje
peque√±o puede realizarse utilizando el algoritmo Hindley-Milner pero que es
extremadamente ineficiente. Ademas como el plan es ir extendiendo este lenguaje,
para formar nuevos, ya no va a ser cierto que se pueda inferir el tipo de un 
identificador algoritmicamente.

\

\noindent
$\texttt{Ty Rule:}$ Abstracci\'on lambda.

\begin{center}
\AxiomC{$\pi,\iota:\theta \vdash e : \theta'$}
\UnaryInfC{$\pi \vdash \clambda{\iota}{\theta}{e} : \theta \rightarrow \theta'$}
\DisplayProof
\end{center}

Para terminar con la reglas de inferencia de este lenguaje tenemos la regla de la
expresi\'on condicional.

\

\noindent
$\texttt{Ty Rule:}$ Expresi\'on condicional.

\begin{center}
\AxiomC{$\pi \vdash b  : \boolt$}
\AxiomC{$\pi \vdash e  : \theta$}
\AxiomC{$\pi \vdash e' : \theta$}
\TrinaryInfC{$\pi \vdash \cifthenelse{b}{e}{e'} : \theta$}
\DisplayProof
\end{center}

Ahora que tenemos todas las reglas de inferencia definidas podemos mencionar
algo que hab\'iamos anticipado cuando definimos contextos, en relaci\'on a la
restricci\'on que estos tienen. Empecemos considerando la frase 
$\clambda{\iota}{\intt}{\clambda{\iota}{\intt} \ \iota \times \iota}$ y supongamos
no existe ninguna restricci\'on sobre los contextos, luego podemos dar
una derivaci\'on con las reglas de inferencia que hemos dado tal que valide 
el siguiente juicio de tipado 
$\vdash \clambda{\iota}{\intt}
		{\clambda{\iota}{\intt} \ \iota \times \iota : \intt \rightarrow \intt \rightarrow \intt}$.
		
La pregunta que surge, ahora que tenemos que este juicio es valido y por lo tanto
deber\'iamos poder evaluar nuestra frase, esta relacionada con la doble
ocurrencia de $\iota$. ¬ø Cuando aplicamos esta frase a dos frases enteras, 
que valor debe tomar $\iota$ ?; Para lidiar entonces con esto, es que
tenemos la restricci\'on sobre los contextos, la idea es que ahora
con la restricci\'on la frase $\clambda{\iota}{\intt}{\clambda{\iota}{\intt} \ \iota \times \iota}$
no pertenece a ning\'un juicio de tipado valido.

\subsubsection{Sem\'antica}

Ahora vamos a definir la sem\'antica de los tipos y los contextos, para esto vamos a
definir los dominios sem\'anticos usando categor\'ias y las ecuaciones
sem\'anticas usando sem\'antica denotacional. 

Vamos a necesitar de tres categor\'ias, una sera de los tipos ($\lrangles{Type}$),
otra de contextos ($\lrangles{Context}$) y finalmente una para el significado 
de los juicios de tipado. Lo interesante sobre utilizar categor\'ias, sobre
todo para el significado de los juicios de tipado, ser\'a la capacidad de
adaptar las ecuaciones sem\'anticas a las distintas caracter\'isticas del lenguaje.

\begin{definition}\label{lambdaa:typescategory}
La categor\'ia de tipos, que nombraremos $\Theta$, sera una categor\'ia discreta tal que 
la colecci\'on de objetos esta definida como,

$\Theta_0$ $=$ $\{\theta \ | \ \theta \ \in \lrangles{Type} \}$\\

\end{definition}

\begin{definition}\label{lambdaa:contextcategory}
La categor\'ia de contextos, que nombraremos $\Pi$, sera una categor\'ia discreta tal que 
la colecci\'on de objetos esta definida como,

$\Pi_0$ $=$ $\{\pi \ | \ \pi \ \in \lrangles{Context} \}$\\

\end{definition}

La categor\'ia sem\'antica, que nombraremos $\CD$, sera una categor\'ia cartesiana 
cerrada, la cual iremos adaptando seg\'un las necesidades de nuestro lenguaje. 
Tanto para $\lambdaarrow$ como para $\lambdaleq$ esta sera $\Dom$.\\

Antes de continuar con las definiciones sem\'anticas hagamos un repaso de cual es
la categor\'ia $\Dom$, esta tiene por objetos a dominios y por flechas a
funciones continuas. Adem\'as como caracter\'istica que nos va a interesar, 
tenemos la existencia del operador de punto fijo que representaremos como $\Y_D$
con $D$ un dominio y cuya existencia la garantiza (ref Reynolds Prop 2.5), como
ya hemos mencionado es $\CCC$, donde el producto entre dos objetos $D$ y $D'$ 
es el producto cartesiano de conjuntos y el exponencial $D^{D'}$ es el conjunto 
de funciones de $D'$ en $D$.\\

Ahora s\'i, con los dominios necesarios, podemos definir dos funtores, 
uno entre $\Theta$ y $\CD$, y otro entre $\Pi$ y $\CD$. Esto implica definir 
funciones, que mapee objetos en objetos y flechas en flechas, ahora como $\Theta$ y $\Pi$ 
son discreta, la definici\'on de estas ultimas funciones es directa, por lo 
tanto vamos a definir el mapeo de objetos en objetos.
En general cuando definamos funtores vamos a hacer uso de los indicies, pero luego
cuando los utilicemos vamos a dejarlos de lado.

Mencionamos adem\'as que con $\bot$ vamos a representar la no terminaci\'on, esto
va a hacer falta ya que nuestro lenguaje b\'asico incluye operador de punto fijo.

\begin{definition}\label{lambdaa:typesemfunctor}
Sea $\semBrcks{ \_ } : \Theta \rightarrow \CD$ un funtor, tal que

$\semBrcks{\delta}_0$ $=$ $(S_\delta)_\bot$\\
\indent
$\semBrcks{\theta \rightarrow \theta'}_0$ $=$ $\semBrcks{\theta'}_0^{\semBrcks{\theta}_0}$

\end{definition}

Notar que como $\CD$ es $\mathcal{CCC}$ entonces podemos asegurar que existe el objeto exponencial.

\begin{definition}\label{lambdaa:contextsemfunctor}
Sea $\semBrcks{ \_ } : \Pi \rightarrow \CD$ un funtor, tal que

$\semBrcks{\pi}_0$ $=$ $\prod\limits_{\iota \in dom \ \pi} \semBrcks{\pi\iota}$

\end{definition}

Notar que como $\CD$ es $\mathcal{CCC}$ entonces tenemos productos finitos, como los
contextos son siempre finitos, la definici\'on es correcta.

\subsection{Sem\'antica}

Estamos en condiciones de definir las ecuaciones sem\'anticas, para quien este
familiarizado con la definici\'on de sem\'antica denotacional de lenguajes sin tipado
podemos comentar que las ecuaciones sem\'anticas se definen sobre un juicio 
de tipado y no sobre las expresiones en s\'i. Esto implica entonces, que para evaluar
un programa este antes debe haber typecheckeado correctamente.

Una ecuaci\'on sem\'antica entonces estar\'a definida por un juicio de tipado valido,
supongamos $\pi \vdash e : \theta$, un objeto de la categor\'ia $\CD$, determinado por 
el funtor $\semBrcks{\pi}$, otro objeto de $\CD$, determinado por $\semBrcks{\theta}$ y
un funtor sobre el juicio de tipado, tal que, 
$\semBrcks{\pi \vdash e : \theta} : \semBrcks{\pi} \rightarrow \semBrcks{\theta}$.\\

Agregamos a nuestra lista de metavariables, $\eta$ con tipo $\semBrcks{\pi}$.

\

\noindent
$\texttt{Denotal Sem:}$ Constantes.\

\begin{center}
$\semBrcks{\pi \vdash b : \boolt} \eta$ $=$ $\iotabot b$\\

\

$\semBrcks{\pi \vdash i : \intt} \eta$  $=$ $\iotabot i$\\

\

$\semBrcks{\pi \vdash r : \realt} \eta$ $=$ $\iotabot r$
\end{center}
\

\noindent
$\texttt{Denotal Sem:}$ Operadores b\'asicos.\

\begin{center}

$\semBrcks{\pi \vdash -e : \intt}$ $=$ $(\lambda x \in S_\intt . \iotabot -x)_{\dbot} \circ \semBrcks{\pi \vdash e : \intt}$\\

\

$\semBrcks{\pi \vdash -e : \realt}$ $=$ $(\lambda x \in S_\realt .\iotabot -x)_{\dbot} \circ \semBrcks{\pi \vdash e : \realt}$\\

\

$\semBrcks{\pi \vdash \neg e : \boolt}$ $=$ $(\lambda x \in S_\boolt . \iotabot \neg x)_{\dbot} \circ \semBrcks{\pi \vdash e : \boolt}$

\end{center}

\noindent
$\semBrcks{\pi \vdash e \otimes e' : \intt}\eta$ $=$ \\
				\indent \indent \indent $(\lambda x \in S_\intt . 
											(\lambda x' \in S_\intt . \iotabot (x \otimes x'))_{\dbot}
													\semBrcks{\pi \vdash e' : \intt}\eta)_{\dbot}
														\semBrcks{\pi \vdash e : \intt}\eta$

\begin{center}
con $\otimes \in \{+,-,*,/\ , \rem\}$
\end{center}

\noindent
$\semBrcks{\pi \vdash e \otimes e' : \realt}\eta$ $=$ \\
				\indent \indent \indent $(\lambda x \in S_\realt . 
											(\lambda x' \in S_\realt . \iotabot (x \otimes x'))_{\dbot}
													\semBrcks{\pi \vdash e' : \realt}\eta)_{\dbot}
														\semBrcks{\pi \vdash e : \realt}\eta$

\begin{center}
con $\otimes \in \{+,-,*\}$
\end{center}

\noindent
$\semBrcks{\pi \vdash e \owedge e' : \boolt}\eta$ $=$ \\
				\indent \indent \indent $(\lambda x \in S_\boolt . 
											(\lambda x' \in S_\boolt . \iotabot (x \owedge x'))_{\dbot}
													\semBrcks{\pi \vdash e' : \boolt}\eta)_{\dbot}
														\semBrcks{\pi \vdash e : \boolt}\eta$

\begin{center}
con $\owedge \in \{\wedge,\vee,\Rightarrow,\Leftrightarrow\}$
\end{center}

\begin{center}

$\semBrcks{\pi \vdash e \olessthan e' : \boolt}\eta$ $=$ $(\lambda x \in S_\delta . 
											(\lambda x' \in S_\delta . \iotabot (x \olessthan x'))_{\dbot}
													\semBrcks{\pi \vdash e' : \delta}\eta)_{\dbot}
														\semBrcks{\pi \vdash e : \delta}\eta$

\

con $\delta \in \{\intt, \realt \}, \olessthan \in \{<,>,\leq,\geq\}$
\end{center}

\begin{center}

$\semBrcks{\pi \vdash e \ominus e' : \boolt}\eta$ $=$ $(\lambda x \in S_\delta . 
											(\lambda x' \in S_\delta . \iotabot (x \ominus x'))_{\dbot}
													\semBrcks{\pi \vdash e' : \delta}\eta)_{\dbot}
														\semBrcks{\pi \vdash e : \delta}\eta$

\

con $\ominus \in \{=,\neq\}$
\end{center}

Hasta aqu\'i tenemos definida la sem\'antica para las expresiones enteras,
reales y booleanas. Definamos ahora la parte interesante del lenguaje, esto 
sera, la expresi\'on condicional, aplicaci\'on, abstracci\'on lambda, operador
de punto fijo e identificador.

\

\noindent
$\texttt{Denotal Sem:}$ Expresi\'on condicional.\

\

$\semBrcks{\pi \vdash \cifthenelse{b}{e}{e'} : \theta}\eta$ $=$\\
		\indent \indent \indent $(\lambda b \in S_{\boolt} .$ if $b$ \\
		\indent \indent \indent \indent \indent \indent \indent 
											then $\semBrcks{\pi \vdash e : \theta}\eta$\\
		\indent \indent \indent \indent \indent \indent \indent 
											else $\semBrcks{\pi \vdash e' : \theta}\eta)_{\dbot}\semBrcks{\pi \vdash b : \boolt}\eta$

\

\noindent
$\texttt{Denotal Sem:}$ Aplicaci\'on.\

\

$\semBrcks{\pi \vdash ee' : \theta'}\eta$ $=$ $\semBrcks{\pi \vdash e : \theta \rightarrow \theta'}\eta
														  (\semBrcks{\pi \vdash e' : \theta}\eta)$

\

\noindent
$\texttt{Denotal Sem:}$ Abstracci\'on lambda.\

\

$\semBrcks{\pi \vdash \clambda{\iota}{\theta}{e} : \theta \rightarrow \theta'}\eta$ $=$
						$\lambda x \in \semBrcks{\theta}$ . $\semBrcks{\pi,\iota:\theta \vdash e : \theta'}[\ \eta \ | \ \iota:x \ ]$
						
\

\noindent
$\texttt{Denotal Sem:}$ Operador de punto fijo.\

\

$\semBrcks{\pi \vdash \rec{e} : \theta}\eta$ $=$ $\Y_{\theta} (\semBrcks{\pi \vdash e : \theta \rightarrow \theta}\eta)$

\

\noindent
$\texttt{Denotal Sem:}$ Identificador.\

\

$\semBrcks{\pi \vdash \iota : \theta}\eta$ $=$ $\eta \iota$\\

Estas ultimas ecuaciones nos terminan de definir la sem\'antica de nuestro 
primer lenguaje lambda arrow.\\

Ahora que tenemos nuestro lenguaje definido tanto sint\'acticamente como
sem\'anticamente, veamos algunas propiedades y caracter\'isticas. Tomemos
la ecuaci\'on sem\'antica de la abstracci\'on lambda y analic\'emosla un 
poco, podemos empezar notando que el significado que le estamos dado
a la abstracci\'on lambda de nuestro lenguaje se corresponde exactamente
con la noci\'on de funci\'on, de hecho, no hay que confundir la letra lambda
que ocurre en el lado izquierdo de la que ocurre en el lado derecho de la
ecuaci\'on. Con esto en mente analicemos un poco mas de cerca la definici\'on,\\

$\semBrcks{\pi \vdash \clambda{\iota}{\theta}{e} : \theta \rightarrow \theta'}\eta$ $:$
$\semBrcks{\theta'}^{\semBrcks{\theta}}$\\

\noindent
esto recordando que $\semBrcks{\theta \rightarrow \theta'}$ $=$ $\semBrcks{\theta'}^{\semBrcks{\theta}}$,
es decir, como ya mencionamos antes, el significado de la abstracci\'on lambda es
una funci\'on en $\Dom$, que va de $\semBrcks{\theta}$ en $\semBrcks{\theta'}$. Mirando
ahora la parte derecha,\\

$\lambda x \in \semBrcks{\theta}$ . 
				$\semBrcks{\pi,\iota:\theta \vdash e : \theta'}[\ \eta \ | \ \iota:x \ ]$ $:$
				$\semBrcks{\theta} \rightarrow \semBrcks{\theta'}$\\

\noindent
vemos que efectivamente es una funci\'on en el dominio correcto, adem\'as en\\

$\semBrcks{\pi,\iota:\theta \vdash e : \theta'}$ $:$ 
								$\semBrcks{pi,\iota:\theta} \rightarrow \semBrcks{\theta'}$\\

\noindent
la aplicaci\'on del entorno $[\ \eta \ | \ \iota:x \ ]$ extendido tipa perfecto 
con $\semBrcks{pi,\iota:\theta}$ dando como resultado el tipo esperado,\\

$\semBrcks{\pi,\iota:\theta \vdash e : \theta'}[\ \eta \ | \ \iota:x \ ]$ $:$ $\semBrcks{\theta'}$.\\

Acabamos de ver un poco mas de cerca la ecuaci\'on sem\'antica de la abstracci\'on
lambda, lo que vamos a hacer a continuaci\'on es probar que nuestra sem\'antica 
denotacional es correcta con respecto a la regla de reducci\'on $\beta$, para esto
vamos a necesitar el teorema de substituci\'on. Para enunciar y probar este teorema
vamos a tener que introducir un nuevo tipo de juicio de tipado as\'i como tambi\'en
algunos conceptos de substituci\'on, como la idea es no meternos en mucho tecnicismo
presentemos r\'apidamente las herramientas que vamos a necesitar.\\

Empecemos introduciendo por parte de la substituci\'on el operador $\Delta$ que 
sera un map entre $\lrangles{Id}$ y $\lrangles{Phrase}$ que representara una
substituci\'on de identificadores por frases, y una funci\'on
$FV$ de $\lrangles{Phrase}$ en $\lrangles{Id}$ que determinara los
identificadores libres de una frase.\\

Adem\'as, vamos a necesitar de un juicio de tipado nuevo cuyo significado
ser\'a que dado un identificador $\iota$ y una substituci\'on $\Delta$, 
la substituci\'on de $\iota$ por $\Delta\iota$ en una frase conserva el 
tipado. Dados $\pi$, $\pi'$ contextos y $\delta$, vamos a representar el 
nuevo juicio como $\pi \vdash \Delta : \pi'$.

\begin{theorem}[De substituci\'on]
Sean $\pi$ y $\pi'$ contextos, $\delta$ una substituci\'on y supongamos
tenemos dos juicios de tipado $\pi' \vdash e : \theta$, $\pi \vdash \delta : \pi'$ 
tal que \\

$\eta'\iota$ $=$ $\semBrcks{\pi \vdash \delta\iota : \pi'\iota}$
para todo $\iota \in \ dom \ \pi'$, entonces\\
 
$\semBrcks{\pi' \vdash e : \theta}\eta'$ $=$ $\semBrcks{\pi \vdash e / \Delta : \theta}\eta$.

\end{theorem}


\begin{proof}
Procedamos por inducci\'on en la estructura de la derivaci\'on de los juicios de tipado.\\

\begin{itemize}

\item Casos base
\begin{itemize}
\item Supongamos $\pi \vdash b : \boolt$, luego tenemos 
$\semBrcks{\pi \vdash b : \boolt}\eta'$ $=$ $\iotabot b$ $=$ 
$\semBrcks{\pi' \vdash b : \boolt}\eta$ $=$ $\semBrcks{\pi' \vdash b / \delta : \boolt}\eta$.

\item (An\'alogo para $\intt$ y $\realt$).

\item Supongamos $\pi' \vdash \iota : \theta$, luego 
$\semBrcks{\pi' \vdash \iota : \theta}\eta'$ $=$ $\eta'\iota$
ahora por hip\'otesis tenemos que 
$\eta'\iota$ $=$ $\semBrcks{\pi \vdash \delta\iota : \pi'\iota}\eta$ $=$
$\semBrcks{\pi \vdash \iota / \delta : \theta}\eta$.
\end{itemize}

\item Casos inductivos,
\begin{itemize}
\item Supongamos $\pi' \vdash e \ominus e' : \boolt$, luego tenemos \\
$\semBrcks{\pi' \vdash e \ominus e' : \boolt}\eta'$ $=$
	$(\lambda x . 
		(\lambda x' . \iotabot (x \ominus x'))_{\dbot}
					\semBrcks{\pi' \vdash e' : \boolt}\eta')_{\dbot}
						\semBrcks{\pi' \vdash e : \boolt}\eta'$ \\
						
por hip\'otesis inductiva dos veces\\

$(\lambda x . 
		(\lambda x' . \iotabot (x \ominus x'))_{\dbot}
					\semBrcks{\pi' \vdash e' / \delta : \boolt}\eta)_{\dbot}
						\semBrcks{\pi' \vdash e / \delta : \boolt}\eta$ $=$
						
$\semBrcks{\pi' \vdash (e / \delta) \ominus (e' / \delta) : \boolt}\eta$ $=$
$\semBrcks{\pi' \vdash (e \ominus e') / \delta : \boolt}\eta$.\\

\item An\'alogo dem\'as operadores binarios, un\'arios, expresi\'on condicional
aplicaci\'on y operador de punto fijo.\\

\item Supongamos $\pi' \vdash \clambda{\iota}{\theta}{e} : \theta \rightarrow \theta'$, luego
$\semBrcks{\pi' \vdash \clambda{\iota}{\theta}{e} : \theta \rightarrow \theta'}\eta'$ $=$
$\lambda x . \semBrcks{\pi',\iota:\theta \vdash e : \theta'}[ \eta' \ | \ \iota:x ]$ \\

ahora, probando * y luego aplicando hip\'otesis inductiva obtenemos,\\

$\lambda x . \semBrcks{\pi,\iota':\theta \vdash e / \delta' : \theta'}[ \eta \ | \ \iota':x ]$ $=$
$\semBrcks{\pi \vdash \clambda{\iota'}{\theta}{e / \delta'} : \theta \rightarrow \theta'}\eta$ $=$
$\semBrcks{\pi \vdash (\clambda{\iota}{\theta}{e}) / \delta' : \theta \rightarrow \theta'}\eta$\\

donde $\delta' = [ \delta \ | \ \iota:\iota' ]$ y 
$\iota' \not\in \bigcup\limits_{\kappa \in FV(e)-\{\iota\}} (FV(\delta\kappa))$

\begin{itemize}
\item Para poder aplicar la hip\'otesis inductiva tenemos que probar que vale que,\\

para todo $\kappa \in \ dom (\widehat{\pi})$, donde $\widehat{\pi} = \pi',\iota:\theta$, \\

$[ \eta' \ | \ \iota:x ]\kappa$ $=$ 
$\semBrcks{\pi,\iota':\theta \vdash \delta'\kappa : \widehat{\pi}\kappa}[ \eta \ | \ \iota':x ]$.\\

Tomamos un $\kappa$ cualquiera, y vamos a separar en dos casos, si $\kappa \not= \iota$ entonces
es directo aplicando la hip\'otesis. Veamos que sucede si suponemos $\kappa = \iota$,\\

$[ \eta' \ | \ \iota:x ]\kappa$ $=$ $x$ y\\

$\semBrcks{\pi,\iota':\theta \vdash \delta'\kappa : \widehat{\pi}\kappa}[ \eta \ | \ \iota':x ]$ $=$
$\semBrcks{\pi,\iota':\theta \vdash \iota' : \theta}[ \eta \ | \ \iota':x ]$ $=$
$[ \eta \ | \ \iota':x ]\iota'$ $=$ $x$.

Por lo tanto podemos aplicar la hip\'otesis inductiva.\\

\end{itemize}
\end{itemize}
\end{itemize}

\end{proof}

%es analizar categ\'oricamente la abstracci\'on
%lambda aplicada a una frase, es decir vamos a suponer un juicio de tipado
%$\pi \vdash (\clambda{\iota}{\theta}{e})e' : \theta'$, vamos a ver que las flechas
%que vamos a obtener coinciden exactamente con la definici\'on de la ecuaci\'on 
%sem\'antica de la aplicaci\'on.

Por otro lado, una propiedad importante que deben cumplir nuestras 
ecuaciones sem\'anticas es ser funciones continuas, no hay que olvidar
que cuando decimos que, dado un juicio $\pi \vdash e : \theta$, el tipo
de nuestra ecuaci\'on ser\'a $\semBrcks{\pi} \rightarrow \semBrcks{\theta}$, ese 
tipo representa un conjunto de funciones continuas en $\Dom$. Es decir, para
verdaderamente estar seguros que las definiciones que hemos dado son 
correctas, debemos probar que las ecuaciones sem\'anticas son funciones 
continuas. Para terminar adem\'as vamos a probar que la sem\'antica 
denotacional 

\begin{proposition}\

\begin{enumerate}

\item Supongamos f es un funci\'on monotona del predominio $P$ en el predominio $P'$,
entonces f ser\'a una funci\'on continua si y solo si, para toda cadena
interesante $x_0 \sqsubseteq x_1 \sqsubseteq \cdots$ en $P$,

\begin{center}
$f (\bigsqcup\limits^{\infty}_{i=0} x_i) \sqsubseteq {\bigsqcup\limits^{\infty}_{i=0}}' f (x_i)$
\end{center}

\item Si $P$ y $P'$ son predominios, $P \rightarrow P'$ es un predominio en
el cual el limite de la cadena de funciones $f_0 \sqsubseteq'' f_1 \sqsubseteq'' \cdots$ 
es una funci\'on tal que 

\begin{center}
$({\bigsqcup\limits^{\infty}_{i=0}}'' f_{i})x = {\bigsqcup\limits^{\infty}_{i=0}}' f_{i} x$
\end{center}

para todo $x \in P$. Adem\'as, si $P$ es un dominio, $P \rightarrow P'$ es un dominio
cuyo menor elemento es una funci\'on tal que $\bot'' x = \bot'$ para todo $x \in P$.

\item Supongamos $P$ y $P'$ son predominios, entonces:

\begin{enumerate}
\item[(a)] Una funci\'on constante de $P$ en $P'$ es una funci\'on continua de $P$ en $P'$.\\

\item[(b)] La funci\'on identidad en $P$ es una funci\'on continua de $P$ en $P$.\\

\item[(c)] Si f es una funci\'on continua de $P$ en $P'$ y g es una funci\'on
continua de $P'$ en $P''$, entonces $g \circ f$ es una funci\'on continua de $P$ en $P''$.\\

\item[(d)] Si f es una funci\'on continua de $P$ en $P'$, entonces $\_ \circ f$ es una funci\'on
continua de $P' \rightarrow P''$ en $P \rightarrow P''$.\\

\item[(e)] Si g es una funci\'on continua de $P'$ en $P''$, entonces $g \circ \_$ es una funci\'on
continua de $P \rightarrow P'$ en $P \rightarrow P''$.

\end{enumerate}

\end{enumerate}

\end{proposition}

\begin{proposition}

Dado un juicio de tipado $\pi \vdash e : \theta$ la ecuaci\'on sem\'antica
\\ 
$\semBrcks{\pi \vdash e : \theta}$ es una funci\'on continua.

\end{proposition}

\begin{proof}

En la prueba vamos a proceder por inducci\'on en la estructura de la derivaci\'on 
de los juicios de tipado.\\

Para probar los casos base usamos Prop 1.3.a, que nos asegura que una funci\'on
constante es funci\'on continua. Continuemos entonces con los casos inductivos,
supongamos tenemos un juicio de tipado $\pi \vdash e : \theta$ tal que
$\semBrcks{\pi \vdash e : \theta}$ es una funci\'on continua y probemos
que dado un juicio de tipado $\pi \vdash e : \theta$ mas complejo,
$\semBrcks{\pi \vdash e : \theta}$ es una funci\'on continua.\\

La idea es usar Prop 1.1, para esto supongamos tenemos una cadena interesante
$\eta_0 \sqsubseteq \eta_1 \sqsubseteq \cdots$ en $\semBrcks{\pi}$ y probemos
para cada caso inductivo que $\semBrcks{\pi \vdash e : \theta}(\bigsqcup\limits^{\infty}_{i=0} \eta_i)$
$=$ $\bigsqcup\limits^{\infty}_{i=0} \semBrcks{\pi \vdash e : \theta} (\eta_i)$.

\begin{itemize}

\item Supongamos tenemos $\pi \vdash ee' : \theta$,\\

$\semBrcks{\pi \vdash ee' : \theta}(\bigsqcup\limits^{\infty}_{i=0} \eta_i)$ $=$
$\semBrcks{\pi \vdash e : \theta \rightarrow \theta'}(\bigsqcup\limits^{\infty}_{i=0} \eta_i)
			(\semBrcks{\pi \vdash e' : \theta}(\bigsqcup\limits^{\infty}_{i=0} \eta_i))$\\

hasta ac\'a hemos usado la definici\'on de la ecuaci\'on de la aplicaci\'on, ahora usando 
hip\'otesis inductiva dos veces tenemos,\\

$\semBrcks{\pi \vdash e : \theta \rightarrow \theta'}(\bigsqcup\limits^{\infty}_{i=0} \eta_i)
			(\semBrcks{\pi \vdash e' : \theta}(\bigsqcup\limits^{\infty}_{i=0} \eta_i))$ $=$
\begin{flushright}
$=$ $(\bigsqcup\limits^{\infty}_{i=0} \semBrcks{\pi \vdash e : \theta \rightarrow \theta'} (\eta_i))
					(\bigsqcup\limits^{\infty}_{i=0} \semBrcks{\pi \vdash e' : \theta}(\eta_i))$
\end{flushright}
					
notar que podemos ver a $\semBrcks{\pi \vdash e : \theta \rightarrow \theta'} (\eta_i)$
como una funci\'on $f_i$, lo que nos permite usar Prop 1.2, dar un paso en la igualdad y
continuar hasta el resultado esperado,\\

\begin{center}

$(\bigsqcup\limits^{\infty}_{i=0} \semBrcks{\pi \vdash e : \theta \rightarrow \theta'} (\eta_i))
					(\bigsqcup\limits^{\infty}_{i=0} \semBrcks{\pi \vdash e' : \theta}(\eta_i))$ 
$=$\\
\

$=$ 
$\bigsqcup\limits^{\infty}_{i=0} (
		\semBrcks{\pi \vdash e : \theta \rightarrow \theta'}(\eta_i)
					(\bigsqcup\limits^{\infty}_{j=0} \semBrcks{\pi \vdash e' : \theta}(\eta_j)))$ 
$=$\\
\

$=$
$\bigsqcup\limits^{\infty}_{i=0} \bigsqcup\limits^{\infty}_{j=0}$
$\semBrcks{\pi \vdash e : \theta \rightarrow \theta'}(\eta_i)(\semBrcks{\pi \vdash e' : \theta}(\eta_j))$ 
$=$\\
\

$=$
$\bigsqcup\limits^{\infty}_{k=0}$
$\semBrcks{\pi \vdash e : \theta \rightarrow \theta'}(\eta_k)(\semBrcks{\pi \vdash e' : \theta}(\eta_k))$ 
$=$\\
\

$=$
$\bigsqcup\limits^{\infty}_{k=0}$ $\semBrcks{\pi \vdash ee' : \theta'}(\eta_k)$

\end{center}

por lo tanto la ecuaci\'on sem\'antica $\semBrcks{\pi \vdash ee' : \theta}$ es una funci\'on 
continua.

\item Los casos para el expresi\'on condicional, operador de punto fijo, identificador, 
operadores binarios y un\'arios son similares, en cada caso particular usando las Prop anteriores.

\item Supongamos tenemos $\pi \vdash \clambda{\iota}{\theta}{e} : \theta \rightarrow \theta'$,
esta en papel, todav\'ia no estoy seguro.\\

\end{itemize}


\end{proof}

\section{Lambda Leq}

En la secci\'on anterior definimos la sint\'axis y sem\'antica del lenguaje que llamamos
lambda arrow, para esto en el transcurso introducimos distintos conceptos sobre el tipado.
Ahora vamos estudiar a lambda leq, el cual tiene como fin introducir conceptos sobre
el subtipado, por esta raz\'on el lenguaje se mantiene exactamente igual al lenguaje 
de la secci\'on anterior. La principal diferencia entonces estar\'a en la definici\'on
de la categor\'ia de tipos y en que vamos a agregar un nuevo juicio de tipado, como
consecuencia de esto ultimo, tendremos que agregar nuevas reglas de tipado y ecuaciones 
sem\'anticas.\\

\subsection{Subtipado}

Entre los tipos del lenguaje lambda arrow, y por lo tanto los de lambda leq, tenemos
a $\intt$ y $\realt$ los cuales representan los conjuntos de enteros y reales matem\'aticos.
Algo interesante a pensar es que, los enteros forman parte de los reales, es decir,
$\Z \subseteq \R$, luego surge la pregunta, ¬øExistir\'a una forma de expresar esta relaci\'on 
como una relaci\'on entre los $\lrangles{Type}$?, la respuesta es s\'i y es el subtipado.\\

\subsubsection{Reglas de inferencia}

Comencemos introduciendo el nuevo juicio de tipado, este sera una relaci\'on entre tipos,
sean $\theta$ y $\theta'$ diremos que $\theta$ es subtipo de $\theta'$ cuando $\theta \leq \theta'$.

Primero veamos reglas de inferencia generales a cualquier tipo, empecemos discutiendo
una idea intuitiva de las reglas que ser\'ian deseables. Supongamos tenemos que la expresi\'on
$e$ tiene tipo $\intt$ y adem\'as que $\intt$ es subtipo de $\realt$, luego quisi\'eramos 
poder decir que $e$ tiene tipo $\realt$, adem\'as si suponemos un tipo $nat$ que es
subtipo de $int$, entonces deber\'iamos poder decir que $nat$ es subtipo de $\realt$,
es decir, tener transitividad entre los tipos, cualquier tipo es
subtipo de \'el mismo, es decir, los tipos son reflexivos. Para finalizar, 
supongamos tenemos $\theta_0 \leq \theta_0'$ y $\theta_1 \leq \theta_1'$ y adem\'as
que tenemos una expresi\'on $e$ que tiene tipo $\theta_0' \rightarrow \theta_1$. Luego
$e$ puede aplicarse a elementos de tipo $\theta_0$ y el resultado de tal aplicaci\'on
puede ser un elemento de tipo $\theta_1'$.

Empecemos presentando las reglas que representan lo que mencion\'abamos anteriormente.

\

\noindent
$\texttt{Ty Rule:}$ Subsumption.

\begin{center}
\AxiomC{$\pi \vdash e : \theta$}
\AxiomC{$\theta \leq \theta'$}
\BinaryInfC{$\pi \vdash e : \theta'$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ Trans.

\begin{center}
\AxiomC{$\theta \leq \theta'$}
\AxiomC{$\theta' \leq \theta''$}
\BinaryInfC{$\theta \leq \theta''$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ Reflex.

\begin{center}
\AxiomC{}
\UnaryInfC{$\theta \leq \theta$}
\DisplayProof
\end{center}

\

\noindent
$\texttt{Ty Rule:}$ Func.

\begin{center}
\AxiomC{$\theta_0 \leq \theta_0'$}
\AxiomC{$\theta_1 \leq \theta_1'$}
\BinaryInfC{$\theta_0' \rightarrow \theta_1 \leq \theta_0 \rightarrow \theta_1'$}
\DisplayProof
\end{center}

Estas reglas que mencionamos tiene la particularidad de ser generales para
cualquier sistema de tipado, definamos ahora mas reglas en relaci\'on a nuestros
tipos y lenguaje concreto, esto sera definir la relaci\'on entre enteros y reales
y vamos a agregar una mas, tal vez no sea lo mas recomendado en cuanto al dise√±o
del lenguaje pero es practico considerarla, que es la relaci\'on entre booleanos
y enteros.

\

\noindent
$\texttt{Ty Rule:}$ boolToint.

\begin{center}
\AxiomC{}
\UnaryInfC{$\boolt \leq \intt$}
\DisplayProof
\end{center}

\noindent
$\texttt{Ty Rule:}$ intToreal.

\begin{center}
\AxiomC{}
\UnaryInfC{$\intt \leq \realt$}
\DisplayProof
\end{center}

\subsubsection{Sem\'antica}

Ahora que tenemos definido el nuevo juicio de tipado y la relaci\'on entre los 
tipos, vamos a actualizar nuestra categor\'ia de tipos, esta dejara de ser
una categor\'ia discreta y la clave esta en que ahora nuestra relaci\'on entre
los tipos determinara las flechas.

\begin{definition}\label{lambdal:typescategory}
La categor\'ia de tipos, que nombraremos $\Theta$, se define como sigue

$\Theta_0$ $=$ $\{\theta \ | \ \theta \ \in \lrangles{Type} \}$\\
\indent
$\Theta_1(\theta,\theta')$ $=$ $\{\theta \rTo \theta' \ | \ \theta \leq \theta'\}$\\

\end{definition}

Esta nueva categor\'ia coincide con el poset de tipos con la relaci\'on de orden
$\leq$ visto como categor\'ia, por lo tanto se desprende que dados
dos tipos $\theta$ y $\theta'$, $| \ \Theta_1(\theta,\theta') \ | \leq \ 1$.

Ademas esta nueva definici\'on nos impacta directamente en el
funtor sem\'antico $\semBrcks{ \ } : \Theta \rightarrow \CD$, ahora tenemos que 
definir como actua el funtor con respecto a las flechas.

\begin{definition}\label{lambdal:typesemfunctor}
Sea $\semBrcks{ \ } : \Theta \rightarrow \CD$ un funtor, tal que

$\semBrcks{\delta}_0$ $=$ $(S_\delta)_\bot$\\
\indent
$\semBrcks{\theta \rightarrow \theta'}_0$ $=$ $\semBrcks{\theta'}_0^{\semBrcks{\theta}_0}$\\

\[
\semBrcks{\boolt \leq \intt}_1 \ x =
\begin{cases}
0  & \text{si } \text{x} \\
1  & \text{si } \neg \text{x}
\end{cases}
\]
\indent
$\semBrcks{\intt \leq \realt}_1$ $=$ $\J$\\
\indent
$\semBrcks{\theta \leq \theta}_1$ $=$ $1_{\semBrcks{\theta}}$\\
\indent
$\semBrcks{\theta \leq \theta''}_1$ $=$ $\semBrcks{\theta' \leq \theta''}_1 \circ \semBrcks{\theta \leq \theta'}_1$\\
\indent
$\semBrcks{(\theta_0 \rightarrow \theta'_0) \leq (\theta_1 \rightarrow \theta'_1)}_1$ 
				$=$ 
				$\lambda f \in \semBrcks{\theta_0 \rightarrow \theta'_0}_0$ .
				$\semBrcks{\theta'_0 \leq \theta'_1}_1 \circ f \circ \semBrcks{\theta_1 \leq \theta_0}_1$\\

con $\J$ la inyecci\'on de enteros en reales.

\end{definition}

La definici\'on de la relaci\'on $\leq$ entre tipos nos permite ademas actualizar 
la definici\'on de la categor\'ia de contexto, de manera tal de definir $\leq$ entre
contextos para que luego, como pasa con los tipos, esta relaci\'on sea una flecha 
en la categor\'ia. Dados $\pi$ y $\pi'$ tal que $dom \ \pi$ $=$ $dom \ \pi'$, diremos
que $\pi \leq \pi'$ cuando para todo $\iota \in dom \ \pi$ se cumple $\pi \iota \leq \pi' \iota$.

\begin{definition}\label{lambdal:contextcategory}
La categor\'ia de contextos, que nombraremos $\Pi$, se define como sigue

$\Pi_0$ $=$ $\{\pi \ | \ \pi \ \in \lrangles{Context} \}$\\
\indent
$\Pi_1(\pi,\pi')$ $=$ $\{ \pi \rTo \pi' \ | \ \pi \leq \pi' \}$

\end{definition}

De igual manera que cuando dimos la nueva definici\'on de $\Theta$, podemos dar
una actualizaci\'on a la definici\'on de $\Pi$.

\begin{definition}\label{lambdal:contextsemfunctor}
Sea $\semBrcks{ \ } : \Pi \rightarrow \CD$ un funtor, tal que

$\semBrcks{\pi}_0$ $=$ $\prod\limits_{\iota \in dom \ \pi} \semBrcks{\pi\iota}$\\
\indent
$\semBrcks{\pi \leq \pi'}_1$ $=$ $\prod\limits_{\iota \in dom \ \pi} \semBrcks{\pi\iota \leq \pi'\iota}$

\end{definition}

Esta ultima definici\'on da por terminado el trabajo de acomodar los
dominios categoricos, ademas de las nuevos jucios de tipado y su 
sem\'antica respectiva.

\subsection{Sem\'antica}

Para completar la sem\'antica del lenguaje lambda leq, nos falta 
definir una ecuaci\'on sem\'antica que relacione un juicio de tipado
con una relaci\'on de orden entre dos tipos, la ecuaci\'on que estamos
buscando relaci\'on con la regla de inferencia Subsumption.\\
\

\noindent
$\texttt{Denotal Sem:}$ Subsumption.\

\

$\semBrcks{\pi \vdash e : \theta'}$ $=$ $\semBrcks{\theta \leq \theta'} \circ \semBrcks{\pi \vdash e : \theta}$
